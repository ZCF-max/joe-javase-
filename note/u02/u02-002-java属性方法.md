# 1. 成员属性

**概念：** 类中可以存放属性变量，简称属性。
- **位置：** 
    - 如果一个变量定义在方法体中，就叫做局部变量。
    - 如果一个变量定义在方法体外，类体中，就叫这个类的成员属性。
- **分类：** 属性根据修饰符而分为六种：
    - `public String name`：公共属性：跨包任何类可见。
    - `protected String name`：保护属性：跨包父子类可见。
    - `String name`：默认属性：同包可见。
    - `private String name`：私有属性：本类可见。
    - `static String name`：静态属性：共享且唯一。
    - `final String name`：常量属性：不可二次赋值属性，建议全大写。
- **默认值：** 属性变量跟局部变量不同，属性变量拥有默认值。 
    - `byte`，`short`，`int`，`long` 默认值是0。
    - `float`，`double` 默认值是0.0。
    - `char` 默认值是空格，`\u0000`。
    - `boolean` 默认值是false。
    - 引用数据类型的默认值全都是null。

**练习：** 02002-1
1. 局部变量和属性变量的区别？

# 2. 成员方法

**概念：** 成员方法和成员属性一样，都是类中的一个成员。
- **分类：** 方法根据修饰符分为8种：
    - `public void fun(){}`：公共方法：跨包任何类可见。
    - `protected void fun(){}`：保护方法：跨包父子类可见。
    - `void fun(){}`：默认方法：同包可见。
    - `private void fun(){}`：私有方法：本类可见。
    - `static void fun(){}`：静态方法：共享且唯一。
    - `public fun(){}`：构造方法：俗称构造器，创造类时必须调用的方法。
    - `abstract void fun();` 抽象方法：一个没有方法体的方法。
    - `final void fun(){}` 最终方法：不能被重写。
- **方法四要素：**
    - **方法名：** 方法的名字，命名规范同变量名，首字母小写驼峰，尽量使用动词。
    - **返回类型：** 方法要返回给调用者一个什么类型的数据如果没返回任何数据则类型为void。
    - **形参列表：** 方法要接收哪些类型的数据，多个数据用逗号隔开如果不需要传入数据，则该方法叫做无参方法。
    - **方法体：** 方法的逻辑代码，注意最好一个方法只做一件事。

## 2.1 方法的设计思路

**流程：** 当我们想要设计一个方法的时候，建议遵循以下顺序：
1. **用途：** 我想设计一个能够将两个数字加起来得出结果的方法。
2. **访问权限：** 这个方法我只想对本类其他方法开启访问：
    - `private`
3. **静态与否：** 这个方法我想让它属于每一个实例，而不是属于类：
    - 不写 `static`
4. **返回值：** 我想让这个方法最终返回给我一个 `int` 类型的结果：
    - `private int`
5. **方法名：** 方法名就叫 `addNum`：
    - `private int addNum()`
6. **形参列表：** 我想调用这个方法的时候，肯定要接收两个int类型的变量：
    - `private int addNum(int numA, int numB)`
7. **方法体：** 编写方法的逻辑代码，一个方法只做一件事：
    - `private int addNum(int numA, int numB){...}`

**源码：**
```java
private int addNum(int numA, int numB){
    return numA + numB;
}

@Test
public int addNum(){
    int result = addNum(1, 5);
    System.out.println(result);
}
```

## 2.2 方法的调用

**源码：** 创建四种不同类型的方法，并使用junit测试调用过程。
```java
public void methodA() {
    System.out.println("普通、公共、非静态、无参");
}

public static void methodB() {
    System.out.println("普通、公共、静态、无参");
}

public void methodC(String str) {
    System.out.println("普通、公共、非静态、有参");
}

public static void methodD(String str, int b) {
    System.out.println("普通、公共、非静态、有参");
}

@Test
public void methodCall(){
    MethodCallDemo methodCallDemo = new MethodCallDemo();
    methodCallDemo.methodA();
    MethodCallDemo.methodB();
    methodCallDemo.methodC("");
    MethodCallDemo.methodD("", -1);
}
```

## 2.3 方法参数的传递

**概念：** 方法的参数在传递的时候有一个特性：
- 当传递的参数是基本数据类型的时候，代表传递副本。
- 当传递的参数是引用数据类型的时候，代表传递引用。

**源码：**
```java
private void methodA(int num) {
    num = 1000;
}

@Test
public void passCopy() {
    int num = 10;
    methodA(num);
    System.out.println(num);
}

private void methodB(int[] arr) {
    arr[0] = 1000;
}

@Test
public void passReference() {
    int[] arr = {1, 2};
    methodB(arr);
    System.out.println(Arrays.toString(arr));
}
```

**练习：** 02002-2-3
1. 使用方法编程有什么好处？
2. 静态方法可以访问非静态属性吗？
3. 静态方法可以访问静态属性吗？
4. 非静态方法可以访问静态属性吗？
5. 非静态方法可以访问非静态属性吗？
6. What is the result?
```java
public class Batman {
    int squares = 81;
    public static void main(String[] args) {
        new Batman().go();
    }
    void go() {
        incr(++squares);
        System.out.println(squares); 
    }
    void incr(int squares) { squares += 10; }
}
```
- A. 81
- B. 82
- C. 91
- D. 92
- E. Compilation fails.
- F. An exception is thrown at runtime.

7. Click the Exhibit button. What is the output of the program shown in the exhibit?
![](https://user-gold-cdn.xitu.io/2020/7/23/17379b2f6a80f6fd?w=509&h=461&f=jpeg&s=68857)
- A. 300-100-100-100-100
- B. 300-300-100-100-100
- C. 300-300-300-100-100
- D. 300-300-300-300-100

## 2.4 方法的递归调用

**概念：** 
- 递归的核心就一句话：自己调用自己。
- 递归虽然简单，但是比较耗时耗力，而且所有使用递归可以解决的问题，都能用循环来解决，所以不到万不得已的时候，不要使用递归。
- 递归必须要有出口！否则就是一个死递归。

**源码：** 死递归演示代码
```java
private void methodA() {
    System.out.println("methodA...");
    // 死递归导致堆栈溢出：StackOverflowError
    methodA();
}

@Test
public void deadRecursion() {
    methodA();
}
```

**源码：** 使用递归来求5的阶乘
```java
private int factorial(int num) {
    // 第1次 num=5 return 5 * factorial(4) 待命
    // 第2次 num=4 return 4 * factorial(3) 待命
    // 第3次 num=3 return 3 * factorial(2) 待命
    // 第4次 num=2 return 2 * factorial(1) 待命
    // 第5次 num=1 return 1
    return num == 1 ? 1 : num * factorial(num - 1);
}

@Test
public void factorialByRecursive() {
    System.out.println(factorial(5));
}
```

**图示：** 递归求阶乘过程描述
![](https://user-gold-cdn.xitu.io/2020/7/23/17379b2d42bed615?w=366&h=357&f=png&s=14674)

**源码：** 汉诺塔
```java
/**
 * @author JoeZhou
 */
public class HanoiTest {

    /**
     * @param plateNo 盘子号码
     * @param pillarA    第1根柱子
     * @param pillarB    第2根柱子
     * @param pillarC    第3根柱子
     */
    private void hanoi(int plateNo, char pillarA, char pillarB, char pillarC) {
        if (plateNo == 1) {
            System.out.printf("1号盘子：%s >> %s\n", pillarA, pillarC);
        } else {
            // 无论多少盘子都分成两部分
            // 第一部分，将plateNo-1的上面的部分看成一个盘子
            // 第二部分，最后一个盘子
            int hanoiTopPart = plateNo - 1;
            // 将上面的盘子，从pillarA途经pillarB移到pillarC
            hanoi(hanoiTopPart, pillarA, pillarC, pillarB);
            System.out.printf("%s号盘子：%s >> %s\n", plateNo, pillarA, pillarC);
            // 将上面的盘子，从pillarBb途经pillarA移到pillarC
            hanoi(hanoiTopPart, pillarB, pillarA, pillarC);
        }
    }

    @Test
    public void testHanoi() {
        hanoi(6, 'A', 'B', 'C');
    }
}
```

# 3. 初始化块

**概念：** JVM会在创建一个类和使用这个类中间的这一段时间里，执行初始化块（包括构造方法、动态块和静态块）里面的内容。

## 3.1 构造方法

**概念：** 构造方法，也叫构造器，是一种特殊的方法，当我们实例化（new）一个类的时候，就是在调用这个类的构造方法的过程，每new一次，就会调用一次。
- **特点：**
    - 构造方法的名字必须和类名一致。
    - 构造方法没有返回值也不写 `void` 和 `return`。
    - 构造方法不能被 `static` 等修饰。
- **分类：**
    - 隐式无参构造方法：这种构造方法是一个类的默认构造方法，new一个类的时候默认调用这个方法。
    - 显式无参构造方法：自己在类中编写一个没有参数的构造方法，会覆盖掉隐式无参构造方法。
    - 显式有参构造方法：自己在类中编写一个有参数的构造方法这种构造器可以写多个，它们的共存要求是参数列表不相同，new一个类的时候可以自动根据传进来的参数列表对应找到那个有参构造方法。
- 构造方法只能通过new来调用，不能使用方法的调用模式来进行调用。

**源码：** ConstructorDemo.java
```java
/**
 * @author JoeZhou
 */
public class ConstructorDemo {
    public ConstructorDemo() {
        System.out.println("ConstructorDemo 的无参构造...");
    }

    public ConstructorDemo(String str) {
        System.out.println("ConstructorDemo 的有参构造..." + str);
    }

    public ConstructorDemo(int numA, int numB) {
        System.out.println("ConstructorDemo 的有参构造..." + (numA + numB));
    }
}
```
 
**源码：**
```java
@Test
public void constructor() {
    new ConstructorDemo();
    new ConstructorDemo("赵四");
    new ConstructorDemo(15, 16);
}
```
 
## 3.2 动态块

**概念：** 动态块的格式就是 `{...}`，和构造方法一样，每new一次就会执行一次，不一样的是动态块必须全部执行，无法指定执行哪一个，而且执行顺序在构造器之前。

**源码：** DynamicBlockDemo.java
```java
/**
 * @author JoeZhou
 */
public class DynamicBlockDemo {
    public DynamicBlockDemo() {
        System.out.println("DynamicBlockDemo的构造...");
    }

    {
        System.out.println("DynamicBlockDemo的动态块01...");
    }

    {
        System.out.println("DynamicBlockDemo的动态块02...");
    }
}
```

**源码：** 
```java
@Test
public void dynamicBlock() {
    new DynamicBlockDemo();
    new DynamicBlockDemo();
    new DynamicBlockDemo();
}
```

## 3.3 静态块

**概念：** 
- 静态块的格式就是 `static{...}`，常用于一些初始化数据的工作。
- 静态块和动态块不一样，它就只执行一次，而且执行顺序在动态块之前。
- 静态块和静态方法一样，里面只能访问到静态的属性和方法。
- 静态块必须全部执行，无法指定执行哪一个。

**源码：** StaticBlockDemo.java
```java
/**
 * @author JoeZhou
 */
public class StaticBlockDemo {
    public StaticBlockDemo() {
        System.out.println("StaticBlockDemo的构造...");
    }

    {
        System.out.println("StaticBlockDemo的动态块01...");
    }

    {
        System.out.println("StaticBlockDemo的动态块02...");
    }

    static {
        System.out.println("StaticBlockDemo的静态块01...");
    }

    static {
        System.out.println("StaticBlockDemo的静态块02...");
    }
}
```

**源码：**
```java
@Test
public void dynamicBlock() {
    new StaticBlockDemo();
    new StaticBlockDemo();
    new StaticBlockDemo();
}
```

**练习：** 02002-3-3
1. Which two code fragments correctly create and initialize a static array of int elements? (Choose two.)
- A. static final int[] a = { 100,200 };
- B. static final int[] a; static { a=new int[2]; a[0]=100; a[1]=200; }
- C. static final int[] a = new int[2]{ 100,200 };
- D. static final int[] a; static void init() { a = new int[3]; a[0]=100; a[1]=200; }

2. Which code should be inserted at line 1 of Demo.java to compile and run Demo to print "pizzapizza"?
```java
package utils;
public class Repetition {
    public static String twice(String s) { return s + s; }
} 

// and given another class Demo: 

// insert code here
public class Demo {
    public static void main(String[] args) {
        System.out.println(twice("pizza"));
    }
}
```
- A. import utils.*;
- B. static import utils.*;
- C. import utils.Repetition.*;
- D. static import utils.Repetition.*;
- E. import utils.Repetition.twice();
- F. import static utils.Repetition.twice;
- G. static import utils.Repetition.twice;

> 使用静态导入可以导入类中的所有静态域：import static 包路径.类名.*：导入这个类中所有的静态域（属性和方法）。

> import static 包路径.类名.静态方法名：导入这个类中指定的静态方法。

# 4. this关键字

**概念：** java中提供this关键字，用法有两种：
- 当类中某个非静态方法的参数名和类的某个成员变量名相同时，为了避免参数的作用范围覆盖了成员变量的作用范围，必须明确的使用this关键字来指定哪个变量是当前类的成员属性。
    - `this.` 可以翻译成"当前实例的"，如 `this.name` 就是"当前类里的name属性"。
- 如果某个构造方法的第一条语句具有形式 `this(...)`，那么这个构造方法将调用本类中的其他构造方法。

**源码：** ThisDemo.java
```java
/**
 * @author JoeZhou
 */
public class ThisDemo {

    private String name;

    public ThisDemo() {
        this("赵四");
    }

    public void setName(String name) {
        this.name = name;
    }

    public ThisDemo(String str) {
        System.out.println("姓名为：" + str);
    }
    
}
```

**源码：** ThisDemo.java
```java
@Test
public void thisConstructor() {
    new ThisDemo();
    new ThisDemo("刘能");
}
```

**练习：** 02002-4
1. this能用在静态方法或静态块中吗？

# 5. POJO

**概念：** 
- POJO（Plain Ordinary Java Object）简单的Java对象，POJO中有一些属性及其getter/setter方法的类，没有业务逻辑，当然如果你有一个简单的运算属性也是可以的，但不允许有复杂的业务方法。
- 当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，它就是一个JavaBean。
- **POJO分类：**
    - `PO`：Persistant Object， 用在持久层，可以理解为POJO经过持久化后的对象。
    - `DTO`：Data Transfer Object，据传输对象，一般用于向数据层外围提供仅需的数据，如查询一个表有50个字段，界面或服务只需要用到其中的10个字段，DTO就包装出去的对象，DTO可用于隐藏数据层字段定义，也可以提高系统性能，减少不必要字段的传输损耗。
    - `VO`：View Object 用在视图层，一般用于web层向view层封装并提供需要展现的数据
    - `BO`：Business Object 用在service层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递，现在基本不用。
- 这些定义在实际使用设计中并不会全部用到，根据不同设计架构定义不同的类对象，形态大致如此，可根据自己项目进行调整。

> POJO和DOMAIN也是同一个概念。