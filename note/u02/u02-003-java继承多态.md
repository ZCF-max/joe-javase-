# 1. 继承

**概念：** 
- 所谓继承就是将父亲的非private成员拿过来直接用，但是不包括构造方法，同时也可以拥有自己的成员。
- 继承是一种 `is a` 的关系，如"鸟is a动物"，"赵四is a人"等。
- 继承在java中是单方向的（单继承），且final修饰的类不能被继承。
- 继承具有层次性和传递性。
- 继承是为了提高代码可重用性，使程序变得简单。
- 类的祖先是 `java.lang.Object` 类，如果一个类没有声明指定父类，就默认继承Object类，Object类中有一些常用的方法。
    - `toString()`：  返回代表该实例的字符串形式，格式为类名@内存地址十六进制串。
    - `equals()`：判断两个实例是否指向同一内存区域。
    - `getClass()`：得到实例对应的模板的类全名。
    - `hashCode()`：得到对象的hash码，hashCode被设计用来提高性能，如果两个实例变量内存地址相等，那么它们一定有相同的hash值，但是两个实例变量有相同的hash值，但它们未必相等。

## 1.1 继承的实现

**概念：** java中的继承通过 `extends` 关键字来完成继承关系。

**源码：** Employee.java
```java
/**
 * @author JoeZhou
 */
public class Employee implements Serializable {
    private double salary = 2000.0;
    public double getSalary() {return this.salary;}
    public void setSalary(double salary) {this.salary = salary;}
}
```

**源码：** Manager.java
```java
/**
 * @author JoeZhou
 */
public class Manager extends Employee implements Serializable {
    private double bonus = 200.0;
    public double getBonus() {return bonus;}
    public void setBonus(double bonus) {this.bonus = bonus;}
}
```

**源码：**
```java
@Test
public void employeeAndManager() {
    Manager manager = new Manager();
    double salary = manager.getSalary();
    double bonus = manager.getBonus();
    System.out.println("月总薪水：" + (salary + bonus));
}
```

## 1.2 super关键字

**概念：** java中提供super关键字，用法和this类似，也有两种：
- 在子类调用父类的普通方法时，可以在子类的构造方法或者普通方法中使用 `super.方法名();` 来强行指定，仅在父类中寻找方法，否则默认现在子类中寻找该方法，找不到再去父类中寻找。
- 想在子类调用父类的构造方法，必须在子类构造方法中的第一行使用 `super()`。
- 调用子类构造的时候，一定会先去调用父类的构造，然后再调用子类的构造。

**源码：** Animal.java
```java
/**
 * @author JoeZhou
 */
public class Animal {
    private String name;

    public Animal() {
    }

    public Animal(String name) {
        this.name = name;
    }

    public void move() {
        System.out.println("动物都可以移动！");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

**源码：** Bird.java
```java
/**
 * @author JoeZhou
 */
public class Bird extends Animal {
    /**
     * 在构造方法的第一句使用super()，调用父类的构造方法
     */
    public Bird() {
        // super的好处就是可以直接赋值，不用set了
        super("精卫");
    }
}
```

**源码：** Dog.java
```java
/**
 * @author JoeZhou
 */
public class Dog extends Animal {
    public Dog() {
        // super可以调用父类的普通方法;
        super.move();
    }

    public void methodA() {
        super.move();
    }
}
```

**源码：**
```java
@Test
public void animalAndBirdAndDog(){
    System.out.println(new Bird().getName());
    new Dog().methodA();
}
```

**练习：** 02003-1-2
1. What is the result?
```java
class Atom {
    Atom() { System.out.print("atom "); }
}

class Rock extends Atom {
    Rock(String type) { System.out.print(type); }
}

public class Mountain extends Rock {
    Mountain() {
        super("granite ");
        new Rock("granite ");
    }
    public static void main(String[] a) { new Mountain(); }
}
```
- A. Compilation fails.
- B. atom granite
- C. granite granite
- D. atom granite granite
- E. An exception is thrown at runtime.
- F. atom granite atom granite

# 2. 多态

**概念：** 
- 一种类型多种形态，多态是一个 `like a` 的关系：
    - 如同一个电话，拨不同的号码，实现不同的功能。
    - 如同一个插排，插不同的电器，实现不同的功能。
- 多态在JAVA中的实现就是方法的重载(overload)和方法的重写(override)。

## 2.1 方法的重载

**概念：** 方法的重载可以提高调用方法时的体验，节省代码，要求：
- 在同一个类中。
- 方法名相同。
- 参数列表不同。
- 其他方法要素，如返回值等均无要求。

**练习：** 02003-2-1
1. 请问如下代码算方法重载吗？
```java
public int getSum(int a, int b){
    return a+b;
}

public Integer getSum(int b, int a){
    return a+b;
}
```

## 2.2  方法的重写

**概念：** 方法的重写，要求：
- 在继承关系的两个类中，即父子类中。
- 方法名相同。
- 参数列表也相同。
- 修饰符越写越大。
- 异常和返回值越写越小。
- 被 `final` 或者 `private` 修饰的方法，不能被重写。
- 重写的方法建议在方法上添加 `@Override` 进行标记。

> 一大两小两不变。

**练习：** 02003-2-2
1. Which four code fragments, inserted independently at line 7, will compile? (Choose four.)
```java
public class Hi {
    void m1() { }
    protected void m2 () { }
}
class Lois extends Hi {
    // insert code here 7
}
```
- A. public void m1() { }
- B. protected void m1() { }
- C. private void m1() { }
- D. void m2() { }	
- E. public void m2() { }
- F. protected void m2() { }
- G. private void m2() { }

2. Which five methods, inserted independently at line 5, will compile? (Choose five.)
```java
public class Blip {
    protected int blipvert(int x) { return 0; }
}
class Vert extends Blip {
    // insert code here
}
```
- A. public int blipvert(int x) { return 0; }
- B. private int blipvert(int x) { return 0; }
- C. private int blipvert(long x) { return 0; }
- D. protected long blipvert(int x) { return 0; }
- E. protected int blipvert(long x) { return 0; }
- F. protected long blipvert(long x) { return 0; }
- G. protected long blipvert(int x, int y) { return 0; }

3. What is the result?
```java
class Pizza {
    java.util.ArrayList toppings;
    public final void addTopping(String topping) {
        toppings.add(topping);
    }
}
public class PepperoniPizza extends Pizza {
    public void addTopping(String topping) {
        System.out.println("Cannot add Toppings");
    }
    public static void main(String[] args) {
        Pizza pizza = new PepperoniPizza();
        pizza.addTopping("Mushrooms");
    }
}
```
- A. Compilation fails.
- B. Cannot add Toppings
- C. The code runs with no output.
- D. A NullPointerException is thrown in Line 4.

## 2.3 引用数据类型转换

**概念：** 我们可以new一个子类，然后使用父类实例接收，此时，如果 `Father` 和 `Son` 中有相同名字的方法或属性，则会发生动态绑定的现象：
- 方法看右边，属性看左边。

**源码：** Father.java
```java
/**
 * @author JoeZhou
 */
public class Father {
    public String name = "father";

    public void method() {
        System.out.println("method-father");
    }
} 
```

**源码：** Son.java
```java
/**
 * @author JoeZhou
 */
public class Son extends Father {
    public String name = "son";
    
    @Override
    public void method() {
        System.out.println("method-son");
    }
}
```

**源码：** Son.java
```java
@Test
public void sonAndFather() {
    // 动态绑定：不运行不知道到底new个什么
    Father father = new Son();
    
    // 具体调用的是哪个方法，看等号右边（运行时类型）
    father.method();

    // 具体调用的是哪个属性，看等号左边（编译时类型）
    System.out.println(father.name);
}
```

## 2.4 instanceof实例判断

**概念：** 
- 用 `对象变量名 instanceof 类名（接口名）` 来判断该变量所指向的对象是否属于该类。
- 只有父类原本就是由子类new出来的时候，才能向下转型，否则会报类转换异常：
    - `Dog -> Animal -> (Dog)Dog`，转换成功。
    - `Dog -> Animal -> (Cat)Cat`，转换异常。

**源码：** Animal.java
```java
/**
 * @author JoeZhou
 */
public class Animal{}
```

**源码：** Dog.java
```java
/**
 * @author JoeZhou
 */
public class Dog extends Animal{}
```

**源码：**
```java
@Test
public void instanceOf() {
    Dog dog = new Dog();
    Animal animal = new Animal();

    System.out.println(dog instanceof Animal);
    System.out.println(dog instanceof Dog);
    System.out.println(animal instanceof Animal);
    System.out.println(animal instanceof Dog);
    
    animal = new Dog();
    dog = (Dog)new Animal();
    
    dog = (Dog) animal;
    System.out.println(animal instanceof Animal);
    System.out.println(animal instanceof Dog);
    System.out.println(dog instanceof Animal);
    System.out.println(dog instanceof Dog);
}
```

**练习：** 02003-2-4
1. Which three are valid? (Choose three.)
```java
class ClassA {}
class ClassB extends ClassA {}
class ClassC extends ClassA {} 

and:

ClassA p0 = new ClassA();
ClassB p1 = new ClassB();
ClassC p2 = new ClassC();
ClassA p3 = new ClassB();
ClassA p4 = new ClassC();
``` 
- A. p0 = p1;
- B. p1 = p2;
- C. p2 = p4;
- D. p2 = (ClassC)p1;
- E. p1 = (ClassB)p3;
- F. p2 = (ClassC)p4;
