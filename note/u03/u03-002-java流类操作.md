# 1. I/O流

**概念：** 
- 大多数的应用程序（项目）都需要与外部设备进行数据交换，最常见的外部设备有磁盘、硬盘和网络。
- I/O（Input/Output）就是指应用程序（项目）和这些设备之间的数据交换。
- java中有很多负责I/O数据交换的类，都在 `java.io` 包中。
- `java.io.File` 类是I/O包中唯一代表硬盘文件本身的类，通过它可以对文件进行创建，删除，重命名，设置读写权限等操作。
    - 构造器：`new File(String filename)`，java支持 `UNIX` 和 `WINDOWS/DOS` 约定的路径分隔符 `/` 和 `\\`
    - `boolean exists()`：判断文件/目录是否存在。
    - `boolean mkdir()`：创建单层目录。 
    - `boolean mkdirs()`：创建多层目录。
    - `void delete()`：删除文件/目录，彻底删除，不进回收站，删除文件夹的前提是，文件夹是空文件夹。
    - `void deleteOnExit()`：在JVM终止时删除文件，只有在JVM正常终止时，才会尝试执行删除操作。
    - `boolean createNewFile()`：创建一个文件。
    - `String getName()`：得到文件/目录的名称。 
    - `String getPath()`：得到文件/目录的路径。 
    - `long length()`：得到文件字节数。
    - `boolean canRead()`：判断文件是否可读（能查看但是不能操作和存储）。
    - `boolean canWrite()`：判断文件是否可写（能写入但是看不见）。
    - `boolean isFile()`：判断文件是否是文件。
    - `boolean isDirectory()`：判断文件是否是目录。
    - `boolean renameTo(File file)`：重命名为新的file实例的名字注意参数中的file实例不要创建出来。
    - `boolean equals(File file)`：判断文件/目录是否是同一个。
    - `String getParent()`：返回父目录的路径名，如果此路径名没有指定父文件夹，则返回null。
    - `boolean isHidden()`：返回文件是否是一个隐藏文件。
    - `long lastModified()`：返回文件最后一次被修改的时间戳，如果该文件不存在，或者发生I/O错误，则返回0L。 
    - `boolean isAbsolute`：返回文件是否是绝对路径（从盘符出发就是绝对路径）。
    - `String getAbsolutePath()`：返回文件的绝对路径。

**测试：** FileTest.java
```java
public class FileTest {

    private File file;

    @Before
    public void before() throws IOException {
        String pathDirs = "D:\\java\\io";
        File dirs = new File(pathDirs);
        if (!dirs.exists()) {
            System.out.println(dirs.mkdirs() ? "目录创建成功" : "目录创建失败");
        }
        String pathname = pathDirs + "\\build.txt";
        this.file = new File(pathname);
        if (this.file.exists()) {
            System.out.println(this.file.delete() ? "删除成功" : "删除失败");
        }
        System.out.println(this.file.createNewFile() ? "文件创建成功" : "文件创建失败");
    }

    @Test
    public void fileApi() {
        System.out.println("文件名：" + file.getName());
        System.out.println("文件路径：" + file.getPath());
        System.out.println("文件大小：" + file.length());
        System.out.println(file.canRead() ? "可读" : "不可读");
        System.out.println(file.canWrite() ? "可写" : "不可写");
        System.out.println(file.isFile() ? "是文件" : "不是文件");
        System.out.println(file.isDirectory() ? "是目录" : "不是目录");
        File newFile = new File("D:\\java\\io\\build-1.txt");
        System.out.println(file.renameTo(newFile) ? "修改成功" : "修改失败");
        System.out.println(file.equals(newFile) ? "是同一个" : "非同一个");
        System.out.println("父目录：" + file.getParent());
        System.out.println(file.isHidden() ? "隐藏文件" : "非隐藏文件");
        System.out.println("最后修改日期：" + new Date(file.lastModified()));
        System.out.println(file.isAbsolute() ? "是绝对路径" : "不是绝对路径");
        System.out.println("文件绝对路径：" + file.getAbsolutePath());
    }
}
```




2. RandomAccessFile

有时候我们在访问一个文件的时候，不想把文件从头读到尾，而是希望像访问一个数据库一样地访问一个文件。于是java.io.RandomAccessFile给我们提供了功能丰富的文件访问操作，支持随机位置访问。

RandomAccessFile具有一个位置指示器，指向当前读写处的位置，默认位置是文件的开头，我们可以自己设定指示器的初始，读写n个字节后，指示器指向n个字节后的下一个字节处。

RandomAccessFile仅限于操作文件，不能访问其他IO设备，如网络，内存映像等。

员工信息读写案例

我们现在往一个文件中写入三个员工的信息，然后按顺序读取员工信息。
package com.joe.io;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
 * @author Joe
 */
public class RandomAccessFileTest {
	public static void main(String[] args) throws IOException {
        
        // 路径不存在，会帮你创建一个
        RandomAccessFile raf = new RandomAccessFile("D:\\IO\\emp.txt", "rw");
        
        // 写
        raf.writeUTF("赵四");
        raf.writeInt(18);
        raf.writeUTF("刘能");
        raf.writeInt(38);
        raf.writeUTF("广坤");
        raf.writeInt(58);
        
        // 移动指针位置为0
        raf.seek(0);
        
        // 读
        System.out.println(raf.readUTF());
        System.out.println(raf.readInt());
        System.out.println(raf.readUTF());
        System.out.println(raf.readInt());
        System.out.println(raf.readUTF());
        System.out.println(raf.readInt());
        raf.close();
	}
}


tips：如果我们想按照第二个，第一个，第三个这样的顺序读取员工信息，应该如何设置。
tips：utf-8编码下，一个字符占3个字节，gbk编码下 一个字符占2个字节。
tips：writeUTF()会首先把字符串字节数写上去，大小是两个字节，所以6个字节的数据，就需要8字节的空间，

RandomAccessFile的其他方法
RandomAccessFile file = new RandomAccessFile("D:\\JavaDir\\IO\\Text_RandomAccessFile_2.txt", "rw");  

file.writeInt(20);// 4b 
file.writeDouble(8.236598);// 8b  
file.writeUTF("123456");// 2b + 6b:前两个字节存放这个字符串实际长度[6]
file.writeBoolean(true);// 1b  
file.writeShort(395);// 2b  
file.writeLong(2325451l);// 8b  
file.writeUTF("123456789");// 2b + 9b:前两个字节存放这个字符串实际长度[9]
file.writeFloat(35.5f);// 4b  
file.writeChar('a');// 2b  

file.seek(0);// reset the seek on 0  

System.out.println(file.readInt());  
System.out.println(file.readDouble());  
System.out.println(file.readUTF());  

file.skipBytes(3);// skip 3b (contains a boolean(1) and a short(2)) 

System.out.println(file.readLong());
file.skipBytes(file.readShort());// UTF字符串前两个字节存放的是这个字节的字节数，所以readShort正好可以读出这个字符串的长度
System.out.println(file.readFloat());  
System.out.println(file.readChar());
System.out.println(">>read over..");

file.close();


3. 流类概念

电脑硬盘上存放文件，文件上存放数据，Java中通过流来读写数据。



tips：我们要研究的就是这些不同的管道。

[流的分类]
按方向 输入流 & 输出流 站在程序的角度来辨别方向
按处理数据方式 字节流 & 字符流 字节流是最原始的二进制传输方式，1字节占8位字符流是以字符为单位，1字符占2字节，占16位
按功能 节点流 & 处理流 节点流是对数据直传输处理流会在数据传输过程中对数据进行进一步处理后再传输

[Java中的四大抽象流]	
 字节流 字符流
输入流 InputStream Reader
输出流 OutputStream Writer
tips：读入写出
tips：文本内容使用字符流，二进制内容使用字节流。

[抽象流的子类]
节点流 文件流 FileInputStream
  FileOutputStream
  FileReader
  FileWriter
 内存数组流 ByteArrayInputStream
  ByteArrayOutputStream
  CharArrayReader
  CharArrayWriter
 内存字符串流 StringReader
  StringWriter
处理流 缓冲流 BufferedInputStream
  BufferedOutputStream
  BufferedReader
  BufferedWriter
 转换流 InputStreamReader
  OutputStreamWriter
 打印流 PrintStream
  PrintWriter
 数据流 DataInputStream
  DataOutputStream
 对象流 ObjectInputStream 
  ObjectOutputStream 
 线程管道流 PipedInputStream
  PipedOutputStream
  PipedReader
  PipedWriter

4. 文件节点流

节点流是对数据的直传输，中间不涉及任何数据的处理。

文件字节输入流
利用FileInputStream将自身文件输出在控制台，并计算总字节数
@Test
public void FileInputStreamTest() throws IOException {
    
    // 文件路径，支持"/"和"\\"
	String filePath = "****.java";
 
    // 将FileInputStream管插在你要操作的文件上
	FileInputStream fis = new FileInputStream(filePath);
 
    // 查看可见（还剩下的）总字节数
	System.out.println("总字节数：" + fis.available());
 
    // 定义一个中间变量，负责接收每次循环出来的字节
	int b;
	while ((b = fis.read()) != -1) {
        // 将数字转换为char值
		System.out.print((char) b);
	}
    
	fis.close();
}


文件字节输出流
利用FileInputStream和FileOutputStream，将HelloWorld.txt文件内容copy到某HolloWorld.java文件中
@Test
public void FileOutputStreamTest() throws IOException {
    
    // 输入流
	FileInputStream fis = new FileInputStream("E:\\io\\HelloWorld.txt");
 
    // 输出流，要输出的文件路径如果没有程序会帮忙创建
	FileOutputStream fos = new FileOutputStream("E:\\io\\HelloWorld.java");

	int b;
 
    // 从HelloWorld.txt输入一个，往HelloWorld.java输出一个
	while ((b = fis.read()) != -1) {
		fos.write(b);
	}

    // 冲刷管道中残留数据
	fos.flush();
	fos.close();
	fis.close();

	System.out.println("copy over...");
}


tips：FileOutputStream()第二个参数默认false，如果改为true，则每次写入，代表追加，否则代表覆盖原来的值。

文件字符输入流
利用FileReader将包含中文的自身文件输出在控制台
@Test
public void readerTest() throws IOException {
	String path = "****.java";
	FileReader fr = new FileReader(path);

	int b = -1;
	while ((b = fr.read()) != -1) {
		System.out.print((char) b);
	}

	fr.close();
}


文件字符输出流
利用FileWriter制作一个文件Unicode.dat
@Test
public void writerTest() throws IOException {
	FileWriter fw = new FileWriter("E:\\io\\unicode.dat");

    // unicode码最大值65535
	for(int i = 0, j = 65535; i < j; i++) {
		fw.write(i);
	}
	
	fw.flush();
	fw.close();
}


5. 处理缓冲流

处理流会在节点流的基础上，对数据进行更丰富的处理，然后再进行传输。

缓冲字节输入流
利用BufferedInputStream中的mark和reset方法，对文件进行中间部分内容读取
@Test
public void bufferedInputStreamTest() throws IOException {
	FileInputStream fis = new FileInputStream("E:\\io\\BT.txt");
	BufferedInputStream bis = new BufferedInputStream(fis, 8192);// p2 : default 8K.

	System.out.println("1b:" + (char) bis.read());// 在1号位置读取一个字节
	System.out.println("2b:" + (char) bis.read());// 在2号位置读取一个字节

	bis.mark(4);// 在3号位置mark，4字节后该mark失效

	System.out.println("3b:" + (char) bis.read());// 在3号位置读取一个字节
	System.out.println("4b:" + (char) bis.read());// 在4号位置读取一个字节
	System.out.println("5b:" + (char) bis.read());// 在5号位置读取一个字节
	System.out.println("6b:" + (char) bis.read());// 在6号位置读取一个字节

	bis.reset();// 回到标记的3号位置

	System.out.println("3b:" + (char) bis.read());// 在3号位置读取一个字节
	System.out.println("4b:" + (char) bis.read());// 在4号位置读取一个字节
	System.out.println("5b:" + (char) bis.read());// 在5号位置读取一个字节
	System.out.println("6b:" + (char) bis.read());// 在6号位置读取一个字节

	bis.close();
}


tips：mark()方法标记的位置，只取决于这行代码被调用时，fis中指针的位置，或者理解为这行代码的位置，跟参数无关。
tips：mark()方法的参数是一个以字节为单位的标记有效期，比如4，代表从标记开始，4个字节内，标记都有效，如果读了5个字节，mark()标记失效，reset()方法将会报错。
tips：mark()方法的有效期不仅仅取决于它的参数，还取决于BufferedInputStream()的缓存，默认8K，两个值，谁大走谁，比如mark(5)，但是BufferedInputStream()的缓存是8192字节，所以读的字节没超过8192字节，都生效。

缓冲字节输出流
利用BufferedOutputStream对一个文件写入10个A
@Test
public void BufferedOutputStreamTest() throws IOException {
	FileOutputStream fos = new FileOutputStream("E:\\io\\BO2.txt");
	BufferedOutputStream bos = new BufferedOutputStream(fos);

	for (int i = 0; i < 10; i++) {
        // 如果写入数字，会转成unicode码
		bos.write('A');
	}

	bos.flush();
	bos.close();
}


缓冲字符输入流
利用BufferedReader中的readline方法一行一行地读取自身文件，并输出在控制台上
@Test
public void BufferedReaderTest() throws IOException {
	FileReader fr = new FileReader("D:\\...\\处理_缓冲流.java");
    // 在FileReader外套一层BufferedReader
	BufferedReader br = new BufferedReader(fr);
	String str = null;
    // BufferedReader中有readLine()方法，可以按行读取
	while((str = br.readLine()) != null) {
		System.out.println(str);
	}
	br.close();
}


缓冲字符输出流
利用BufferedWriter向文件写入100个随机数，每个随机数占据一行
@Test
public void bufferedWriterTest() throws IOException {
	FileWriter fw = new FileWriter("E:\\io\\random.txt");
	BufferedWriter bw = new BufferedWriter(fw);

    Random random = new Random();
    for (int i = 0, j = 100; i < j; i++) {
        
        // BufferedWriter支持写入字符串
        bw.write("" + (random.nextInt(100)));
        
        // newLine()可以换行
        bw.newLine();
    }
    
	bw.flush();
	bw.close();
}


6. 处理转换流

我们可以利用处理转换流将字节流转换成对应的字符流（inputStream-Reader，outputStream-Writer）。

输入转换流
利用InputStreamReader模拟Scanner键入输出，使用readLine()方法读取控制台信息
@Test
public void inputStreamReaderTest() throws IOException {
    
    // System.in本身就是InputStream类型
	InputStreamReader isr = new InputStreamReader(System.in);
	BufferedReader br = new BufferedReader(isr);
	String str;
	while ((str = br.readLine()) != null) {
		System.out.println(">> " + str);
	}
    br.close();
}


tips：Idea中的Junit和System.in或者Scanner有冲突，请换成main方法测试。

输出转换流
@Test
public void outputStreamWriterTest() throws IOException {
    
    // true代表追加
	FileOutputStream fos = new FileOutputStream("E:\\io\\osw.txt", true);
 
    // 将FileOutputStream转成Writer
	OutputStreamWriter osw = new OutputStreamWriter(fos);
	osw.write("你好");
 
    // utf8
	System.out.println(osw.getEncoding());
	osw.flush();

    // 第二个参数可以控制编码
	osw = new OutputStreamWriter(fos, "GBK");
	osw.write("世界");
 
    // gbk
	System.out.println(osw.getEncoding());
	osw.flush();
	osw.close();
}


7. 处理打印流

打印流是输出语句的底层结构，无需抛出IO异常，且自带flush效果。

打印字节流
利用继承自OutputStream的PrintStream，重新定义输出打印语句的效果
public class Text_PrintStream {
	public static void main(String[] args) throws FileNotFoundException {
		PrintStream ps = new PrintStream(new FileOutputStream("D:\\JavaDir\\IO\\Text_PrintStream.dat"));
		// 重新定义输出语句中的out，让其从默认指向控制台改为指向ps绑定的文件上
		System.setOut(ps);
		// 利用新的输出语句，将unicode前128个打印在文件中
		for (int i = 0; i < 128; i++) {
			System.out.print((char) i + " ");
		}
		ps.close();
	}
}


如果修改out指定之后，需要回复原来的指向(控制台)，则需要在setOut()之前，对System.out进行备份，然后再使用新指定之后，再次调用setOut()来还原备份。
PrintStream preOut = System.out;// 默认值备份
System.setOut(preOut);// 还原备份


tips：System.out和System.err都能重定向到别的输出流中输出，此时控制台console区域不输出内容。

打印字符流
使用PrintWriter创建一个日志文件，模拟Log4j（java的日志文件）工作
@Test
public void printWriterTest() throws IOException {
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	FileWriter fw = new FileWriter("E:\\io\\日志.log", true);
	PrintWriter pw = new PrintWriter(fw);
	String str = null;
	while ((str = br.readLine()) != null) {
		if ("q".equalsIgnoreCase(str)) {
			break;
		}
		pw.println(str);
	}
	pw.println("LOGGING AT " + new Date());
    br.close();
	pw.close();
}


tips：idea中，junit和scanner冲突，测试请使用main方法。

8. 处理数据流

需求：在内存中创造一个虚拟的字节数组，向字节数组中写入一个double一个boolean并读出来。

数据输入字节流：DataInputStream extends InputStream
数据输出字节流：DataOutputStream extends OutputStream
字节数组输入字节流：ByteArrayInputStream extends InputStream
字节数组输出字节流：ByteArrayOutputStream extends OutputSteam



@Test
public void dataOutputStreamTest() throws IOException {
	// 在内存中创造一个虚拟的字节数组，并插一根字节数组输出流管(baos)，准备往里面写数据
	ByteArrayOutputStream baos = new ByteArrayOutputStream();
	
	// 在baos外层嵌套数据输出流管(dos)，因为想使用它的writeDouble()、writeInt()等便捷方法写数据
	DataOutputStream dos = new DataOutputStream(baos);
	
	// 写：使用DataOutputStream中的便捷方法向内存数组中写数据
	dos.writeDouble(3.14);
	dos.writeBoolean(true);
	dos.writeInt(250);
	dos.flush();
	
	// 读：内存中的字节数组没有名字，我们只能从节数组输入流管(baos)中读数据
	// ByteArrayInputStream()的构造方法中只支持字节数组参数，所有我们需要将baos转成字节数组
	ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
	
	// 在bais外层嵌套数据输入流管(dis)，因为想使用它的readDouble()、readInt()等便捷方法读数据
	DataInputStream dis = new DataInputStream(bais);
	
	// 读：使用DataInputStream中的便捷方法从内存数组中读数据
	System.out.println(dis.readDouble());
	System.out.println(dis.readBoolean());
	System.out.println(dis.readInt());
	
	dos.close();
	dis.close();
}


9. 处理对象流

ObjectOuputStream和ObjectInputStream可以实现对可序列化类对象的传输。
public class 处理_对象流 {
	@Test
	public void ObjectStreamTest() throws IOException, ClassNotFoundException {

        // 对象输出流
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("E:\\io\\student.txt"));

        // 新建一个对象，并将对象写到文件中
		oos.writeObject(new Student("赵四",58));

        // 对象输入流
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("E:\\io\\student.txt"));
  
        // 从文件中读取对象，并查看
		System.out.println(ois.readObject());

		oos.flush();
		oos.close();
		ois.close();
	}
}

/**
 * Serializable没有任何方法 就是告诉虚拟机这是一个可序列化的类，可以被传输 这种接口称为标记接口
 */
@SuppressWarnings("serial")
class Student implements Serializable {
	private String name;
	private transient Integer age;// 被修饰的属性不参与序列化过程，值不可见(为默认值)
 	
    public Student(String name, Integer age) {
		this.name = name;
		this.age = age;
	}
 	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Integer getAge() {return age;}
	public void setAge(Integer age) {this.age = age;}
}


练习题

t01. Click the Task button.  a/b/c/d.txt   [a,b,c]         d.txt


path = path.getSubdirectory(dir); return !file.isNew(); return (file != null);
String path = ""; path=path.getFile(filename); File path = new File("");
return file.exists(); return path.isFile(); File file = new File(path, filename);
path = new File(path, dir); File path = new File(File.separator); path = path + File.spearator + dir;

4 12 9 7
第1处：String path = "";
第2处：path = path + File.separator + dir;
第3处：File file = new File(path, filename);
第4处：return file.exists();
t02. Given that the current directory is empty, and that the user has read and write privileges to the current directory, and the following,Which statement is true?
import java.io.*;
public class Maker {
    public static void main(String[] args) {
        File dir = new File("dir");
        File f = new File(dir, "f");
    }
}


A. Compilation fails.
B. Nothing is added to the file system.
C. Only a new file is created on the file system.
D. Only a new directory is created on the file system.
E. Both a new file and a new directory are created on the file system.
答案：B
t03. Given that the current directory is empty, and that the user has read and write permissions, and the following,Which statement is true?
import java.io.*;
public class DOS {
    public static void main(String[] args) {
        File dir = new File("dir");
        dir.mkdir();
        File f1 = new File(dir, "f1.txt");
        try {
            f1.createNewFile();
        } catch (IOException e) { ; }
        File newDir = new File("newDir");
        dir.renameTo(newDir);
    }
}


A. Compilation fails.
B. The file system has a new empty directory named dir.
C. The file system has a new empty directory named newDir.
D. The file system has a directory named dir, containing a file f1.txt.
E. The file system has a directory named newDir, containing a file f1.txt.
答案：E
t04. Click the Task button.
[BufferedReader]  [StreamReader]  [FileReader]  [readLine]  [readLn] [read] [closeFile]  [close]  [x1]  [x2]  [x3]  [x4]

9 3 10  3 1 1 12 4 12 8
第1处：x1
第2处：FileReader
第3处：x2
第4处：FileReader
第5处：BufferedReader
第6处：BufferedReader
第7处：x4
第8处：readLine
第9处：x4
第10处：close
第10处：close

t05. Click the Task button.
temp = buffReader.readLine()    && buffReader.hasNext()
temp = buffReader.nextLine()     (IOException e){
!=null                                           (FileNotFoundException e ){

 Place the code fragments into position to user a BufferedReader to read in an entire text file
class PrintFile{
    public static void main(String[] args){
        BufferedReader buffReader = null;
        // more code here to initialize buffReader
        try{
            String temp;
            while([----1----] [----2----] ){
                System.out.println(temp);
            }
        }catch [----3----]
            e.printStackTrace();
        }
    }
}

154
第1处：(temp = br.readLine())
第2处：!= null
第3处：IOException
3. 原型模式

原型模式就是java中的克隆技术，以某个实例为原型，克隆出一个新的实例，新实例具有原实例的属性值，这样的做法效率很高，因为不需要执行构造器，也不需要为属性赋值等。

克隆不等于new，因为new出来的新实例，所有属性都是默认值，这不叫克隆。

克隆出来的对象可以进行改变，且不会影响到原实例。

想要实现原型模式，必须让你的原实例实现Cloneable接口（否则抛出CloneNotSupportedException异常），并直接或间接使用Object中的clone()方法，Cloneable是一个标记接口，标识某个类为“可克隆的”。

羊类
package com.gof23.原型模式;
import java.util.Date;

public class Sheep implements Cloneable {
	private String name;
	private Date birth;

    public Sheep shallowClone(Sheep sheep) {
    	Sheep result = null;
    	try {
    		result = (Sheep)super.clone();// 使用Object中的clone方法进行克隆
    	} catch (CloneNotSupportedException e) {
    		e.printStackTrace();
    	}
    	return result;
    }

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Date getBirth() {return birth;}
	public void setBirth(Date birth) {this.birth = birth;}
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void shallowCloneTest() throws CloneNotSupportedException {
    Date birth = new Date(111111111111L);// 定义一个时间对象
    Sheep dorset = new Sheep();// 创建Dorset羊
    dorset.setName("Dorset");
    dorset.setBirth(birth);
    Sheep dolly = dorset.shallowClone(dorset);// 根据Dorset羊克隆一个dolly羊
    dolly.setName("dolly");// 对dolly羊重新设置名字
    System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
    birth.setTime(999999999999L);// 改变date对象的值
    System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth值造成了影响
}


上面的例子你会发现，Object中的clone可以完成实例的克隆，但是两个实例的birth属性仍然指向同一个Date，当我对Date进行改变的时候，两只羊的birth属性值会同时发生改变，这种克隆，我们叫它浅复制，如果克隆时，所有的属性也都被克隆一份，就叫做深克隆（深复制）。

深克隆：深克隆的是实现实际上是对对象的序列化和反序列化，所以需要让你的被克隆类实现序列化接口。
// 本次实现深克隆使用 ByteArrayOutputStream 和 ByteArrayInputStream 作为克隆过程中字符数组存储中介
public Sheep deepClone(Sheep sheep) {
	Sheep result = null;
	ByteArrayOutputStream bos = null;
	ObjectOutputStream oos = null;
	ObjectInputStream ois = null;
	try {
		bos = new ByteArrayOutputStream();
		oos = new ObjectOutputStream(bos);
		oos.writeObject(sheep);// 将传入参数sheep类写入bos中
		// 将读取到数据传入ObjectInputStream
		ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
		result = (Sheep) ois.readObject();
	} catch (IOException | ClassNotFoundException e) {
		e.printStackTrace();
	} finally {
		try {
			bos.close();
			oos.close();
			ois.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	return result;
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void deepCloneTest() throws CloneNotSupportedException, ClassNotFoundException, IOException {
	Date birth = new Date(111111111111L);// 定义一个时间对象
	Sheep dorset = new Sheep();// 创建Dorset羊
	dorset.setName("Dorset");
	dorset.setBirth(birth);
	Sheep dolly = dorset.deepClone(dorset);// 根据Dorset羊克隆一个dolly羊
	dolly.setName("dolly");// 对dolly羊重新设置名字
	System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
	birth.setTime(999999999999L);// 改变date对象的值
	System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth没有造成影响
}


还有一种更简单的方式实现深克隆（此时不用实现序列化接口），就是在你的深克隆方法体中，将Date属性再浅克隆一次。
public Sheep deepClone(Sheep sheep) {
    Date birth = (Date)sheep.getBirth().clone();
    sheep.setBirth(birth);
    return sheep;
}


tips：这种方式需要把所有引用属性都重新浅克隆一遍，当引用属性比较多的时候不适用。

总结：

浅克隆：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象，就像你和你的影子，你完蛋，你的影子也完蛋。
深克隆：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。就像你和你的克隆人，你完蛋，你的克隆人还活着。

--------------------------------------------------------------------------------
 By Mr.Joe