# 1. String拓展类

**概念：** 一个String对象的长度和内容都是不可变的，虽然使用"+"可以达到改变内容的目的，但实质会产生一个或多个新的字符串，如果这种改变很频繁，那就会特别浪费内存，如果你的操作中需要频繁进行字符串的拼接，不建议使用 "+"。

**源码：** 使用 "+" 拼接10万次字符串耗时测试代码如下：
```java
@Test
public void plusSignStitchingTimeConsuming(){
    // 获取时间戳：距离1970年1月1日 0点0时0分 一个毫秒数。
    long startTime = System.currentTimeMillis();

    String str = "";
    for (int i = 0; i < 100000; i++) {
        str = str + i;
    }

    long endTime = System.currentTimeMillis();
    System.out.println("总耗时：" + (endTime - startTime) + "毫秒");
}
```

## 1.1 StringBuilder

**概念：**
- StringBuilder是jdk1.5版本提出来的一个类，它是一个可变长的字符串类，可以预分配缓冲区，我们可以通过它来进行频繁的字符串拼接操作。
- 创建方式：`StringBuilder stringBuilder = new StringBuilder("a");`
- 拼接方式：`append()`。
- 虽然在JDK1.8版本中，"+"的底层代码，也是在调用StringBuilder这个类的append()方法，但是多次调用"+"的时候，会创建多次StringBuilder，一样会导致效率低下，这里的优化仍未做到最好，所以在效率上，使用StringBuider仍然要比使用"+"，更优秀。

**源码：** 使用StringBuilder拼接10万次字符串耗时测试代码如下：
```java
@Test
public void stringBuilderStitchingTimeConsuming(){
    // 获取时间戳：距离1970年1月1日 0点0时0分 一个毫秒数。
    long startTime = System.currentTimeMillis();

    StringBuilder stringBuilder = new StringBuilder("");

    for (int i = 0; i < 100000; i++) {
        stringBuilder.append(i);
    }

    long endTime = System.currentTimeMillis();
    System.out.println("总耗时：" + (endTime - startTime) + "毫秒");
}
```

## 1.2 StringBuilder常用方法

方法|描述（n1和n2均指是索引位置）
-|-
`replace(n1, n2, "a");` | 将n1到n2之间的元素，全部替换成字符串"a"
`insert(n1, "a");` | 在n1之后，插入字符串"a"
`delete(n1, n2);` | 将n1到n2之间的元素，全部删除
`deleteCharAt(n1)` | 删除n1位置上的元素
`substring(n1, n2)` | 截取出n1到n2之间的所有元素并返回
`reverse()` | 水平翻转字符串
`toString()` | 以字符串形式展示

```!
以上范围均包括n1，但是不包括n2。
```

**练习：** 01009-1-2

## 1.3 StringBuffer

**概念：** StringBuffer是JDK1.0时代就存在的老员工了，它可以算是StringBuilder的亲生哥哥，它和StringBuilder的方法都是类似的，唯一的区别是，StringBuffer是线程安全的，而StringBuilder是线程不安全的。

**练习：** 01009-1-3

# 2. 数学工具类

**概念：** `java.lang.Math` 工具类提供了大量用于数学运算的方法，Math类是final类，因此不能从Math类继承，Math类中的方法都是static方法，因此不必创建Math类的对象就可以直接使用类的方法。
- `Math.abs(-10)`：绝对值；
- `Math.sqrt(16)`：平方根
- `Math.cbrt(8)`：立方根
- `Math.ceil(2.1)`：向上取整
- `Math.floor(2.9)`：向下取整
- `Math.max(1, 6)`：最大值 
- `Math.min(1, 6)`：最小值 
- `Math.pow(2, 3)`：a的b次幂
- `Math.round(2.4)`：四舍五入
- `Math.random()`：随机数：每次随机都生成一个[0-1)之间的数字

> 随机数生成的代码，更建议使用 `new Random().nextInt(5);`，此时可以直接随机生成一个0到5范围内的int值。

**练习：** 01009-2

# 3. Scanner工具类

**概念：** `java.util.Scanner` 是JDK1.5之后引入的功能类，负责接收控制台上输入的字符，将其转换为相应数据类型的数据，并存储到相应的变量中。
- Scanner的特性规定我们在new它的时候，传一个固定的值 `System.in` 进去，代表输入流；
    - `Scanner scanner = new Scanner(System.in);` 
    - `scanner.close();`
    - `scanner.nextInt()`：接收控制台传递过来的整数。
    - `scanner.nextDouble()`：接收控制台传递过来的浮点数。
    - `scanner.next()`：接收控制台传递过来的字符串。

> IDEA中无法使用Junit测试Scanner，请换成main方法测试。

**练习：** 01009-3

# 4. Arrays工具类

**概念：** `java.util.Arrays` 类包含用来操作数组的各种方法：
- `toString(int[] arr)`：返回一维数组内容的字符串表示形式。
- `deepToString(int[][] arr)`：返回二维数组内容的字符串表示形式。
- `equals(int[] arrA, int[] arrB)`： 返回参数中的两个数组是否相同。
- `fill(int[] arr, int b, int c, int d)`： 从b位置到c位置，将d充满arr数组，bc可省略。
- `binarySearch(int[] arr, char key)`：在arr数组中，用二进制搜索法搜索key。
- `sort(int[] arr, int b, int c)`：从b位置到c位置，升序排列数组arr，bc可省略。

**源码：** 测试Arrays的所有常用方法
```java
@Test
public void equals(){
    int[] arr1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int[] arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int[] arr3 = {1};
    System.out.println(Arrays.equals(arr1, arr2));
    System.out.println(Arrays.equals(arr1, arr3));     
}

@Test
public void fill(){
    int[] arr = new int[5];
    // p1：对哪个数组进行填充
    // p2：从数组的哪个位置开始填充
    // p3：填充多少个
    // p4：填充什么
    Arrays.fill(arr, 0, arr.length, 13);
    System.out.println(Arrays.toString(arr));      
}

@Test
public void binarySearch(){
    int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    // p1：在哪个数组中进行二分查找
    // p2：查找什么值
    System.out.println(Arrays.binarySearch(arr, 5));       
}

@Test
public void sort(){
    int[] arr = {133, 12, 5, 4, 2, 6, 21, 561, 453, 10};
    Arrays.sort(arr);
    System.out.println(Arrays.toString(arr));  
}
```

# 5. 日期工具类

**概念：** 简单基本类型包括八大基本数据类型和String和Date。
- `java.util.Date` 表示指定的日期信息，可以精确到毫秒，Date中许多方法已经过时但仍能使用。
	- 构造器 `public Date()` 默认使用当前系统时间的时间戳。
	- 构造器 `public Date(long date)` 允许自己指定时间戳。
- `java.text.DateFormat` 是一个格式化日期的类：
    - 构造器：`DateFormat dateFormate = new SimpleDateFomat()`
    - 构造器：`DateFormat dateFormate = DateFormat.getInstance();`
- 格式化和解析：	
    - `format()`：格式化：将Date类型数据按照指定的格式转换成String类型数据。
	- `parse()`：解析：将String类型数据按照指定的格式转换成Date类型数据。

**源码：**
```java
@Test
public void build(){

    Date date = new Date();
    System.out.println(date);

    date = new Date(1000L);
    System.out.println(date);
}
```

## 5.1 格式化

**概念：** 日期的格式化就是把Date按照指定模版转成String的过程，使用 `public final String format(Date date)` 可以完成格式化：
- 传入一个Date数据。
- 返回一个String数据。

**测试：**
```java
@Test
public void format() {
    Date now = new Date();
    String pattern = "yyyy年MM月dd日 hh:mm:ss";
    DateFormat dateFormat = new SimpleDateFormat(pattern);
    String result = dateFormat.format(now);
    System.out.println(result);
}
```

> format()中可以直接放时间戳。

## 5.2 解析

**概念：** 日期的解析就是把String按照指定模版转成Date的过程，使用 `public Date parse(String source) throws ParseException` 可以完成格式化：
- 传入一个String数据。
- 返回一个Date数据。

**测试：**
```java
@Test
public void parse() {
    String olympicDate = "2008-08-08";
    String pattern = "yyyy-MM-dd";
    DateFormat dateFormat = new SimpleDateFormat(pattern);
    Date result = null;
    try {
        result = dateFormat.parse(olympicDate);
    } catch (ParseException e) {
        e.printStackTrace();
    }
    System.out.println(result);
}
```

**练习：** 01009-5-2

# 6. 日历工具类
 
**概念：** `java.util.Calendar` 是一个抽象基类，主要用于完成日期字段之间的相互操作功能，可以设置和获取日期数据的特定部分。
- 构造方法：
    - `Calendar calendar = new GregorianCalendar();`
    - `Calendar calendar = Calendar.getInstance();`
- 常用API：
    - `setTime(Date date)`：使用给定的Date设置此Canendar的时间。
    - `getTime()`：转化成Date对象
    - `add(int field, int amount)`: 将日历的field字段添加或较少指定值。
    - `set(int field, int value)`: 将日历的field字段改为value值。
        - `Calendar.MONTH`：老外将12月作为每年的第一个月。
        - `Calendar.DAY_OF_WEEK`：老外将周日作为每周的第一天。
    - `get(int field)`：获得当前时间中field字段的值。

**测试：**
```java
@Test
public void api() {
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(new Date());
    DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

    // 将年份减去1
    calendar.add(Calendar.YEAR, -1);
    System.out.println(dateFormat.format(calendar.getTime()));

    // 将月份设置为1月
    calendar.set(Calendar.MONTH, 0);
    System.out.println(dateFormat.format(calendar.getTime()));

    int year = calendar.get(Calendar.YEAR);
    int month = calendar.get(Calendar.MONTH);
    int date = calendar.get(Calendar.DATE);
    int week = calendar.get(Calendar.DAY_OF_WEEK);
    int hour = calendar.get(Calendar.HOUR);
    int minute = calendar.get(Calendar.MINUTE);
    int second = calendar.get(Calendar.SECOND);
    System.out.printf("%d-%d-%d 星期%d %d:%d:%s", 
    	year, month + 1, date, week + 1, hour, minute, second);
}
```