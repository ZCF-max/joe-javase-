# 1. 汽车案例

**流程：**
1. 设计接口 `Car` 和接口方法 `drive()`。
2. 设计奔驰实现类 `Benz`。
3. 测试：创建一辆奔驰实例并调用 `drive()`。

**源码：** Car.java
```java
/**
 * @author JoeZhou
 */
public interface Car {
    /**驾驶方法*/
    void drive();
}
```

**源码：** Benz.java
```java
/**
 * @author JoeZhou
 */
public class Benz implements Car {
    @Override
    public void drive() {
        System.out.println("奔驰在跑...");
    }
}
```

**测试：**
```java
@Test
public void factory() {
    new Benz().drive();
}
```

**总结：** `factory()` 即是生产者，负责造车又是使用者，负责开车，这不符合工厂模式的理念。

# 2. 静态工厂

**概念：** 静态工厂模式（也称简单工厂）的目的就是想要将生产者和使用者分离，生产者只负责生产，使用者只负责使用。

**流程：**
1. 保留接口 `Car` 和奔驰实现类 `Benz`。
2. 设计工厂类 `CarFactory`。
3. 设计工厂方法 `getBenz()`：返回一个奔驰实例。
4. 测试：从工厂类中获取一辆奔驰实例并调用 `drive()`。

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public class CarFactory {
    public static Car getBenz() {
        return new Benz();
    }
    public static Car getBmw() {
        return new Bmw();
    }
}
```

**测试：**
```java
@Test
public void staticFactory() {
    CarFactory.getBenz().drive();
}
```

**总结：** 静态工厂做到了生产者和使用者的分离，但它不满足OCP开闭原则，因为一旦你想再添加一辆新品牌的车，则需要修改实现类 `CarFactory` 的内容。

> OCP开闭原则：`Open-Closed Principle：` 一个软件的实体应当对添加拓展开放，对修改重构关闭。

# 3. 工厂方法

**概念：** 与静态工厂不同，工厂方法模式不将 `CarFactory` 定义为类，而是定义为接口。

**流程：**
1. 保留接口 `Car` 和奔驰实现类 `Benz`。
2. 设计工厂接口 `CarFactory`。
3. 设计工厂接口方法 `build()`：返回一辆车的实例。
4. 设计奔驰工厂接口实现类 `BenzFactory` 实现 `CarFactory`，专门负责造奔驰。

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public interface CarFactory {
    /**
     * 构建一辆车的实例
     * @return 车的接口实例
     */
    Car build(); 
}
```

**源码：** BenzFactory.java
```java
/**
 * @author JoeZhou
 */
public class BenzFactory implements CarFactory {
    @Override
    public Car build() {
        return new Benz();
    }
}
```

**测试：**
```java
@Test
public void factoryMethod() {
    new BenzFactory().build().drive();
}
```

**总结：** 
- 工厂方法满足OCP原则，因为你添加一辆奥迪，不需要去修改任何一个类或接口的内容，而是再添加一个奥迪类 `AuDi` 和奥迪工厂接口实现类 `AuDiFactory`。
- 但是它的缺点也显而易见，你需要让使用者去new对应的车厂，所以这种模式，理论上优于静态工厂，但实际开发中还是静态工厂用的比较多。

# 4. 抽象工厂

**概念：** 抽象工厂模式在大型的项目中才会遇得到，这种工厂模式并不是对单独的产品（发动机/轮胎/内饰）进行操作，而是对一条产品族（发动机+轮胎）进行整体操作。

**流程：**
1. 设计一个轮胎的接口 `Tires` 和两个轮胎的实现类：`GoodTires` 和 `BadTires`。
2. 设计一个发动机的接口 `Engine` 和两个发动机的实现类：`GoodEngine` 和 `BadEngine`。
3. 设计一个车厂接口 `CarFactory`，负责制造轮胎和发动机等，有两个实现类：`GoodCarFactory` 和 `BadCarFactory`。
4. 在使用的时候，创造一个好车厂或者坏车厂，就可以决定创造出来的零件都是好的或都是坏的。

**源码：** Tires.java
```java
/**
 * @author JoeZhou 
 */
public interface Tires {
    void info();
}
```

**源码：** GoodTires.java
```java
/**
 * @author JoeZhou 
 */
public class GoodTires implements Tires {
    @Override
    public void info() {
        System.out.println("好轮胎...");		
    }
}
```

**源码：** BadTires.java
```java
/**
 * @author JoeZhou
 */
public class BadTires implements Tires {
    @Override
    public void info() {
        System.out.println("坏轮胎...");
    }
}
```

**源码：** Engine.java
```java
/**
 * @author JoeZhou 
 */
public interface Engine {
    void info();
}
```

**源码：** GoodEngine.java
```java
/**
 * @author JoeZhou
 */
class GoodEngine implements Engine {
    @Override
    public void info() {
        System.out.println("好发动机...");
    }
}
```

**源码：** BadEngine.java
```java
/**
 * @author JoeZhou
 */
class BadEngine implements Engine {
    @Override
    public void info() {
        System.out.println("坏发动机...");
    }
}
```

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public interface CarFactory {
    /**
     * 获取发动机
     * @return 发动机实例
     */
    Engine getEngine();

    /**
     * 获取轮胎
     * @return 轮胎实例
     */
    Tires getTires();
}
```

**源码：** GoodCarFactory.java
```java
/**
 * @author JoeZhou
 */
public class GoodCarFactory implements CarFactory {

    @Override
    public Engine getEngine() {
        return new GoodEngine();
    }

    @Override
    public Tires getTires() {
        return new GoodTires();
    }
}
```

**源码：** BadCarFactory.java
```java
/**
 * @author JoeZhou
 */
public class BadCarFactory implements CarFactory {

    @Override
    public Engine getEngine() {
        return new BadEngine();
    }

    @Override
    public Tires getTires() {
        return new BadTires();
    }
}
```

**测试：**
```java
@Test
public void abstractFactory(){
    // by good
    CarFactory goodFactory = new GoodCarFactory();
    goodFactory.getEngine().info();
    goodFactory.getTires().info();
    
    // by bad
    CarFactory badFactory = new BadCarFactory();
    badFactory.getEngine().info();
    badFactory.getTires().info();
}
```

**总结：** 这种工厂模式满足OCP原则，因为想加一条产品族，不需要改变原来的"车厂+零件"的产品族，而是再去添加一个"水果厂+配料"，或者"粮食厂+粮食"等即可。