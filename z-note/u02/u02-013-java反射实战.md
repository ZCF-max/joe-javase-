# 1. 属性文件

需求：给定一个config.txt文档和Student类，请设计一个Junit测试，当config.txt中的内容为Student相关时，运行执行Student类中的studentInfo方法，当config.txt中的内容为Teacher相关时，运行执行Teacher类中的teacherInfo方法。

提示：Properties类。

config.txt文件内容，放在classpath下就可以了
```
className=com.joe.reflect.Student
methodName=studentInfo
```

测试类
```java
class Student {
	public void studentInfo() {
		System.out.println("I am a Student");
	}
}

class Teacher {
	public void teacherInfo() {
		System.out.println("I am a Teacher");
	}
}
```

答案
```java
public class ReflectByPropertiesFile {
	@Test
	public void reflectByPropertiesFile() throws Exception {
		Properties properties = new Properties();
		FileReader fr = new FileReader("src\\com\\reflect\\config.txt");
		properties.load(fr);
		fr.close();
		String className = properties.getProperty("className");
		String methodName = properties.getProperty("methodName");
		Class<?> classObj = Class.forName(className);
		Object newInstance = classObj.getDeclaredConstructor().newInstance();
		classObj.getDeclaredMethod(methodName).invoke(newInstance);
	}
}
```


# 2. 实战案例

**需求：** 通过注解加反射，我们来完成一套ORM框架的造表业务，通过pojo的注解指定，来完成JAVA造表。
- 要有一个实体类User.java，其中需要有id、userName和userAge这个三个私有属性。
- 设计一个注解类Table，它整个运行期有效，只能作用在类名上，参数只有一个value，必填，表示对应数据库的表名。
- 设计一个注解类Id，它整个运行期有效，它只能作用在属性上，空注解，它对应数据库的主键，主键名默认为字段名，格式默认INTEGER，大小默认11。
- 设计一个注解类Column，它整个运行期有效，它只能作用在属性上，参数name() / type() / length()，分别对应字段名、字段类型和字段大小，字段名必填，类型和大小不填写默认（"varchar" 和 50）。
- 设计一个注解解析工具类CreateTableTools，其方法create() 的功能是，将User的类对象作为参数，返回对应建表的SQL语句。
- 表格默认引擎InnoDB，默认编码utf-8。

实体类
```java
/**@author JoeZhou*/
@Table("userInfo")
public class User {
    @Id
    private Integer id;
    @Column(name = "user_name")
    private String userName;
    @Column(name = "user_age", type = "integer", length = 10)
    private String userAge;
}
```

@Table注解类
```java
/**@author Joe*/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Table {
    String value();
}
```

@Id注解类
```java
/**@author Joe*/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id {}
```

@Column注解类
```java
/**@author Joe*/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column {
    
    String name();
    String type() default "varchar";
    int length() default 50;
}
```

解析注解工具类：负责通过反射技术，解析注解，最终形成SQL造表语句
```java
/**@author Joe*/
public class CreateTableTool {
    private Class<?> instance;

    public CreateTableTool(Class<?> instance) {
        this.instance = instance;
    }

    public void build() {
        String sql = getCreateTableSql();
        System.out.println(sql);
        //TODO 调用JDBC的executeUpdate方法发送这个SQL即可完成造表
    }

    /**
     * 获取造表SQL，其中主键默认integer类型，11长度，自增非空，引擎默认InnoDB，编码默认为utf-8
     *
     * @return 造表SQL
     */
    private String getCreateTableSql() {
        String tableName = getTableName();
        String columnsFormatString = getColumnsFormatString();
        String idName = getIdName();
        String sqlFormat =
                "CREATE TABLE `%s` ( "
                        + "`%s` INTEGER(11) AUTO_INCREMENT NOT NULL "
                        + "%s, "
                        + "PRIMARY KEY(`%s`) "
                        + ") ENGINE=InnoDB DEFAULT CHARSET=utf8";
        return String.format(sqlFormat, tableName, idName, columnsFormatString, idName);
    }

    /**
     * 获取@Table注解中标识的表名
     *
     * @return @Table注解中标识的表名
     */
    private String getTableName() {
        return instance.getAnnotation(Table.class).value();
    }

    /**
     * 获取所有@Column中的内容并返回一个格式化字符串
     *
     * @return 一个格式化字符串，如 name varchar(50)
     */
    private String getColumnsFormatString() {
        StringBuilder columns = new StringBuilder();

        Field[] fields = instance.getDeclaredFields();

        for (Field field : fields) {

            // 获取每个属性上的@Column注解
            Column columnAnnotation = field.getAnnotation(Column.class);

            // 只要属性上存在@Column注解，就获取其中的name、type和length
            if (columnAnnotation != null) {
                String name = columnAnnotation.name();
                String type = columnAnnotation.type();
                int length = columnAnnotation.length();

                // 拼成", user_name varchar(50)"的格式
                String line = String.format(", `%s` %s(%d)", name, type, length);
                columns.append(line);
            }
        }
        return columns.toString();
    }

    /**
     * 获取@Id中的内容并返回Id的名字
     *
     * @return Id的名字
     */
    private String getIdName() {

        String idName = "";

        Field[] fields = instance.getDeclaredFields();

        for (Field field : fields) {
            // 获取每个属性上的@Id注解
            Id idAnnotation = field.getAnnotation(Id.class);

            // 只要属性上存在@Id注解，就获取属性名
            if (idAnnotation != null) {
                idName = field.getName();
                break;
            }
        }

        return idName;
    }
}
```

测试
```java
/**@author Joe*/
public class JpaTest {
    @Test
    public void createTable() {
        new CreateTableTool(User.class).build();
    }
}
```

# 3. 编译：动态编译

之前我们编译和运行java代码，都是通过IDE操作来完成的，如果我有一个需求，是从客户端传递到服务器中一个.java文件，或者一段java代码，你接受到之后，利用代码来编译它，然后再运行它，这个过程就是动态编译过程。（JDK1.6引入的动态编译概念）

通过ToolProvider来完成动态编译和动态运行，前提是在D盘创建一个HelloWorld.java文件
```java
/**@author Joe*/
public class DynamicCompile {
	public static void main(String[] args) throws Exception {
        // 获取系统编辑器
		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
		// p1：inputStream输入流，传递给javac的数据，如果为null，表示使用System.in
		// p2：outputStream输出流，javac返回的数据，如果为null，表示使用System.out
		// p3：outputStream输出流，javac返回的错误信息，如果为null，表示使用System.err
		// p4：String类型的不定长数组，可以传递一个或者多个java源文件
		int result = compiler.run(null, null, null, "E:\\HelloWorld.java");
		System.out.println(result);// 0代表编译成功，1代表编译失败
	}
}
```

动态运行
```java
/**@author Joe*/
public class DynamicRun {
    public static void main(String[] args) throws Exception {

        URL url = new URL("file:/E:/");

        // 类加载器：把加载到内存中
        URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url});

        // 加载类名
        Class<?> loadClass = urlClassLoader.loadClass("HelloWorld");

        // 获取方法：main方法
        // p1：调用的方法的名字
        // p2：当你调用这个方法的时候传进来的参数类型
        Method method = loadClass.getMethod("main", String[].class);

        // invoke 是真正的在调用这个方法
        // 这里必须强转成Object类型，否则String[]数组参数会被拆成"a"和"b",与main方法的参数个数不符合
        method.invoke(null, (Object) new String[]{"a", "b"});

        // 节省资源
        urlClassLoader.close();

    }
}
```

tips：如果客户端传递过来的不是一个java文件，而是一段java代码，则可以先用IO流技能将这段java代码输出到一个临时的java文件中，然后在动态编译和运行，得到结果后，别忘了销毁那个临时文件。
