# 1. 属性文件

**概念：** 配置文件的意义是拆分硬编码和组织调度业务层模块，属性文件是配置文件的一种，java中使用 `java.util.Properties` 类来表示属性文件。
- `void load(Reader reader)`：通过Reader流将数据全部读进Properties实例中。
- `String getProperty(String key)`：通过key获取属性文件中的value。

**需求：** 通过切换 `config.txt` 中的内容来控制访问 `Student` 类中的 `studentInfo()`，或是访问 `Teacher` 类中的 `teacherInfo()`。

**源码：** PropertiesTest.java
```java
/**
 * @author JoeZhou
 */
public class PropertiesTest {}

class Student {
    public void studentInfo() {
        System.out.println("Im a Student...");
    }
}

class Teacher {
    public void teacherInfo() {
        System.out.println("Im a Teacher...");
    }
}
```

**配置：** classpath:config.txt
```
className=com.joezhou.reflect.Student
methodName=studentInfo
```

**测试：** PropertiesTest.java 中添加
```java
@Test
public void properties() throws Exception {
    Properties properties = new Properties();
    String fileName = "u02-oop" + File.separator + "src" + File.separator + "config.txt";
    FileReader fr = new FileReader(fileName);
    properties.load(fr);
    fr.close();
    String className = properties.getProperty("className");
    String methodName = properties.getProperty("methodName");
    Class<?> klass = Class.forName(className);
    Object instance = klass.getDeclaredConstructor().newInstance();
    klass.getDeclaredMethod(methodName).invoke(instance);
}
```

> config.txt的路径使用右键 `Copy Relative Path` 来获取。

# 2. 仿写JPA框架

**需求：** 通过注解加反射，我们来设计一个可以通过对pojo的注解的指定，来完成SQL造表的工具类。
1. 设计注解类 `@Table`：运行期有效，作用在类上，参数 `value` 对应数据库表名，必填。
2. 设计注解类 `@Id`：运行期有效，作用在属性上，空注解，对应数据库主键，主键名即字段名，固定 `INTEGER(11)`。
3. 设计注解类 `@Column`：运行期有效，作用在属性上：
    - 参数 `name` 对应数据库字段名，必填。
    - 参数 `type` 对应数据库字段类型，默认varchar
    - 参数 `length` 对应数据库字段大小，默认50
4. 设计实体类 `User.java`，其中需要有 `id`、`userName` 和 `userAge` 这个三个私有属性。
5. 设计工具类 `CreateTableTool.java`：
    - `CreateTableTool(Class<?> instance)`：构造时传入User类对象作为参数。
    - `void build()`：根据建表SQL语句执行建表操作。
    - `String getCreateTableSql()`：获取建表SQL语句。
    - `String getTableName()`：获取 `@Table` 注解中的name值作为表名。
    - `String getColumns()`：获取 `@Column` 注解中的name，type和length值，并进行字符串组装：
        - `user_name varchar(50),` 
        - `user_age integer(10), ` 
    - `String getIdName()`：获取 `@Id` 注解所在的字段名作为数据库普通字段名。

**SQL：** 最终生成的SQL字符串内容
```sql
CREATE TABLE `userInfo` (
    `id` INTEGER(11) AUTO_INCREMENT NOT NULL, 
    `user_name` varchar(50), 
    `user_age` integer(10), 
    PRIMARY KEY(`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

## 2.1 设计注解类@Table

**源码：**
```java
/**
 * @author JoeZhou
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Table {
    String value();
}
```

## 2.2 设计注解类@Id

**源码：**
```java
/**
 * @author JoeZhou
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id { }
```

## 2.3 设计注解类@Column

**源码：**
```java
/**
 * @author JoeZhou
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column {
    String name();
    String type() default "varchar";
    int length() default 50;
}
```

## 2.4 设计实体类User

**源码：** User.java
```java
/**
 * @author JoeZhou
 */
@Table("userInfo")
public class User implements Serializable {
    @Id
    private Integer id;
    @Column(name = "user_name")
    private String userName;
    @Column(name = "user_age", type = "integer", length = 10)
    private String userAge;
}
```

## 2.5 设计工具类CreateTableTool

**源码：** CreateTableTool.java
```java
/**
 * @author JoeZhou
 */
public class CreateTableTool {

    private Class<?> instance;

    public CreateTableTool(Class<?> instance) {
        this.instance = instance;
    }

    public void build() {
        System.out.println(this.getCreateTableSql());
        //TODO 调用JDBC的executeUpdate方法发送这个SQL即可完成造表
    }

    private String getCreateTableSql() {
        String tableName = this.getTableName();
        String columns = this.getColumns();
        String idName = this.getIdName();
        String sqlFormat =
                "CREATE TABLE `%s` ("
                        + "`%s` INTEGER(11) AUTO_INCREMENT NOT NULL"
                        + "%s "
                        + "PRIMARY KEY(`%s`)"
                        + ") ENGINE=InnoDB DEFAULT CHARSET=utf8";
        return String.format(sqlFormat, tableName, idName, columns, idName);
    }

    private String getTableName() {
        return instance.getAnnotation(Table.class).value();
    }

    private String getColumns() {
        StringBuilder columns = new StringBuilder();
        for (Field field : instance.getDeclaredFields()) {
            Column columnAnnotation = field.getAnnotation(Column.class);
            if (columnAnnotation != null) {
                String name = columnAnnotation.name();
                String type = columnAnnotation.type();
                int length = columnAnnotation.length();
                // ", user_name varchar(50)"
                columns.append(String.format(", `%s` %s(%d)", name, type, length));
            }
        }
        columns.append(",");
        return columns.toString();
    }

    private String getIdName() {
        String idName = null;
        for (Field field : instance.getDeclaredFields()) {
            Id idAnnotation = field.getAnnotation(Id.class);
            if (idAnnotation != null) {
                idName = field.getName();
                break;
            }
        }
        return idName;
    }
}
```

## 2.6 设计测试类JpaTest

**测试：** JpaTest.java
```java
/**@author Joe*/
public class JpaTest {
    @Test
    public void createTable() {
        new CreateTableTool(User.class).build();
    }
}
```

# 3. 动态操作

**概念：** 之前我们编译和运行java代码，都是通过IDE操作来完成的，如果我有一个需求，是从客户端传递到服务器中一个.java文件，或者一段java代码，你接受到之后，利用代码来编译它，然后再运行它，这个过程就是动态编译（JDK1.6引入的动态编译概念）过程。

**测试：** 通过ToolProvider来完成动态编译和动态运行，前提是在D盘创建一个HelloWorld.java文件
```java
/**
 * @author JoeZhou
 */
public class DynamicOperaTest {
    
    @Test
    public void dynamicCompile() throws Exception {
        // 获取系统编辑器
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        // p1：inputStream输入流，传递给javac的数据，如果为null，表示使用System.in
        // p2：outputStream输出流，javac返回的数据，如果为null，表示使用System.out
        // p3：outputStream输出流，javac返回的错误信息，如果为null，表示使用System.err
        // p4：String类型的不定长数组，可以传递一个或者多个java源文件
        int result = compiler.run(null, null, null, "E:\\HelloWorld.java");
        System.out.println(result);// 0代表编译成功，1代表编译失败
    }

    @Test
    public void dynamicRun() throws Exception {
        URL url = new URL("file:/E:/");
        // 类加载器：把加载到内存中
        URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url});
        // 加载类名
        Class<?> loadClass = urlClassLoader.loadClass("HelloWorld");
        // 获取方法：main方法
        // p1：调用的方法的名字
        // p2：当你调用这个方法的时候传进来的参数类型
        Method method = loadClass.getMethod("main", String[].class);
        // invoke 是真正的在调用这个方法
        // 这里必须强转成Object类型，否则String[]数组参数会被拆成"a"和"b",与main方法的参数个数不符合
        method.invoke(null, (Object) new String[]{"a", "b"});
        urlClassLoader.close();
    }
}
```

> 如果客户端传递过来的不是一个java文件，而是一段java代码，则可以先用IO流技能将这段java代码输出到一个临时的java文件中，然后在动态编译和运行，得到结果后，别忘了销毁那个临时文件。
