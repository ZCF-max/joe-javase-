# 1. 初始化块

**概念：** JVM会在创建一个类和使用这个类中间的这一段时间里，执行初始化块（包括构造方法、动态块和静态块）里面的内容。

## 1.1 构造方法

**概念：** 构造方法，也叫构造器，是一种特殊的方法，当我们实例化（new）一个类的时候，就是在调用这个类的构造方法的过程，每new一次，就会调用一次。
- 特点：
    - 构造方法的名字必须和类名一致。
    - 构造方法没有返回值也不写 `void` 和 `return`。
    - 构造方法不能被 `static` 等修饰。
- 分类：
    - 隐式无参构造方法：这种构造方法是一个类的默认构造方法，new一个类的时候默认调用这个方法。
    - 显式无参构造方法：自己在类中编写一个没有参数的构造方法，会覆盖掉隐式无参构造方法。
    - 显式有参构造方法：自己在类中编写一个有参数的构造方法这种构造器可以写多个，它们的共存要求是参数列表不相同，new一个类的时候可以自动根据传进来的参数列表对应找到那个有参构造方法。
- 构造方法只能通过new来调用，不能使用方法的调用模式来进行调用。

**源码：** ConstructorDemo.java
```java
/**
 * @author JoeZhou
 */
public class ConstructorDemo {
    public ConstructorDemo() {
        System.out.println("ConstructorDemo 的无参构造...");
    }
    public ConstructorDemo(String str) {
        System.out.println("ConstructorDemo 的有参构造..." + str);
    }
    public ConstructorDemo(int numA, int numB) {
        System.out.println("ConstructorDemo 的有参构造..." + (numA + numB));
    }
}
```
 
**测试：**
```java
@Test
public void constructor() {
    new ConstructorDemo();
    new ConstructorDemo("赵四");
    new ConstructorDemo(15, 16);
}
```

## 1.2 动态块

**概念：** 动态块的格式就是 `{...}`，和构造方法一样，每new一次就会执行一次，不一样的是动态块必须全部执行，无法指定执行哪一个，而且执行顺序在构造器之前。

**源码：** DynamicBlockDemo.java
```java
/**
 * @author JoeZhou
 */
public class DynamicBlockDemo {
    public DynamicBlockDemo() {
        System.out.println("DynamicBlockDemo的构造...");
    }
    { System.out.println("DynamicBlockDemo的动态块01..."); }
    { System.out.println("DynamicBlockDemo的动态块02..."); }
}
```

**测试：** 
```java
@Test
public void dynamicBlock() {
    new DynamicBlockDemo();
    new DynamicBlockDemo();
    new DynamicBlockDemo();
}
```

## 1.3 静态块

**概念：** 
- 静态块的格式就是 `static{...}`，常用于一些初始化数据的工作。
- 静态块和动态块不一样，它就只执行一次，而且执行顺序在动态块之前。
- 静态块和静态方法一样，里面只能访问到静态的属性和方法。
- 静态块必须全部执行，无法指定执行哪一个。

**源码：** StaticBlockDemo.java
```java
/**
 * @author JoeZhou
 */
public class StaticBlockDemo {
    public StaticBlockDemo() {
        System.out.println("StaticBlockDemo的构造...");
    }
    { System.out.println("StaticBlockDemo的动态块01..."); }
    { System.out.println("StaticBlockDemo的动态块02..."); }
    static { System.out.println("StaticBlockDemo的静态块01..."); }
    static { System.out.println("StaticBlockDemo的静态块02..."); }
}
```

**测试：**
```java
@Test
public void dynamicBlock() {
    new StaticBlockDemo();
    new StaticBlockDemo();
    new StaticBlockDemo();
}
```

**练习：** 02002-1-3

# 2. this关键字

**概念：** java中提供this关键字，用法有两种：
- 当类中某个非静态方法的参数名和类的某个成员变量名相同时，为了避免参数的作用范围覆盖了成员变量的作用范围，必须明确的使用this关键字来指定哪个变量是当前类的成员属性。
    - `this.` 可以翻译成"当前实例的"，如 `this.name` 就是"当前类里的name属性"。
- 如果某个构造方法的第一条语句具有形式 `this(...)`，那么这个构造方法将调用本类中的其他构造方法。

**源码：** ThisDemo.java
```java
/**
 * @author JoeZhou
 */
public class ThisDemo {
    private String name;
    public ThisDemo() {
        this("赵四");
    }
    public void setName(String name) {
        this.name = name;
    }
    public ThisDemo(String str) {
        System.out.println("姓名为：" + str);
    }
}
```

**测试：**
```java
@Test
public void thisConstructor() {
    new ThisDemo();
    new ThisDemo("刘能");
}
```

**练习：** 02002

# 3. 单例模式

**概念：** 单例模式（单件模式）要求有且只有一个实例，其对外提供一个可以获取该实例的方法。

## 3.1 饿汉单例模式

**概念：** 饿汉单例模式下，无论是否调用这个 `getInstance()`，都将会new一个Singleton的实例出来，就像一个饿汉一样，无论是否吃馒头，都先做一个馒头出来备用，这无疑有些浪费。
- 将构造器私有化。
- 在类内部自己new一个实例备用。
- 对外提供一个静态方法，可以将我们自己new出来的实例返回。

**源码：** HungrySingleton.java
```java
/**
 * @author JoeZhou
 */
public class HungrySingleton {
    private final static HungrySingleton INSTANCE = new HungrySingleton();
    private HungrySingleton() {}
    public static HungrySingleton getInstance() {
        return INSTANCE;
    }
}
```

**测试：** 
```java
@Test
public void hungrySingleton() {
    HungrySingleton instanceA = HungrySingleton.getInstance();
    HungrySingleton instanceB = HungrySingleton.getInstance();
    System.out.println(instanceA == instanceB);
}
```

## 3.2 饱汉单例模式

**概念：** 饱汉单例模式下，可以解决资源浪费的问题。
- 将构造器私有化。
- 对外提供一个静态方法，只有当这个方法被调用的时候才new自己的实例并返回。

**源码：** FullSingleton.java
```java
/**
 * @author JoeZhou
 */
public class FullSingleton {
    private static FullSingleton instance;
    private FullSingleton() {}
    public static FullSingleton getInstance() {
        if (instance == null) {
            instance = new FullSingleton();
        }
        return instance;
    }
}
```

**测试：** 
```java
@Test
public void fullSingleton() {
    FullSingleton instanceA = FullSingleton.getInstance();
    FullSingleton instanceB = FullSingleton.getInstance();
    System.out.println(instanceA == instanceB);
}
```

# 4. POJO

**概念：** 
- POJO（Plain Ordinary Java Object）简单的Java对象，POJO中有一些属性及其getter/setter方法的类，没有业务逻辑，当然如果你有一个简单的运算属性也是可以的，但不允许有复杂的业务方法。
- 当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，它就是一个JavaBean。
- POJO分类：
    - `PO`：Persistant Object， 用在持久层，可以理解为POJO经过持久化后的对象。
    - `DTO`：Data Transfer Object，据传输对象，一般用于向数据层外围提供仅需的数据，如查询一个表有50个字段，界面或服务只需要用到其中的10个字段，DTO就包装出去的对象，DTO可用于隐藏数据层字段定义，也可以提高系统性能，减少不必要字段的传输损耗。
    - `VO`：View Object 用在视图层，一般用于web层向view层封装并提供需要展现的数据
    - `BO`：Business Object 用在service层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递，现在基本不用。
- 这些定义在实际使用设计中并不会全部用到，根据不同设计架构定义不同的类对象，形态大致如此，可根据自己项目进行调整。

> POJO和DOMAIN也是同一个概念。