# 1. 概念认知

**概念：** 
- 我们可以将一个类写在另一个类中，称为内部类写法，内部类提供了更好的封装，只能让它的外部类直接访问，不允许同一个包中的其他类直接访问。
- 一般内部类在只为外部类提供服务的情况下优先使用。
- 内部类也需要使用public等权限修饰符类界定允许访问的范围。

# 2. 成员内部类

**概念：**
- **成员内部类特性：**
    - 内部类可以访问外部类的成员（包括私有成员）。
    - 外部类不可以访问内部类的任何成员。
    - 成员内部类不能有静态方法、静态属性或静态块。
- **成员内部类访问外部类成员：**
    - 方法1：在内部类中使用外部类实例访问。
    - 方法2：在内部类中使用 `外部类名.this.属性名` 格式进行访问。
- **获取成员内部类实例：** 先获取外部类实例，然后使用 `外部类.new 内部类()` 的格式来获取内部类实例。
    - 内部类实例可以使用内部类类型接收，但是需要导包。
    - 内部类实例可以使用 `外部类.内部类` 的格式类型接收，无需导包。

**源码：** Outer.java
```java
/**
 * @author JoeZhou
 */
public class Outer {
    private String field = "field-outer";
    class Inner {
        private String field = "field-inner";
        public void innerMethod() {
            System.out.println(field);
            System.out.println(new Outer().field);
            System.out.println(Outer.this.field);
        }
    }
}
```

**测试：**
```java
@Test
public void innerClass() {
    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();
    inner.innerMethod();
}
```

> 内部类产生的class文件的格式是：`外部类$内部类.class`，如上面的案例，产生的class文件为：`Outer$Inner.class`。

# 3. 静态内部类

**概念：** 
- **静态内部类特性：**
    - 内部类可以访问外部类的成员（包括私有成员）。
    - 外部类不可以访问内部类的任何成员。
    - 静态内部类可以拥有静态属性、静态块和静态方法。
- **静态内部类访问外部类成员：** 允许在静态内部类中使用外部类实例访问，但不允许使用 `外部类名.this` 来访问。
- **获取静态内部类实例：** 先获取外部类实例，然后使用 `外部类.内部类()` 的格式来获取内部类实例（无需new静态内部类）。
    - 内部类实例可以使用内部类类型接收，但是需要导包。
    - 内部类实例可以使用 `外部类.内部类` 的格式类型接收，无需导包。

**源码：** StaticOuter.java
```java
/**
 * @author JoeZhou
 */
public class StaticOuter {
    private int field = 1;
    private static int staticField = 2;

    static class StaticInner {
        private int field = 3;
        private static int staticField = 4;

        public void method() {
            System.out.println(field);
            System.out.println(staticField);
            System.out.println(new StaticOuter().field);
            System.out.println(StaticOuter.staticField);
            // System.out.println(Outer.this.field);
        }

        public static void staticMethod() {
            System.out.println(staticField);
            System.out.println(new StaticOuter().field);
            System.out.println(StaticOuter.staticField);
            // System.out.println(field);
            // System.out.println(Outer.this.field);
        }
    }
}
```

**测试：**
```java
@Test
public void staticInnerClass() {
    StaticOuter.StaticInner staticInner = new StaticOuter.StaticInner();
    staticInner.method();
    StaticOuter.StaticInner.staticMethod();
}
```

# 4. 匿名内部类

**概念：** 
- 匿名内部类适合那种只需要使用一次的类，比如线程的创建等。
- 匿名内部类格式为：`new 父类构造/接口(){}`。

## 4.1 匿名内部类实现抽象类

**源码：** BaseService.java
```java
/**
 * @author JoeZhou
 */
public abstract BaseService {
    /**添加数据*/
    abstract void create();
}
```

**测试：** 
```java
@Test
public void baseServiceByInnerClass() {
    new BaseService() {
        @Override
        public void create() {
            System.out.println("添加...");
        }
    }.create();
}
```

## 4.2 匿名内部类实现接口

**源码：** UserService.java
```java
/**
 * @author JoeZhou
 */
public abstract UserService {
    /**添加数据*/
    void create();
}
```

**测试：** 
```java
@Test
public void userServiceByInnerClass() {
    new UserService() {
        @Override
        public void create() {
            System.out.println("添加...");
        }
    }.create();
}
```

# 5. Lambda表达式

**概念：** 
- **函数式接口：** 如果一个接口中只有一个抽象方法，那么它就可以称为函数式接口，函数式接口中允许存在静态方法和default方法。
- **Lambda表达式：** Lambda表达式是为了简化函数式接口的实现过程而存在的，它只为简化代码，不能提高效率。

## 5.1 Lambda结构

**概念：** 以 `(参数列表) -> {方法体}` 为主要格式，`->` 代表传递，变形有如下几种：
- `参数 -> {方法体}`：如果参数只有一个，可以省略括号，没有参数的时候不能省略。
- `参数 -> 方法体`：如果过程中只有一行代码可以省略，如果过程中只有一个return也可以省略。

**源码：** AdditionService.java
```java
/**
 * @author JoeZhou
 */
public interface AdditionService {

    /**
     * 两个int数相加的方法
     *
     * @param numA 加法运算的一个数字
     * @param numB 加法运算的另一个数字
     * @return 返回两个数相加的结果
     */
    int add(int numA, int numB);
}
```

**测试：**
```java
@Test
public void lambda() {
    AdditionService additionService = (numA, numB) -> numA + numB;
    System.out.println(additionService.add(10, 20));
}
```

## 5.2 Lambda返回值

**概念：** 
- Lambda表达式用来替代匿名内部类实现接口，得到接口实现类的对象，这也就意味着Lambda表达式具有自己的返回值类型。
- Lambda表达式的返回值类型，就是其实现的接口的类型，且该接口必须是函数式接口。
- 为了方便Lambda表达式的使用，Java 8中提供了4类新的核心接口配合Lambda表达式的功能，它们都定义在 `java.util.function` 包下。
    - 消费型接口Consumer，内置 `accpet()`，只有参数，没有返回值。
    - 供给型接口Supplier，内置 `get()`，只有返回值，没有参数。
    - 函数型接口Function，内置 `apply()`，既有返回值，又有参数。
    - 断言型接口Predicate，内置 `test()`，有参数，且返回值固定为boolean类型。