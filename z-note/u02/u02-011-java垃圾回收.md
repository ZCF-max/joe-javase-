# 1. 垃圾回收机制（GC）

**概念：** java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，由于有个GC，java中的对象不再有作用域的概念，只有对象的引用有作用域，垃圾回收可以有效的防止内存泄漏，有效的使用空闲的内存。
- 所谓程序的运行，其实就是变量不断地在内存中的申请领地，进行活动，最后交还领地给JVM内存的一个过程，假设程序最后不交还领地，则会导致内存垃圾越来越多。
- Java对内存垃圾的处理方式是全自动的，JDK提供了一个垃圾回收员（Garbage Collection），它会不定时跑到你的程序中去回收内存垃圾，消除了程序员手动清理垃圾的烦恼。

## 1.1 JVM栈的GC

**概念：** 内存的划分中，程序计数器、JVM栈和本地方法栈都是随线程生和死的，栈中的栈帧随着方法的调用有序的进栈和出栈，每个栈帧上分配的内存大小在类结构确定时就已知了，所以这些区域内存的分配和回收都是具有确定性的，很容易回收，当方法调用结束或者线程结束，占用的内存就可以被回收。

## 1.2 方法区的GC

**概念：**
- 虽然JVM规范中没有要求对方法区进行垃圾回收，但是一些虚拟机，如HotSpot虚拟机仍然实现了方法区的垃圾回收，方法区的垃圾主要是废弃的常量和无用的类。我们知道方法区中有一些常量池，如字符串常量池，如果系统中不存在引用常量池中常量的引用，那么在内存紧张的时候，这些常量就应该被废弃回收，常量池中的其他类（接口）、方法、字段、符号引用也是如此。
- 判断常量是否应该被废弃的方法比较简单，而判断一个类是无用的类，则需要满足下面三个条件：
    - 该类的所有实例都已经被回收了，即Java堆内存中没有该类的对象实例。
    - 加载该类的类加载器ClassLoader已经被回收了。
    - 该类对应的java.lang.Class对象在任何地方都没有被引用，也即无法通过反射访问该类。
    - 但满足了上述这些条件，也不是说这个类就要被非回收不可，我们是可以通过设置虚拟机参数进行控制的。

## 1.3 堆的GC

**概念：** 在Java堆中，每个类需要的内存都可能不一样，一个方法中多个分支需要的内存也可能不一样，这些都只有在运行期才能知道创建哪些对象，所以这部分内存的分配和回收都是动态的，垃圾回收也主要是对这部分的内存进行回收。

> 我们可以使用代码来建议GC回收System.gc();

# 2. 垃圾判定算法

**概念：** 什么样的实例算是垃圾？判断一个实例对象的生死很难，就像有些人虽然活着，但其实早就死了，一些人虽然死了，但永远活在我们心中，文艺可以扯淡，但是编程必须严谨，所以我们必须要有判断实例对象生或者死的方法。

## 2.1 引用计数算法

**概念：** 
- 当一个对象被创建时，为这个对象实例分配一个变量，该变量计数设置为1：
    - 每当有一个地方引用它时，计数器加1。
    - 每当一个对它的引用失效时，计数器减1。
    - 当计数器的值为0时，就说明不存在对它的引用了，它就可以去死了（不是立刻死亡，而是等待GC啥时候心情好，就过来干死它）。
- 一个对象被回收时，这个对象所引用的其他任何对象的引用计数器也会减一。
- 优点：简单高效直接。
- 缺点：无法检测和解决实例和实例之间的循环引用的问题，如实例A和实例B都是同一个类的实例，A中引用B，B中引用A，则A和B都不能被回收。

**源码：** 建立循环引用，测试当前JDK版本是否使用了引用计数回收策略。
```java
/**
 * @author JoeZhou
 */
public class ReferenceCountDemo {
    private ReferenceCountDemo field;

    public static void main(String[] args) {
        ReferenceCountDemo instanceA = new ReferenceCountDemo();
        ReferenceCountDemo instanceB = new ReferenceCountDemo();
        // 让两个实例循环引用，此时两个实例的引用计数均为1
        instanceA.field = instanceB;
        instanceB.field = instanceA;
        // 断开两个实例的堆栈联系，此时堆中的两个对象应为垃圾，但因为互相引用，永远无法被GC回收
        instanceA = null;
        instanceB = null;
        // 事实上内存在GC之后变小了，说明jdk8使用的不是引用计数的回收方式
        System.gc();
    }
}
```

> 使用 `-verbose:gc -XX:+PrintGCDetails` 运行参数可以看到详细的GC情况，可以发现PSYoungGen空间变小，说明程序依然执行了GC，也说明jdk1.8使用的不是引用计数回收策略。

## 2.2 可达性分析算法

**概念：** 可达性分析算法也叫根搜索算法，是从离散数学中的图论引进而来的，算法把所有的引用关系看成是一张图，从根节点（GC-Root）开始向下搜索实例对象，搜索所走的路径称为是引用链，当一个对象从根节点开始找不到任何一条引用链时，就说明这个对象可被回收，可达性分析算法的本质就是判断某个实例是否有从GC-Root出发的，可达的引用链。
- GC-Root，是一个特殊的对象，且绝对不能被其他对象引用（所以不会出现循环引用的问题）。
    - 虚拟机栈（栈帧本地变量表）中引用的对象。
    - 方法区中静态属性引用的对象。
    - 方法区常量引用的对象。
    - 本地方法栈中（Native 方法）引用的对象。
- jdk1.8使用的是可达性分析算法。
- `finalize()`：在可达性分析算法中，即使是不可达的对象，也并非是要立即执行死刑，它们暂时处于死缓状态，然后被判断是否要执行这个实例的 `finalize()`：
    - 不执行：如果实例没有重写Object类中的 `finalize()`，或者已经执行过一次 `finalize()` 且复活了一次，那么均被判定不执行 `finalize()`，直接被回收。
    - 执行：判定需要 `finalize()` 的实例会被加入到一个队列中，并且由JVM分配一个单独的线程来执行队列中这些实例中的 `finalize()`，如果某个实例的 `finalize()` 方法中，该实例突然被引用链上其他的可达实例关联了，那么这个实例就可以被移出这个即将回收的队列，从而死里逃生。

> 图：02013-2-2，可达性分析算法图示

## 2.3 引用详解

引用也是一个很模糊的概念，为了更加清晰的描述Java中的对象引用，在 JDK1.2后，Java 将引用分为4种，并且除了强引用外都有与之对应的Java类，都继承自Reference类。

- 强引用（Strong Reference）：new的时候就是强引用，类似 Object obj = new Object()
- 软引用（Soft Reference）：是用来描述一些有用，但非必须的对象引用，当内存特别紧张的时候，才会把这些对象列为回收目标进行回收，如果回收之后还是没有足够的内存，那么就会出现内存异常。对应Java类是SoftReference。一般用作缓存。
- 弱引用（Weak Reference）：也是用来描述一些非必须的对象引用，但是引用的强度要比软引用弱，不管内存是否充足，被弱引用关联的对象都将在下一次垃圾收集时被回收。对应Java类是WeakReference，一般用于容器设计中，比如ThreadLocal中就是使用的弱引用。GC看到它，就会立刻将它干掉。
- 虚引用（Phantom Reference）：又称为是幽灵引用或者是幻影引用，是最弱的引用关系。一个对象是否有虚引用，完全不会对该对象的生存造成影响，也无法用虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是，在这个对象被GC回收的时候，虚引用会被存储到一个队列中，然后用户收到一个系统的关于这个引用的死亡通知，通俗的说也就是让对象死的明明白白吧。对应Java类是PhantomReference。主要管理堆外内存，比如NIO的直接内存，你可以设计一个变量，为其添加虚引用，当虚引被回收的时候，你会收到一个通知，当收到这个通知的时候，你去利用别的手段回收对应的堆外内存。GC看到它，就会立刻将它干掉。

测试：强引用测试
```java
/**
 * @author JoeZhou
 */
public class StrongReferenceTest {
    public static void main(String[] args) throws IOException {
        Demo demo = new Demo();
        demo = null;
        System.gc();
        // block the main thread...
        System.out.println(System.in.read());
    }
    static class Demo{
        @Override
        protected void finalize() throws Throwable {
            System.out.println("GC会调用finalize()...");
        }
    }
}
```

测试：软引用测试
```java
public class SoftReferenceTest {
    public static void main(String[] args) throws InterruptedException {
        // -Xms20M -Xmx20M
        SoftReference<byte[]> softReference = new SoftReference<>(new byte[1024 * 1024 * 10]);
        System.out.println(softReference.get() == null);
        System.gc();
        TimeUnit.SECONDS.sleep(1L);
        System.out.println(softReference.get() == null);
        byte[] bs = new byte[1024 * 1024 * 11];
        System.out.println(softReference.get() == null);
    }
}
```

```java
/**
 * @author JoeZhou
 */
public class WeekReferenceTest {
    public static void main(String[] args) throws IOException {
        WeakReference<Demo> wrDemo = new WeakReference<>(new Demo());
        System.out.println(wrDemo.get() == null);
        System.gc();
        System.out.println(wrDemo.get() == null);
    }
    static class Demo{
        @Override
        protected void finalize() throws Throwable {
            System.out.println("GC会调用finalize()...");
        }
    }
}
```

# 3. 垃圾回收算法

## 3.1 标记-清除算法

概念：Mark-Sweep算法
描述：从头到尾遍历区域，绿色标记0，黄色标记1，再次遍历，将所有1清除。
优点：不需要双倍内存
缺点：
1. 整理后内存不连续，产生内存碎片，可能会导致以后再需要分配较大对象的时候，无法找到足够的连续内存而不得不提前触发另一次GC动作。
2. 效率慢，标记和清除这两个过程的效率都不高。

图：02011-3-1

**总结：**
如同它的名字那样，该算法分为 “标记” 和 “清除” 两个过程，标记和清除两个过程效率都不高，首先标记出需要回收的对象，如黄色区域，然后再将标记出的区域内容清除。标记过程需要遍历，这里面也涉及到广度优先搜索和深度优先搜索，这里就不多说了。

不足之处：一个是效率问题，搜索的效率；另外一个是空间问题，标记清除后会产生内存碎片，不利于给大对象分配内存空间。

标记-清除算法是最基础的收集算法，后续的收集算法都是对它的改进。

## 3.2 复制算法

Copy算法

描述：于内存中，再创建一块4*5大小的区域，从头到尾遍历之前的区域，将所有白色模块移动到新区域中，然后删除之前的内存区域。
优点：整理后没有碎片，复制代价小，速度快。
缺点：需要双倍内存

> 图：02011-3-2

别忘了复制之后，要把之前的内存块删掉。

为了解决标记-清除算法的效率问题，复制算法将内存容量划分为两个等量的部分，每次只使用一块，当一块使用完后，就将还存活的对象复制到另一块内存区域，并把刚才使用的那块内存区域一次性清除，这样每次都只需要对一半内存区域进行垃圾回收。

不足之处：这种做法看似简单除暴，但实现简单，运行高效，确实可以解决产生内存碎片的问题，但牺牲了一半可用内存空间的代价也未免太大。另外在对象存活率较高的时候，就需要进行大量的复制操作，效率将会变低，所以对于存活时间长的对象一般不使用这种收集算法。

## 3.3 标记-移动算法

描述：从头到尾遍历区域，绿色标记0，黄色标记1，再次遍历，遇到0向前移动，遇到1直接清除。
优点：整理后没有碎片，不需要双倍内存
缺点：但因在标记-清除算法的基础上增加了"移动"，所以效率比标记-清除要低一些。

> 图：02011-3-3

## 3.4 分代收集算法

概念：堆内存分为，分为新生代、老年代和永久代，新生代和老年代的默认内存大小比例是1：2，这个比例值是可以通过 -XX:NewRatio 参数来动态设置的。

> 02011-3-4 内存分代图

- 新生代（Young Generation）：动态存储，存储新产生的对象，新生代又被划分为3个区域：伊甸园Eden和两个Survivor（se wai wer）区（也叫幸存区），两个幸存区分别叫Survivor from和Survivor to。
    - Eden区：对象一开始都在Eden产生，当Eden满了，JVM执行一次minorGC，minorGC会在整个新生代里面执行GC动作，80%-90%的对象会在这里直接死去，存活下来的幸存对象会被拷贝到某个Survivor区 [A] ，且将幸存对象身上的计数器加1，Eden被清空，同时另一个Survivor区 [B] 中存活下来的幸存对象也会被拷贝到Survivor区 [A]（必须保证至少有一个Survivor区是空的），另外，垃圾回收过程中年龄足够老的对象（计数器值过大）直接进入老年代。整个过程可以看出是采取的复制算法，因为是从Eden将幸存者复制到S1或者S2的。
    - Survivor区：达到某个条件时，会将大于Survivor区的一半相对年龄大的对象都移入老年代，另外，在某次minorGC的过程中，年龄足够老的对象（计数器值过大）也会直接进入老年代。
- 老年代（Old Generation）：存储年龄稍大的对象，主要被MajorGC负责回收（速度比minorGC低10倍，采用标记清除或者标记移动的算法），达到某个条件时JVM会执行一次FullGC，整体大回收。

> 新生代 - minorGC - 复制算法
> 老年代 - majorGC - 标记清除或标记移动算法

# 4. 垃圾收集器

**概念：** 垃圾收集器是垃圾回收机制的具体实现，在JVM中，垃圾收集器可能存在一个或多个（单线程或多线程），它们在工作的时候，会短暂地暂停其他线程，这种情况被称为STW(Stop The Word)，减少STW时间是优化垃圾回收机制的重要指标。
- 垃圾收集器常见组合：
    - `UseSerialGC` = `Serial` + `Serial Old`，JVM客户端默认使用它。
    - `UseParNewGC` = `ParNew` + `Serial Old`
    - `UseConcMarkSweepGC` = `ParNew` + `CMS` + `Serial Old`
    - `UseParallelGC` = `PS Parallel` + `Serial Old（PS MarkSweep）`，JVM服务端默认使用它。

## 4.1 垃圾收集器分类

**概念：** 垃圾收集器的种类很多：
- `Serial`：
    - 一个单线程的新生代收集器，采取复制算法实现。
    - 在单CPU环境下，因为没有线程切换的开销，效率最高，STW控制在在几十到几百毫秒内。
- `Serial Old`：
    - Serial收集器的老年代版本，也是一个单线程收集器，采取标记-整理算法。
    - 它有个别名叫PS-MarkSweep。
- `ParNew`：
    - Serial收集器的多线程版本，收集算法、STW、对象分配的规则、回收策略等都与Serial收集器完全一样。
    - ParNew收集器的优势是更充分的利用CPU资源（多线程），缺点是是在单CPU下，效果不一定会比Serial好。
- `PS Scavenge` 收集器：
    - 一个多线程的新生代收集器，采取复制算法实现。
    - 对比ParNew收集器，它可以更加精准的控制CPU的吞吐量和STW的时间。
- `PS Old`：
    - PS-Scavenge收集器的老年代版本，采取标记-整理算法。
    - PS-Scavenge + PS-Old的组合，对于多CPU环境，吞吐量要求高的环境是很适合的。
- `CMS`：
    - CMS（Concurrent Mark Sweep），采取标记-清除算法，设计理念是尽可能地缩短STW时间。
    - CMD适用于一些特别重视响应速度的项目，但缺点是会产生大量的空间碎片。
- `G1`：
    - 目前最高端的收集器，采取标记-整理算法，不会产生内存碎片，并且也可以精准地控制STW的时间。
    - 对于新生代和老年代都是适用的，优先回收垃圾最多的区域。

## 4.2 垃圾收集器查看

**概念：** 不同版本的JDK选择的垃圾收集器也可能不同，JDK8使用的是 `ParallelGC` 包括新生代收集器 `PS Scavenge` 和 老年代收集器 `PS MarkSweep`。

**测试：** 查看当前版本的垃圾回收器。
```java
/**
 * @author JoeZhou
 */
public class GarbageCollectorTest {
    @Test
    public void myGarbageCollector() {
        for (GarbageCollectorMXBean e : ManagementFactory.getGarbageCollectorMXBeans()) {
            System.out.println(e.getName());
        }
    }
}
```

> 也可以直接使用java -XX:+PrintCommandLineFlags -version命令查看垃圾回收器。

