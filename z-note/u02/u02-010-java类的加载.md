1. 运行三部曲

一个java代码可以执行，需要经过三步骤，编写、编译和运行。

编写：在硬盘上编写java代码，需要符合Java开发规范，是我们的核心工作。

编译：通过javac命令将java代码编译成一个或多个class文件。
中间的过程主要是类型和格式的检查。
如：Person.java -> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字节码生成器 -> Person.class
字节码包括class文件相关信息，java源码中的声明和常量信息（元数据），源码中的语句和表达式等。
JVM和Java语言本身没什么关系，JVM只和class文件有关系，其他语言也能具有class文件。

运行：运行字节码文件
加载：将class文件中的字节码加载到JVM内存中
解释执行：逐行执行

2. 类加载器

一般情况下，因为有IDE辅助的关系，java的编译过程我们不是太关心，这里我们重点关注一下运行时期，类的加载的底层过程。

在了解一个类加载的过程之前，我们先来认识一下类加载器ClassLoader，因为它的主要工作，就是将.class文件中的字节码加载的JVM内存中。

[类加载器分类：级别自上而下]
启动类加载器(Bootstrap ClassLoader) 用C++语言实现，是JVM的一部分负责加载%JAVA_HOME%/lib中的class文件和其他类加载器
拓展类加载器(ExtClassLoader) 由Java语言实现，独立于JVM外部，继承自ClassLoader负责加载%JAVA_HOME%/lib/ext中的class文件
系统类加载器(AppClassLoader) 由Java语言实现，独立于JVM外部，继承自ClassLoader负责加载classPath下的class文件
自定义类加载器(UserClassLoader) 自己定义的类加载器

tips：JVM规范中并没有规定要从什么地方加载字节码，所以我们可以通过自定义类加载器的方式加载任何地方的字节码。

类加载器都在自己独立的空间内进行加载工作，那如果我在classpath下写一个java.lang.Object类的话，UserClassLoader会加载我的Object类，BootstrapClassLoader会加载%JAVA_HOME%\lib\rt.jar中的Object类，那岂不是说内存中有两个Object类的？为了解决这个问题，JVM引入了双亲委派模型。

双亲委派模型（Parent Delegation Model）：除了启动类加载器外，所有的加载器都有一个父加载器，当你一个加载器接到请求的时候，不会马上加载类，而是将这个请求向上传递给他的父加载器，看父加载器能不能加载这个类，如果不行，自己再出手。

理解：如果父类能干，我就不干了，如果父类不能干，我就自己干。

我们利用 “-verbose:class” 命令来详细地看一下ClassLoader的加载顺序
[run]
[Edit Configruations]
[VM arguments]
输入[-verbose:class]
/**
 * @author Joe
 */
public class ClassLoaderTest {
    public static void main(String[] args) {
        new TestClass01();
        System.out.println("--------------------");
        new TestClass02();
        new TestClass03();
        new TestClass03();
        new TestClass04();
        new TestClass04();
    }
}

class TestClass01 { }

class TestClass02 { }

class TestClass03 {
    static {
        System.out.println("TestClass03333333333333");
    }
}

class TestClass04 {
    {
        System.out.println("TestClass04444444444444444444");
    }
}

