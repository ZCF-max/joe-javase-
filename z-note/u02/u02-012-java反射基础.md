# 1. 入门概念

**概念：** 之前我们都是先设计一个类，然后通过这个类的实例来获取属性和方法，而其实我们还可以先得到这个类的Class对象，然后再通过Class对象获取属性和方法，这样的好处是可以获取所有属性和方法，即使是private修饰的。

> 反射是java动态性的一种体现。

**测试：** GetClassTest.java
```java
/**
 * @author JoeZhou
 */
public class GetClassTest {}
```

## 1.1 获取Class对象

**概念：** 获取Class对象有三种方式：
- `instance.getClass()`：要求必须得先有实例。
- `类名.class`：很便捷，但是属于硬编码，对于JDK中自带的类型，推荐使用这种。
- `Class.forName(qualifiedName)`：不是硬编码，对于自定义的类型，推荐使用这种。

**测试：** GetClassTest.java 中添加
```java
@Test
public void getClassByGetClassMethod() {
    GetClassTest instance = new GetClassTest();
    Class<?> class01 = instance.getClass();
    Class<?> class02 = instance.getClass();
    System.out.println(class01.hashCode() == class02.hashCode());
}

@Test
public void getClassByClassField() {
    Class<?> class01 = GetClassTest.class;
    Class<?> class02 = GetClassTest.class;
    System.out.println(class01.hashCode() == class02.hashCode());
}

@Test
public void getClassByForNameMethod() throws ClassNotFoundException {
    String qualifiedName = "com.joezhou.reflect.GetClassTest";
    Class<?> class01 = Class.forName(qualifiedName);
    Class<?> class02 = Class.forName(qualifiedName);
    System.out.println(class01.hashCode() == class02.hashCode());
}
```

## 1.2 数组的Class对象

**概念：** 判断数组的Class对象是否相同的时候，只比较它们的类型和维度。

**测试：** GetClassTest.java 中添加
```java
/**
 * @author JoeZhou
 */
public class ArrayClassTest {
    @Test
    public void arrayTypeTest() {
        Class<?> class01 = new int[10].getClass();
        Class<?> class02 = new int[20].getClass();
        Class<?> class03 = new int[10][10][10].getClass();
        Class<?> class04 = new double[10].getClass();
        System.out.println(class01 == class02);
        System.out.println(class01 == class03);
        System.out.println(class01 == class04);
    }
}
```

> new int[10].getClass() 可以简化为 int[].class 的写法。

# 2. 反射构造方法

**测试：** ConstructorTest.java
```java
/**
 * @author JoeZhou
 */
public class ConstructorTest {
    private Class<?> klass;
    @Before
    public void before() {
        klass = Demo.class;
    }
}
class Demo {
    public Demo() {System.out.println("public + ()：");}
    public Demo(String str) {System.out.println("public + (String)：" + str); }
    private Demo(int num) {System.out.println("private + (int)：" + num);}
    Demo(Double dbl) {System.out.println("(Double)：" + dbl);}
    protected Demo(Float flt) {System.out.println("protected  + (Float)：" + flt);}
    public void sayHello() {System.out.println("hello!");}
}
```

## 2.1 获取构造方法

**概念：** Class常用API方法：
- `Constructor<?>[] getConstructors()`：获取类的所有public修饰的方法。
- `Constructor<?>[] getDeclaredConstructors()`：获取类的所有方法。
- `Constructor<T> getConstructor()`：获取指定的一个public构造方法。
- `Constructor<T> getDeclaredConstructor()`：获取指定的一个构造方法。

**测试：** ConstructorTest.java中添加
```java
@Test
public void reflectConstructorsOnlyPublic() {
    Constructor<?>[] constructors = klass.getConstructors();
    for (Constructor<?> constructor : constructors) {
        System.out.println(constructor);
    }
}

@Test
public void reflectConstructors() {
    Constructor<?>[] constructors = klass.getDeclaredConstructors();
    for (Constructor<?> constructor : constructors) {
        System.out.println(constructor);
    }
}

@Test
public void reflectConstructorOnlyPublic() throws Exception {
    System.out.println(klass.getConstructor());
    System.out.println(klass.getConstructor(String.class));
}

@Test
public void reflectConstructor() throws Exception {
    System.out.println(klass.getDeclaredConstructor());
    System.out.println(klass.getDeclaredConstructor(int.class));
    System.out.println(klass.getDeclaredConstructor(String.class));
    System.out.println(klass.getDeclaredConstructor(Double.class));
    System.out.println(klass.getDeclaredConstructor(Float.class));
}
```

## 2.2 使用构造方法

**测试：** ConstructorTest.java中添加
```java
@Test
public void usePublicConstructor() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    Constructor<?> constructor = Demo01.class.getConstructor(String.class);
    Demo01 demo01 = (Demo01) constructor.newInstance("joe");
    demo01.sayHello();
}

@Test
public void useConstructor() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    Constructor<?> constructor = Demo01.class.getDeclaredConstructor(int.class);
    constructor.setAccessible(true);
    Demo01 demo01 = (Demo01) constructor.newInstance(28);
    demo01.sayHello();
}
```

# 3. 反射成员属性

**测试：** FieldTest.java
```java
/**@author JoeZhou*/
public class FieldTest {
    private String name;
    public int age = 26;
    double sal = 100;
    protected double bons = 20;
}
```

## 2.1 获取成员属性

**测试：** FieldTest.java 中添加
```java
@Test
public void getFieldsOnlyPublic() {
    Field[] fields = FieldTest.class.getFields();
    System.out.println(Arrays.toString(fields));
}

@Test
public void getFields() {
    Field[] fields = FieldTest.class.getDeclaredFields();
    System.out.println(Arrays.toString(fields));
}

@Test
public void getFieldOnlyPublic() throws NoSuchFieldException, SecurityException {
    System.out.println(FieldTest.class.getField("age"));
}

@Test
public void getField() throws NoSuchFieldException, SecurityException {
    System.out.println(FieldTest.class.getDeclaredField("age"));
    System.out.println(FieldTest.class.getDeclaredField("name"));
    System.out.println(FieldTest.class.getDeclaredField("sal"));
    System.out.println(FieldTest.class.getDeclaredField("bons"));
}
```

## 2.2 使用成员属性

**测试：** FieldTest.java 中添加
```java
@Test
public void usePublicField() throws Exception {
    Object instance01 = FieldTest.class.getDeclaredConstructor().newInstance();
    Object instance02 = FieldTest.class.getDeclaredConstructor().newInstance();
    
    // 属性对象.setInt(实例,值)：往哪个实例的对应属性中设置值
    Field ageField = FieldTest.class.getField("age");
    ageField.setInt(instance01, 25);
    ageField.setInt(instance02, 26);
    
    // 属性对象.getInt(实例)：从哪个实例中取出对应属性的值
    System.out.println(ageField.get(instance01));
    System.out.println(ageField.get(instance02));
}

@Test
public void useField() throws Exception {
    Object instance01 = FieldTest.class.getDeclaredConstructor().newInstance();
    Object instance02 = FieldTest.class.getDeclaredConstructor().newInstance();
       
    Field nameField = FieldTest.class.getDeclaredField("name");
    nameField.setAccessible(true);
    
    nameField.set(instance01, "赵四");
    nameField.set(instance02, "刘能");
    System.out.println(nameField.get(instance01));
    System.out.println(nameField.get(instance02));
}
```

# 4. 反射成员方法

**测试：** MethodTest.java
```java
/**@author JoeZhou*/
public class MethodTest {
    public static void fun01(String str, int a) {
		System.out.println("I am fun01..." + str + a);
	}

	private static void fun02() {
		System.out.println("I am fun02...");
	}
}
```

## 4.1 获取成员方法

**测试：** MethodTest.java 中添加
```java
	@Test
	public void getMethodsOnlyPublic() {
        // 包括继承下来的public方法
		Method[] methods = MethodTest.class.getMethods();
		for (Method method : methods) {
			System.out.println(method);
		}
	}

	@Test
	public void getMethods() {
        // 忽略继承下来的方法
		Method[] declaredMethods = MethodTest.class.getDeclaredMethods();
		for (Method method : declaredMethods) {
			System.out.println(method);
		}
	}

	@Test
	public void getMethodOnlyPublic() throws NoSuchMethodException, SecurityException {
		System.out.println(MethodTest.class.getMethod("fun01", String.class, int.class));
	}

	@Test
	public void getMethod() throws NoSuchMethodException, SecurityException {
		System.out.println(MethodTest.class.getDeclaredMethod("fun02"));
	}
```

## 4.2 使用成员方法

**测试：** MethodTest.java 中添加
```java
@Test
public void usePublicMethod() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    Object instance01 = MethodTest.class.getConstructor().newInstance();
    Method fun01 = MethodTest.class.getMethod("fun01", String.class, int.class);
    // 方法对象.invoke(实例,参数)：调用哪个实例中的这个方法，并传入对应参数
    fun01.invoke(instance01, "赵四", 58);
}

@Test
public void useMethod() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    Object instance01 = MethodTest.class.getConstructor().newInstance();
    Method fun02 = MethodTest.class.getDeclaredMethod("fun02");
    fun02.setAccessible(true);
    fun02.invoke(instance01);
}
```

# 5. 反射注解

首先获取标注了注解的类，得到一个该注解的实例：Class.forName("类全名")，当然过你想要获取的是一个属性上的注解，则需要通过类的实例getDeclaredField()来获取属性实例，然后再使用如下方法：

[可以使用的方法]
实例.getAnnotations() 获取实例上所有的注解，包括继承来的
实例.getDeclaredAnnotations() 获取实例上所有的注解，不包括继承来的
实例.getAnnotation() 通过注解名获取实例上的某个注解，包括继承来的
实例.getDeclaredAnnotation() 通过注解名获取实例上的某个注解，不包括继承来的

测试：
```java
@Test
public void test() throws ClassNotFoundException {
	// 获取类对象
    Class c = Class.forName("com.joe.annotation.MyAnnotationTest");
    
    // 通过注解名来获取这个类上的指定注解：强转成我们自己的注解类型
    MyAnnotation annotation = (MyAnnotation) c.getDeclaredAnnotation(MyAnnotation.class);
    
    // 调用注解中的参数
    System.out.println(annotation.age());
    System.out.println(annotation.name());
    System.out.println(Arrays.toString(annotation.course()));
}
```

# 6. 反射性能测试

调用一个方法的新能速度：

开启了普通调用 > setAccessible的反射 >  没开启setAccessible的反射

```java
/**@author Joe*/
public class ReflectPerformanceTest {

    private Long testTimes = 1000000000L;

    @Test
    public void normalPerformance() {
        User user = new User();
        for (int i = 0; i < testTimes; i++) {
            user.hello();
        }
        System.out.println("普通方法调用完毕...");
    }

    @Test
    public void reflectPerformance() throws Exception {
        User user = new User();
        Method method = user.getClass().getDeclaredMethod("hello");
        for (int i = 0; i < testTimes; i++) {
            method.invoke(user);
        }
        System.out.println("没开启setAccessible方法的反射调用完毕...");
    }

    @Test
    public void reflectWithAccessPerformance() throws Exception {
        User user = new User();
        Method method = user.getClass().getDeclaredMethod("hello");
        method.setAccessible(true);
        for (int i = 0; i < testTimes; i++) {
            method.invoke(user);
        }
        System.out.println("开启了setAccessible方法的反射调用完毕...");
    }
}

class User {
    private int age;

    public void hello() {
        age++;
    }
}
```

tips：使用junit测试，可以在控制台直接查看耗时情况。