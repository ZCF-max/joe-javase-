# 1. 运行三部曲

**概念：** 一个java代码可以执行，需要经过三个步骤：
- 编写：在硬盘上编写java代码，需要符合Java开发规范，是我们的核心工作。
- 编译：通过javac命令将java代码编译成一个或多个class文件。
    - 编译的底层过程主要是类型和格式的检查，如：Person.java -> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字节码生成器 -> Person.class
    - 字节码包括class文件相关信息，java源码中的声明和常量信息（元数据），源码中的语句和表达式等。
    - JVM和Java语言本身没什么关系，JVM只和class文件有关系，其他语言也能具有class文件。
- 运行：运行字节码文件中的内容。
    - 加载：将class文件中的字节码从硬盘上加载到JVM内存中，准备进行操作。
    - 解释：逐行执行。

# 2. 类加载器

**概念：** 类加载器ClassLoader的主要工作就是将.class文件中的字节码加载的JVM内存中。
- 类加载器分类：级别自上而下
    - 启动类加载器 `BootstrapClassLoader`：用C++语言实现，是JVM的一部分，负责加载 `%JAVA_HOME%\jree\lib` 中的class文件和其他类加载器。
    - 拓展类加载器 `ExtClassLoader`：由Java语言实现，独立于JVM外部，继承自 `ClassLoader`，负责加载 `%JAVA_HOME%\jre\lib\ext` 中的class文件。
    - 系统类加载器 `AppClassLoader`：由Java语言实现，独立于JVM外部，继承自 `ClassLoader`，负责加载 `classPath` 下的class文件。
    - 自定义类加载器 `UserClassLoader`：自己定义的类加载器，JVM规范中并没有规定要从什么地方加载字节码，所以我们可以通过自定义类加载器的方式加载任何地方的字节码。

## 2.1 双亲委派模型

**概念：** 
- 重复加载问题：类加载器都在自己独立的空间内进行加载工作，如果我在classpath下写一个 `java.lang.Object` 类的话：
    - `AppClassLoader` 会加载我自己写的Object类。
    - `BootstrapClassLoader` 会加载 `%JAVA_HOME%\lib\rt.jar` 中的Object类。
    - 结果内存中出现两个Object类，发生错误，为了解决这个问题，JVM引入了双亲委派模型。
- 双亲委派模型 `Parent Delegation Model`：除了启动类加载器外，所有的加载器都有一个父加载器，当你一个加载器接到请求的时候，不会马上加载类，而是将这个请求向上传递给他的父加载器，看父加载器能不能加载这个类，如果全都不行，自己再出手。

> 双亲委派模型理解：如果父类能干，我就不干了，如果父类不能干，我就自己干。

## 2.2 类加载器的执行顺序

**概念：** 我们可以在main方法（不要使用junit测试）的运行过程中使用 `-verbose:class` 命令来详细地看一下各个ClassLoader执行加载的情况。

**流程：**
1. `run` - `Edit Configurations`
2. 在 `VM options` 一栏填入 `-verbose:class`
3. 运行代码，控制台查看内容。

**源码：** ClassLoaderTest.java
```java
/**
 * @author JoeZhou
 */
public class ClassLoaderTest {
    public static void main(String[] args) {
        new ClassA();
        System.out.println("main...");
        new ClassB();
        new ClassC(); new ClassC();
        new ClassD(); new ClassD();
    }
}
class ClassA { }
class ClassB { }
class ClassC {
    static { System.out.println("classC-static-block..."); }
}
class ClassD {
    { System.out.println("classD-dynamic-block..."); }
}
```

# 3. 类加载过程

**概念：** 类加载的过程最终会形成一些可以被JVM直接使用的Java类型，这个过程只有在运行期才会触发，所以会牺牲一些程序启动的性能，但是却可以提供更高的灵活度。
- 类加载必经的五个过程：加载，连接（校验，准备，解析），初始化，使用，卸载。
   
## 3.1 加载Loading

**概念：** 加载过程就是将class文件中的字节码 `bytecode` 一行一行读入JVM内存中的方法区，但不会执行。
- 通过类全名来获取定义这个类的二进制字节流，这部分工作由类加载器完成。
- 将这个字节流所代表的静态存储结构，转化成方法区中运行时数据结构。
- 在堆中生成一个对应的 `java.lang.Class` 对象，作为方法区中这个类的各种数据的访问入口。
- JVM在加载数组的时候为了提高效率，减少重复加载（数组中类型统一且固定），加载的是数组的类型，多维数组也是递归加载类型，直到发现非数组类型停止，而数组的创建由JVM直接完成。
- 基本数据类型和引用数据类型的加载过程没有差别，因为在编译阶段，基本数据类型就会被封装成对应的包装类。

## 3.2 连接Linking

**概念：** 连接又分为三个步骤：验证、准备和解析
- 验证 `Verification`：检查被加载的类是否有正确的内部结构，包括代码是否正确，类与类之间的关系是否合理等，这与编译时期的检查不同。
- 准备 `Preparation`：为类的静态属性和方法分配内存，并设置初始值，以保证在不赋值的情况下也可以正确使用。
- 解析 `Resolution`：将类的二进制数据中的符号引用（字面量）替换为直接引用（内存地址）。
    - 符号引用 `Symbolic References`：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，在class文件中表示我和你的关系，比如全路径名，方法名称等，只要是能无歧义地定位到目标即可。符号引用与JVM内存无关，引用的目标不一定加载到内存中，在Java中，一个类将会编译成一个class文件，在编译时，java类并不知道所引用的类的实际内存地址，只能用一些符号来替代，各种JVM实现的内存布局可能不一样，但是它们能接受的符号引用是一致的，因为符号引用的字面量明确定义在JVM规范的class文件格式中。
    - 直接引用可以是直接指向目标的指针，比如指向 `java.lang.Class`，指向静态方法，指向静态属性等，还可以是相对偏移量，比如指向属性变量，属性方法等，还可以是一个可以间接定位到目标的句柄。直接引用和JVM布局是相关的，同一个符号引用在不同的JVM上翻译出来的直接引用一般会不相同，如果有了直接引用，那引用的目标必定已经被加载到内存中了。总之，直接引用是在JVM中使用内存地址的形式来表示我和你的关系。

> 图 02009-3-4

**总结：**
- A.java通过javac之后，会形成A.class和B.class
- 变量b中存的到底是什么？是一个符号 "我引用了com.joe.pojo.B类"
- 类运行时，A和B才被加载到内存中，A分配到内存地址为0x0011，B分配到内存地址为0x0012
- B类有了真正的内存地址后，再将之前的符号引用"我引用了com.joe.pojo.B类"转成直接引用0x0012，这个过程就是符号引用转成直接引用的过程。

## 3.3 初始化（Initialization）

**概念：** 调用类的构造器（不是对象的构造器）和静态块，对成员变量（静态和非静态）赋值（不是赋初始值，是赋真正的值）。
- 一个类什么时候会被初始化？
    - 我是一个类
    - 有人new出我的一个对象的时候，我会被初始化
    - 访问我的静态成员（属性和方法）的时候，我会被初始化
    - 反射，克隆，反序列化我的时候，我会被初始化
    - 我的子类被初始化的时候，我会先被初始化
    - 如果我拥有main方法，我会被初始化
    - 如果我被初始化了，内部的执行顺序是：静态变量 -> 静态块 -> 属性、动态块 -> 构造器
    - 如果我有父类，且我被初始化了，内部的执行顺序是：父类的静态方法 -> 我的静态方法 -> 父类的构造器 -> 我的构造器
    - 在一个类加载器中，类只能初始化一次，如果这个类存在直接父类，并且父类没被初始化，则先初始化父类（不适用于接口）

## 3.4 实例在内存中存储

**概念：** 在JVM中，实例在内存中的存储也是很有规律的，存储的布局可以分为三块区域：
- 对象头区：Object Header
    - 存储对象的元数据信息，包括对象运行时数据和类型指针（JVM通过这个指针来确定它是属于哪个类的）
    - 存储Mark Word，包括对象自身的运行时数据，如它的哈希码和它在GC中分代的年龄、锁状态表示，线程持有锁，偏向锁ID，偏向锁时间戳等信息。
- 实例数据区：Instance Data
    - 存储真正有效的数据，即在程序中定义的各种类型的字段数据，这部分数据有一部分是从父类中继承下来的，也有在子类中定义的，总之都要被记录下来。
    - 各字段的分配策略为long/double，int、short/char，byte/boolean，相同宽度的字段总是被分配到一起，便于之后取数据。
- 对齐填充区：Padding
    - 对齐填充并不一定是必然存在的，因为HotSpot虚拟机内存管理的要求是给实例分配内存的大小必须是8字节的整数倍，所以不够的部分需要填充。又因为对象头部分正好是 8 字节的倍数，所以对齐填充实际上补全的是实例数据区域，对齐填充的数据并没有特殊的含义，仅仅是起到填充占位符的作用。

## 3.5 访问对象

**概念：** 在不同的虚拟机中，对象的访问方式也是不同的，主流的访问方式有使用句柄和直接指针两种。
- 使用句柄：是一种间接使用指针访问实例的方式，因为它需要先在Java堆中划分出一块内存区域作为句柄池。栈中的变量存储的是句柄池中稳定的句柄的地址，而句柄中包含的才是Java堆中的实例和对应的java.lang.Class各自的具体地址。
    - 使用句柄访问方式的最大好处是栈中的变量存储的是稳定的句柄地址，在实例被移动时只会改变句柄中的类型数据指针，而栈中变量本身不需要被修改。
- 直接指针：栈中的变量直接存储的是实例的地址。
    - 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的的时间开销。
    - HotSpot实现中采用的是本方式。

> 图：02009-3-6-1，直接引用图解

> 图：02009-3-6-2，使用句柄池方式图解

## 3.6 方法的调用

**概念：** 方法调用都是发生在栈里，一个方法对应一个栈帧。

**源码：**
```java
public class UserTest{
    public static void main(String[] args){
        User user = new User();
        user.a();
    }
}
class User{
    private String name;
    public void a(){
        b();
    }
    public void b(){
        System.out.println("b");
    }
}
```

**总结：** 上面的代码经历了如下流程：
1. main方法推入栈中。
2. JVM发现new关键字，将new变成一个字节码指令。
3. 检查常量池中是否有User类的符号引用，以判断这个类是否存在。
4. 检查User类是否被加载，连接、初始化过，如果没有重新加载。
    - 第一次时发现User类没有被加载过，加载，连接、初始化（执行静态块）。
    - 第二次时发现User类已经被加载过了，忽略加载，连接、初始化（不再执行静态块）。
5. 为user实例分配一块连续的堆内存空间，方式有两种：
    - 指针碰撞：分配内存空间包括开辟一块新的内存和移动指针两个步骤，非原子步骤可能出现并发问题，JVM采用CAS乐观锁解决。
    - 空闲列表：分配内存空间包括开辟一块新的内存和修改空闲列表两个步骤，非原子步骤可能出现并发问题，JVM采用CAS乐观锁解决
6. 为user实力中的属性name分配初始默认值null：保证了user可以不赋初始值就直接使用。	
7. 对user实例进行必要的对象头信息设置：
    - 标记GC分代年龄：记录一下user实例的年龄。
    - 标记元数据信息：记录一下user实例是哪个类的实例。
    - 标记HashCode：记录一下user实例的HashCode。
8. 方法a入栈，在main方法上
9. 方法b入栈，在a方法之上
10. b方法执行完毕弹出
11. a方法执行完毕弹出
12. main方法执行完毕弹出

**练习：** 02009-3-7

# 4. 字节指令

**概念：** 源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。
- javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。
- javap的用法格式：javap <options> <classes>
    - javap -help可以看到javap的options选项。
    - 其中classes就是你要反编译的class文件。
- 也可以通过IDEA的 `view` - `bytecode` 来查看文件的字节码，但前提是必须运行过一次。

源码：ByteCodeTest.java
```java
/**
 * @author JoeZhou
 */
public class ByteCodeTest {
    private int num;
    public int method() {
        return num++;
    }
}
```

## 4.1 字节码文件

**概念：** 编译ByteCodeTes.java文件得到一个ByteCodeTest.class 文件，以文本的形式打开生成的class文件，可以看到文件中的为16进制代码：
- 文件开头的4个字节称之为魔数，唯有以"cafe babe"开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。
- 0000是编译器jdk版本的次版本号0，0034转化为十进制是52，是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0， 通过java -version 命令稍加验证, 可得结果。
- 继续往下是常量池内容，这里不做分析。

## 4.2 字节码内容-基本信息

**概念：** 反解析ByteCodeTes.java文件，查看字节码内容。
- 命令：javap -v -p ByteCodeTest.class
- 类的访问标志：
    - ACC_PUBLIC（0x0001）：被public修饰
    - ACC_FINAL（0x0010）：被final修饰
    - ACC_SUPER（0x0020）：允许使用Invokespecial字节码指令的新语义
    - ACC_INTERFACE（0x0200）：是一个接口
    - ACC_ABSTRACT（0x0040）：是抽象的，包括接口和抽象类
    - ACC_SYNTHETIC（0x1000）：这个类并非由用户代码产生
    - ACC_ANNOTATION（0X2000）：是一个注解类
    - ACC_ENUM（0x4000）：是一个枚举类

**字节码：** 字节码文件前8行解析
- `Classfile ...ByteCodeTest.class`：标识class文件当前所在位置
    - `Last modified 2019-9-29`：标识文件最后修改日期
    - `size 309 bytes`：标识文件字节数
    - `MD5 checksum`：标识MD5值
    - `Compiled from "*.java"`：标识这个class文件是编译自哪个文件
- `public class ...ByteCodeTest`：类的全限定名
    - `minor version`：JDK次版本号
    - `major version`：JDK主版本号
    - `flags`：类的访问标志

## 4.3 字节码内容-常量池

**概念：** 常量池Constant pool 中标识的是常量池信息，可以理解成Class文件中的资源仓库，主要存放的是两大类常量：字面量和符号引用（类和接口的全限定名、字段的名称和描述符，方法的名称和描述符等）
- 标识前缀：V（void）
    - B（byte）/S（short）/I（int）/（J）long
    - F（float）/D（double）/Z（boolean）/C（char）
    - L（对象类型，以分号结尾，如 "Ljava/lang/Object;"）
    - [（数组类型，以分号结尾，如 "[L/java/lang/String;"）
    - [[（二维数组类型，以分号结尾，如 "[[L/java/lang/String;"）
- `#n` 表示常量池编号。

**字节码：** 常量池内容解析
```
Methodref #4.#15 ... 一个方法定义，指向了第4和第15个常量，最后可以拼接成当前行最右侧的注释内容：“//java/lang/Object."(init)":()V”。这段代码可以理解为该类的实例构造器的声明，由于ByteCodeTest类没有重写构造方法，所以调用的是父类Object的构造方法。此处也说明了ByteCodeTest类的直接父类是Object。该方法默认返回值是V, 也就是void，无返回值。
Fieldref #3.#16 ... 一个属性定义，指向了第3和第16个常量，最后可以拼成当前行最右侧的注释内容：“//com/joe/jvm/ByteCodeTest.field01:I”，最后的I表示int类型，详见 [属性类型] 表。
Class #17 ... 一个类引用，指向了第17个常量，最后可以拼成当前行最右侧的注释内容：“//com/joe/jvm/ByteCodeTest”，这里存储的是ByteCodeTest类的信息
Class #18 ... 一个类引用，指向了第18个常量，最后可以拼成当前行最右侧的注释内容：“//java/lang/Object”，这里存储的是Object类的信息
Utf8 字符串常量
NameAndType 变量名和变量类型拼成的字符串常量
```

## 4.4 字节码内容-方法代码

**概念：** 在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现。

**字节码：** 方法代码内容解析
```
private int field01 声明一个int类型的私有变量field01
descriptor:I 描述这个变量为为一个int类型
flags:ACC_PRIVATE 描述这个变量为为私有的
public *.ByteCodeTest() 声明一个构造器
descriptor:()V 描述这个构造器为无参
flags:ACC_PUBLIC 描述这个构造器为public修饰
code中的stack 描述最大操作数栈，JVM运行时会根据这个值来分配栈帧中的操作栈深度，此处为1
code中的locals 局部变量所需的存储空间，单位为Slot（JVM为局部变量分配内存时所使用的最小单位，为4个字节大小）。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。
code中的arg_size 方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this
```

---------------
attribute_info 方法体内容，0,1,4为字节码"行号"，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的"java/lang/Object."":()V", 然后执行返回语句，结束方法。

LineNumberTable 行号表，每个方法都有一个行号表，记录了字节码偏移量，即源码行号与字节码行号之间的对应关系，如line 1:0，记录的是源码中1号位置对应字节码中的0号位置。
- 可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，
- 如果选择不生成 LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。

LocalVariableTable 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。

同理可以分析Main类中的另一个方法"inc()": 方法体内的内容是：将this入栈，获取字段#2, 将int类型的1入栈，将栈内顶部的两个数值相加，返回一个int类型的值。
