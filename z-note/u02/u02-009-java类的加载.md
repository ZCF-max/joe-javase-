# 1. 运行三部曲

**概念：** 一个java代码可以执行，需要经过三步骤，编写、编译和运行。

- 编写：在硬盘上编写java代码，需要符合Java开发规范，是我们的核心工作。
- 编译：通过javac命令将java代码编译成一个或多个class文件。
    - 中间的过程主要是类型和格式的检查。
        - 如：Person.java -> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字节码生成器 -> Person.class
    - 字节码包括class文件相关信息，java源码中的声明和常量信息（元数据），源码中的语句和表达式等。
    - JVM和Java语言本身没什么关系，JVM只和class文件有关系，其他语言也能具有class文件。
- 运行：运行字节码文件
    - 加载：将class文件中的字节码加载到JVM内存中
    - 解释执行：逐行执行

# 2. 类加载器

**概念：** 在了解一个类加载的过程之前，我们先来认识一下类加载器ClassLoader，因为它的主要工作，就是将.class文件中的字节码加载的JVM内存中。
- 类加载器分类：级别自上而下
    - 启动类加载器(Bootstrap ClassLoader) 用C++语言实现，是JVM的一部分，负责加载%JAVA_HOME%/lib中的class文件和其他类加载器
    - 拓展类加载器(ExtClassLoader) 由Java语言实现，独立于JVM外部，继承自ClassLoader，负责加载%JAVA_HOME%/lib/ext中的class文件
    - 系统类加载器(AppClassLoader) 由Java语言实现，独立于JVM外部，继承自ClassLoader，负责加载classPath下的class文件
    - 自定义类加载器(UserClassLoader) 自己定义的类加载器，JVM规范中并没有规定要从什么地方加载字节码，所以我们可以通过自定义类加载器的方式加载任何地方的字节码。

## 2.1 双亲委派模型

**概念：** 类加载器都在自己独立的空间内进行加载工作，如果我在classpath下写一个java.lang.Object类的话，UserClassLoader会加载我的Object类，BootstrapClassLoader会加载%JAVA_HOME%\lib\rt.jar中的Object类，那岂不是说内存中有两个Object类的？为了解决这个问题，JVM引入了双亲委派模型。
- 双亲委派模型（Parent Delegation Model）：除了启动类加载器外，所有的加载器都有一个父加载器，当你一个加载器接到请求的时候，不会马上加载类，而是将这个请求向上传递给他的父加载器，看父加载器能不能加载这个类，如果不行，自己再出手。
- 理解：如果父类能干，我就不干了，如果父类不能干，我就自己干。

## 2.2 类加载顺序

**概念：** 我们利用 “-verbose:class” 命令来详细地看一下ClassLoader的加载顺序
- run - Edit Configurations - VM options
- 输入 -verbose:class

**源码：** ClassLoaderTest.java
```java
/**
 * @author JoeZhou
 */
public class ClassLoaderTest {
    public static void main(String[] args) {
        new ClassA();
        System.out.println("--------------------");
        new ClassB();
        new ClassC(); new ClassC();
        new ClassC(); new ClassC();
    }
}
class ClassA { }
class ClassB { }
class ClassC {
    static { System.out.println("classC-static-block..."); }
}
class ClassD {
    { System.out.println("classC-dynamic-block..."); }
}
```

> 不要使用junit测试，使用main方法。

# 3. 类加载过程

**概念：** 类加载（Class Loading）是一种机制，描述的是将字节码以.class文件的形式加载到内存，再经过连接、初始化后，最终形成可以被JVM直接使用的Java类型的过程，这个过程只有在运行期才会触发，所以会牺牲一些程序启动的性能，但是却可以提供更高的灵活度。
- 类加载必经的五个过程：加载，连接（校验， 准备，解析），初始化，使用，卸载。
   
# 3.1 加载（Loading）

**概念：** 将class文件中的字节码（bytecode）一行一行读入JVM内存中的方法区，但不会执行。
- 通过类全名来获取定义这个类的二进制字节流，这部分工作由类加载器完成。
- 将这个字节流所代表的静态存储结构，转化成方法区中运行时数据结构。
- 在堆中生成一个对应的 `java.lang.Class` 对象，作为方法区中这个类的各种数据的访问入口。

tips：JVM在加载数组的时候为了提高效率，减少重复加载（数组中类型统一且固定），加载的是数组的类型，多维数组也是递归加载类型，直到发现非数组类型停止，而数组的创建由JVM直接完成。
tips：基本数据类型和引用数据类型的加载过程没有差别，因为在编译阶段，基本数据类型就会被封装成对应的包装类。

# 3.2 连接（Linking）

**概念：** 连接又分为三个步骤：验证、准备和解析
- 验证（Verification）：检查被加载的类是否有正确的内部结构，包括代码是否正确，类与类之间的关系是否合理等，这与编译时期的检查不同。
- 准备（Preparation）：为类的静态成员（包括属性和方法）分配内存，并设置初始值（比如null、0、false等）。
- 解析（Resolution）：将类的二进制数据中的符号引用（字面量）替换为直接引用（内存地址）。
    - 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，在class文件中表示我和你的关系，比如全路径名，方法名称等，只要是能无歧义地定位到目标即可。符号引用与JVM内存无关，引用的目标不一定加载到内存中，在Java中，一个类将会编译成一个class文件，在编译时，java类并不知道所引用的类的实际地址，只能用一些符号来替代，各种JVM实现的内存布局可能不一样，但是它们能接受的符号引用是一致的，因为符号引用的字面量明确定义在JVM规范的class文件格式中。
    - 直接引用可以是直接指向目标的指针，比如指向java.lang.Class，指向静态方法，指向静态属性等，还可以是相对偏移量，比如指向属性变量，属性方法等，还可以是一个可以间接定位到目标的句柄。直接引用和JVM布局是相关的，同一个符号引用在不同的JVM上翻译出来的直接引用一般会不相同，如果有了直接引用，那引用的目标必定已经被加载到内存中了。总之，直接引用是在JVM中使用内存地址的形式来表示我和你的关系。

> 图 02009-3-4

**总结：**
- A.java通过javac之后，会形成A.class和B.class
- 变量b中存的到底是什么？是一个符号“我引用了com.joe.pojo.B类”
- 类运行时，A和B才被加载到内存中，A分配到内存地址为0x0011，B分配到内存地址为0x0012
- B类有了真正的内存地址后，再将之前的符号引用“我引用了com.joe.pojo.B类”转成直接引用0x0012，这个过程就是符号引用转成直接引用

# 3.3 初始化（Initialization）

**概念：** 调用类的构造器（不是对象的构造器）和静态块，对成员变量（静态和非静态）赋值（不是赋初始值，是赋真正的值）。
- 一个类什么时候会被初始化？
    - 我是一个类
    - 有人new出我的一个对象的时候，我会被初始化
    - 访问我的静态成员（属性和方法）的时候，我会被初始化
    - 反射，克隆，反序列化我的时候，我会被初始化
    - 我的子类被初始化的时候，我会先被初始化
    - 如果我拥有main方法，我会被初始化
    - 如果我被初始化了，内部的执行顺序是：静态变量 -> 静态块 -> 属性、动态块 -> 构造器
    - 如果我有父类，且我被初始化了，内部的执行顺序是：父类的静态方法 -> 我的静态方法 -> 父类的构造器 -> 我的构造器
    - 在一个类加载器中，类只能初始化一次，如果这个类存在直接父类，并且父类没被初始化，则先初始化父类（不适用于接口）

# 3.4 实例在内存中存储

**概念：** 在JVM中，实例在内存中的存储也是很有规律的，存储的布局可以分为三块区域：
- 对象头区：Object Header
    - 存储对象的元数据信息，包括对象运行时数据和类型指针（JVM通过这个指针来确定它是属于哪个类的）
    - 存储Mark Word，包括对象自身的运行时数据，如它的哈希码和它在GC中分代的年龄、锁状态表示，线程持有锁，偏向锁ID，偏向锁时间戳等信息。
- 实例数据区：Instance Data
    - 存储真正有效的数据，即在程序中定义的各种类型的字段数据，这部分数据有一部分是从父类中继承下来的，也有在子类中定义的，总之都要被记录下来。
    - 各字段的分配策略为long/double，int、short/char，byte/boolean，相同宽度的字段总是被分配到一起，便于之后取数据。
- 对齐填充区：Padding
    - 对齐填充并不一定是必然存在的，因为HotSpot虚拟机内存管理的要求是给实例分配内存的大小必须是8字节的整数倍，所以不够的部分需要填充。又因为对象头部分正好是 8 字节的倍数，所以对齐填充实际上补全的是实例数据区域，对齐填充的数据并没有特殊的含义，仅仅是起到填充占位符的作用。

# 3.5 访问对象

**概念：** 在不同的虚拟机中，对象的访问方式也是不同的，主流的访问方式有使用句柄和直接指针两种。
- 使用句柄：是一种间接使用指针访问实例的方式，因为它需要先在Java堆中划分出一块内存区域作为句柄池。栈中的变量存储的是句柄池中稳定的句柄的地址，而句柄中包含的才是Java堆中的实例和对应的java.lang.Class各自的具体地址。
    - 使用句柄访问方式的最大好处是栈中的变量存储的是稳定的句柄地址，在实例被移动时只会改变句柄中的类型数据指针，而栈中变量本身不需要被修改。
- 直接指针：栈中的变量直接存储的是实例的地址。
    - 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的的时间开销。
    - HotSpot实现中采用的是本方式。

> 图：02009-3-6-1，直接引用图解

> 图：02009-3-6-2，使用句柄池方式图解

# 3.6 方法的调用

**概念：** 方法调用都是发生在栈里，一个方法对应一个栈帧。

**源码：**
```java
public class UserTest{
    public static void main(String[] args){
        User user = new User();
        user.a();
    }
}
class User{
    private String name;
    public void a(){
        b();
    }
    public void b(){
        System.out.println("b");
    }
}
```

**总结：** 上面的代码经历了如下流程：
1. main方法推入栈中。
2. JVM发现new关键字，将new变成一个字节码指令。
3. 检查常量池中是否有User类的符号引用，以判断这个类是否存在。
4. 检查User类是否被加载，连接、初始化过，如果没有重新加载。
    - 第一次时发现User类没有被加载过，加载，连接、初始化（执行静态块）。
    - 第二次时发现User类已经被加载过了，忽略加载，连接、初始化（不再执行静态块）。
5. 为user实例分配一块连续的堆内存空间，方式有两种：
    - 指针碰撞：分配内存空间包括开辟一块新的内存和移动指针两个步骤，非原子步骤可能出现并发问题，JVM采用CAS乐观锁解决。
    - 空闲列表：分配内存空间包括开辟一块新的内存和修改空闲列表两个步骤，非原子步骤可能出现并发问题，JVM采用CAS乐观锁解决
6. 为user实力中的属性name分配初始默认值null：保证了user可以不赋初始值就直接使用。	
7. 对user实例进行必要的对象头信息设置：
    - 标记GC分代年龄：记录一下user实例的年龄。
    - 标记元数据信息：记录一下user实例是哪个类的实例。
    - 标记HashCode：记录一下user实例的HashCode。
8. 方法a入栈，在main方法上
9. 方法b入栈，在a方法之上
10. b方法执行完毕弹出
11. a方法执行完毕弹出
12. main方法执行完毕弹出

**练习：** 02009-3-7

# 4. 字节码文件

**概念：** 字节码文件中有很多比较重要的信息，比如 `LineNumberTable` 行号表，每个方法都有一个行号表，记录了字节码偏移量，即源码行号与字节码行号之间的对应关系，如line 1:0，记录的是源码中1号位置对应字节码中的0号位置。

## 4.1 使用javap查看字节码

**概念：** 可以通过 `javap -l 类`  命令来查看这个文件的字节码。

**流程：**
1. 在桌面新建HelloWorld.java
2. 通过 `javac` 命令编译这个文件，得到HelloWorld.class。
3. 通过 `javap -l`  命令查看这个文件的字节码。

## 4.2 使用IDEA查看字节码

**概念：** 可以通过IDEA的 `view` - `bytecode` 来查看文件的字节码，但前提是必须运行过一次。

**流程：**
1. 新建HelloWorld.java
2. 运行HelloWorld.java
3. `view` - `bytecode`