# 1. 继承

**概念：** 
- 所谓继承就是将父亲的非private成员拿过来直接用，但是不包括构造方法，同时也可以拥有自己的成员。
- 继承是一种 `is a` 的关系，如"鸟is a动物"，"赵四is a人"等。
- 继承在java中是单方向的（单继承），且final修饰的类不能被继承。
- 继承具有层次性和传递性。
- 继承是为了提高代码可重用性，使程序变得简单。
- 类的祖先是 `java.lang.Object` 类，如果一个类没有声明指定父类，就默认继承Object类，Object类中有一些常用的方法。
    - `toString()`：  返回代表该实例的字符串形式，格式为类名@内存地址十六进制串。
    - `equals()`：判断两个实例是否指向同一内存区域。
    - `getClass()`：得到实例对应的模板的类全名。
    - `hashCode()`：得到对象的hash码，hashCode被设计用来提高性能，如果两个实例变量内存地址相等，那么它们一定有相同的hash值，但是两个实例变量有相同的hash值，但它们未必相等。

## 1.1 继承的实现

**概念：** java中的继承通过 `extends` 关键字来完成继承关系。

**源码：** Employee.java
```java
/**
 * @author JoeZhou
 */
public class Employee implements Serializable {
    private double salary = 2000.0;
    public double getSalary() {return this.salary;}
    public void setSalary(double salary) {this.salary = salary;}
}
```

**源码：** Manager.java
```java
/**
 * @author JoeZhou
 */
public class Manager extends Employee implements Serializable {
    private double bonus = 200.0;
    public double getBonus() {return bonus;}
    public void setBonus(double bonus) {this.bonus = bonus;}
}
```

**测试：**
```java
@Test
public void employeeAndManager() {
    Manager manager = new Manager();
    double salary = manager.getSalary();
    double bonus = manager.getBonus();
    System.out.println("月总薪水：" + (salary + bonus));
}
```

## 1.2 super关键字

**概念：** java中提供super关键字，用法和this类似，也有两种：
- 在子类调用父类的普通方法时，可以在子类的构造方法或者普通方法中使用 `super.方法名();` 来强行指定，仅在父类中寻找方法，否则默认现在子类中寻找该方法，找不到再去父类中寻找。
- 想在子类调用父类的构造方法，必须在子类构造方法中的第一行使用 `super()`。
- 调用子类构造的时候，一定会先去调用父类的构造，然后再调用子类的构造。

**源码：** Animal.java
```java
/**
 * @author JoeZhou
 */
public class Animal {
    private String name;

    public Animal() {}

    public Animal(String name) {
        this.name = name;
    }

    public void move() {
        System.out.println("动物都可以移动！");
    }

    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
}
```

**源码：** Bird.java
```java
/**
 * @author JoeZhou
 */
public class Bird extends Animal {
    public Bird() {
        super("精卫");
    }
}
```

**源码：** Dog.java
```java
/**
 * @author JoeZhou
 */
public class Dog extends Animal {
    public Dog() {
        super.move();
    }

    public void methodA() {
        super.move();
    }
}
```

**测试：**
```java
@Test
public void animalAndBirdAndDog(){
    System.out.println(new Bird().getName());
    new Dog().methodA();
}
```

**练习：** 02003-1-2

# 2. 多态

**概念：** 
- 一种类型多种形态，多态是一个 `like a` 的关系：
    - 如同一个电话，拨不同的号码，实现不同的功能。
    - 如同一个插排，插不同的电器，实现不同的功能。
- 多态在JAVA中的实现就是方法的重载 `overload` 和方法的重写 `override`。

## 2.1 方法的重载

**概念：** 方法的重载可以提高调用方法时的体验，节省代码，要求：
- 在同一个类中。
- 方法名相同。
- 参数列表不同。
- 其他方法要素，如返回值等均无要求。

**练习：** 02003-2-1

## 2.2  方法的重写

**概念：** 方法的重写，要求：
- 在继承关系的两个类中，即父子类中。
- 方法名相同。
- 参数列表也相同。
- 修饰符越写越大。
- 异常和返回值越写越小。
- 被 `final` 或者 `private` 修饰的方法，不能被重写。
- 重写的方法建议在方法上添加 `@Override` 进行标记。

> 重写原则：一大两小两不变。

**练习：** 02003-2-2

## 2.3 引用数据类型转换

**概念：** 我们可以new一个子类，然后使用父类实例接收，此时，如果 `Father` 和 `Son` 中有相同名字的方法或属性，则会发生动态绑定的现象：
- 方法看右边，属性看左边。

**源码：** Father.java
```java
/**
 * @author JoeZhou
 */
public class Father {
    public String name = "father";

    public void method() {
        System.out.println("method-father");
    }
} 
```

**源码：** Son.java
```java
/**
 * @author JoeZhou
 */
public class Son extends Father {
    public String name = "son";
    
    @Override
    public void method() {
        System.out.println("method-son");
    }
}
```

**测试：**
```java
@Test
public void sonAndFather() {
    // 动态绑定：不运行不知道到底new个什么
    Father father = new Son();
    
    // 具体调用的是哪个方法，看等号右边（运行时类型）
    father.method();

    // 具体调用的是哪个属性，看等号左边（编译时类型）
    System.out.println(father.name);
}
```

## 2.4 instanceof实例判断

**概念：** 
- 用 `对象变量名 instanceof 类名（接口名）` 来判断该变量所指向的对象是否属于该类。
- 只有父类原本就是由子类new出来的时候，才能向下转型，否则会报类转换异常：
    - `Dog -> Animal -> (Dog)Dog`，转换成功。
    - `Dog -> Animal -> (Cat)Cat`，转换异常。

**源码：** Animal.java
```java
/**
 * @author JoeZhou
 */
public class Animal{}
```

**源码：** Dog.java
```java
/**
 * @author JoeZhou
 */
public class Dog extends Animal{}
```

**测试：**
```java
@Test
public void instanceOf() {
    Dog dog = new Dog();
    Animal animal = new Animal();

    System.out.println(dog instanceof Animal);
    System.out.println(dog instanceof Dog);
    System.out.println(animal instanceof Animal);
    System.out.println(animal instanceof Dog);
    
    animal = new Dog();
    dog = (Dog)new Animal();
    
    dog = (Dog) animal;
    System.out.println(animal instanceof Animal);
    System.out.println(animal instanceof Dog);
    System.out.println(dog instanceof Animal);
    System.out.println(dog instanceof Dog);
}
```

**练习：** 02003-2-4
