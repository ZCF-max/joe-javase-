# 1. 概念入门

**概念：** 
- Annotation是从JDK5开始引入的新技术，注解不是注释（comment）、注解和注释一样，都可以对程序作出某种解释，但不同的是，注解可以被其它程序读取并操作。
- 注解是一个特殊的类：
    - 以 `public @interface 注解名{}` 的方式被创建。
    - 以 `@注解名(KV)` 的格式被使用。
- 注解可以修饰 `package`、`class`、`method` 和 `field` 等，但是在同一个位置，相同注解不能重复使用。

# 2. 内置注解

**概念：** jdk提供的默认注解，我们叫做内置注解，可以直接使用，使用方式如下：
- 注解如果只有一个参数，则可以使用 `@注解名(KV)` 的方法来使用。
- 注解如果有多个参数，则必须使用 `@注解名({KV, KV, KV...})` 的方法来使用，使用大括号修饰。

> 如果唯一的参数名是 `value`，则 `value` 也可以省略。

## 2.1 @Override

**概念：** 当子类重写了父类方法的时候，建议在重写方法上添加 `@Override` 来告诉javac，这个方法是一个重写方法，此时这个方法必须按照重写方法的格式来编写，否则javac将报错。

**源码：** Student.java
```java
/**
 * @author JoeZhou
 */
public class Student {
    @Override
    public String toString() {
        return "Student重写了toString()";
    }
}
```

**测试：**
```java
@Test
public void studentToString() {
    System.out.println(new Student().toString());
}
```

## 2.2 @Deprecated

**概念：** 表示不推荐使用的方法，当某个方法被此注解标识，则代表这个方法过时，在使用它的时候，javac会为此方法上添加删除线以作警示，但是这个方法仍能正确使用，不推荐不代表不能用。

**源码：** 在Student.java中添加
```java
@Deprecated
public void setStudentName(){
    System.out.println("设置学生姓名...");
}
```

**测试：**
```java
@Test
public void studentDeprecated() {
    new Student().setStudentName();
}
```

## 2.3 @SuppressWarnings

**概念：** `@SuppressWarnings` 用于镇压、抑制编译器产生警告信息，常用值如下：
- `all`：所有警告。
- `unused`：未曾使用过这个属性或方法的警告。
- `boxing`：装箱拆箱相关警告。
- `cast`：类型转换相关警告。
- `dep-ann`：使用了过时的注解的警告。
- `deprecation`：使用了过时的类或方法的警告。
- `fallthrough`：switch发生case穿透（未写break）时的警告。
- `finally`：finally块不能完成时的警告。
- `hiding`：不可见的局部变量警告。
- `incomplete-switch`：switch语句中缺少条目警告。
- `nls`：非NLS字符串文本警告。
- `null`：空分析警告。
- `rawtypes`：对类参数使用泛型时的非特定类型的警告。
- `restriction`：不鼓励或禁止引用的用法的警告。
- `serial`：可序列化的类中没有serialVersionUID属性。
- `static-access`：不正确的静态访问警告。
- `synthetic-access`：从内部类进行未优化的访问警告。
- `unchecked`：使用了未检查警告。
- `unqualified-field-access`：字段访问不合格相关的警告。

**源码：** 在Student.java中添加
```java
@SuppressWarnings(value = "unused")
public void warning() {
    int num = 10;
}
```

# 3. 元注解

**概念：** 元注解（meta-annotation）就是注解其他注解的注解，它负责对其他注解进行说明，Java中定义了四种元注解：
- `@Target`：描述注解的使用范围，即这个注解可以作用在什么地方，包上？方法上？类上？
- `@Retention`：描述注解的保留策略，即注解的生命周期，注解何时生效、何时失效？
- `@Documented`：标明这个注解会成为javadoc的一部分。
- `@Inherited`：标明这个注解可以被子类继承。

## 3.1 @Target

**概念：** @Target描述注解的使用范围，注解中有一个参数value，值是 `ElementType[]` 枚举数组类型，ElementType枚举属性如下：
- `ElementType.TYPE`：表示该注解可以定义在接口、类和枚举类上。
- `ElementType.FIELD`：表示该注解可以定义在字段、枚举常量上。
- `ElementType.METHOD`：表示该注解可以定义在方法上。
- `ElementType.PARAMETER`：表示该注解可以定义在方法参数上。
- `ElementType.CONSTRUCTOR`：表示该注解可以定义在构造器上。
- `ElementType.LOCAL_VARIABLE`：表示该注解可以定义在局部变量上。
- `ElementType.ANNOTATION_TYPE`：表示该注解可以定义在注解上。
- `ElementType.PACKAGE`：表示该注解可以定义在包上。

**源码：** @Target
```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    ElementType[] value();
}
```

## 3.2 @Retention

**概念：** 描述注解的生命周期，注解中有一个参数value，值是RetentionPolicy[]枚举数组类型，RetentionPolicy枚举属性如下：
- `RetentionPolicy.SOURCE`：表示该注解只在源代码中保留。
- `RetentionPolicy.CLASS`：表示该注解在类代码中保留，但在运行时无法获得。
- `RetentionPolicy.RUNTIME`：表示该注解在整个运行期间都保留。

**源码：** @Retention
```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    RetentionPolicy value();
}
```

> 只有生命周期为RUNTIME的时候，该注解才能被反射到。

# 4. 自定义注解

**概念：** 
- 使用@interface自定义注解时，自动继承了 `java.lang.annotation.Annotaion` 接口。
- 自定义注解属性的时候，要遵循以下规定：
    - 方法名就是是参数名，如果只有一个参数，一般起名为value，因为使用者可以对它省略。
    - 方法返回值就是参数类型。
    - 可以通过default来声明参数的默认值。
- 自定义注解的时候需要使用元注解，来声明你定义的注解可以用在什么地方，以及何时有效，如：
    - `@Target({ElementType.TYPE, ElementType.METHOD})`
        - 我这个注解可以作用在类上或者方法上
    - `@Retention(RetentionPolicy.RUNTIME)`
        - 我这个注解整个运行期间都能有效

**源码：** MyAnnotation.java
```java
/**
 * @author JoeZhou
 */
@Documented
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface MyAnnotation {

    // String name;
    String name();

    // int age = 18;
    int age() default 18;

    // String[] course = {"语文", "数学"}
    String[] course() default {"语文", "数学"};
}
```

**源码：** Student.java
```java
/**
 * @author JoeZhou
 */
@MyAnnotation(name = "赵四")
public class Student {

    @MyAnnotation(name = "刘能")
    public void method(){

    }
}
```