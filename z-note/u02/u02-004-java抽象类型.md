# 1. 抽象类

**概念：** 
- **抽象类：** 被 `abstract` 修饰的类叫做抽象类，可以理解为"半残类"，它有完整的构造方法，但不能直接调用，而是依靠子类构造方法来间接调用，从而完成实例化过程。
- **抽象方法：** 被 `abstract` 修饰且没有方法体的方法叫抽象方法，不能被 `private` 和 `final` 修饰。
- 抽象类中不一定有抽象方法，但拥有抽象方法的类一定得声明为抽象类。
- 抽象类命名应建议以Abstract或Base开头。

**源码：** BaseStartDemo.java
```java
/**
 * @author JoeZhou
 */
public abstract class BaseStartDemo {
    public void methodA() {
        System.out.println("methodA");
    }
    public abstract void methodB();
    public abstract void methodC();
}
```

> 实际上抽象类就是允许比普通类多一个抽象方法，且不能直接创建本类型而已。

# 2. 抽象方法实现

**概念：** 抽象类的实例化可以使用它的子孙类来完成继承重写的过程。

**源码：** MyStartDemo.java，BaseStartDemo.java见第一节源码
```java
/**
 * @author JoeZhou
 */
public class MyStartDemo extends BaseStartDemo {
    @Override
    public void methodB() {
        System.out.println("子类重写了methodB...");
    }
    @Override
    public void methodC() {
        System.out.println("子类重写了methodC...");
    }
}
```

**测试：**
```java
@Test
public void buildBySubClass() {
    BaseStartDemo baseStartDemo = new MyStartDemo();
    baseStartDemo.methodA();
    baseStartDemo.methodB();
    baseStartDemo.methodC();
}
```

**练习：** 02004-2

# 3. 接口

**概念：** 接口也是一个特殊的类，但是它规定：
- 接口中的属性都是默认被 `public static final` 修饰的。
- 接口中的方法都是默认被 `public abstract` 修饰的。
- 如果说抽象类是一个半残的类，那么接口就是一个全残的类。
- 接口需要将 `class` 关键字替换为 `interface`。

**源码：** UserService.java
```java
/**
 * @author JoeZhou
 */
public interface UserService {
    public static final String NAME = "123";
    String GENDER = "female";

    public abstract void methodA();
    void methodB();
}
```

# 4. 接口方法实现

**概念：** 接口和抽象类一样，要由子孙类来实现（不再叫做继承），通过 `implements` 关键字来完成。
- 接口一般直接命名，实现类在接口同包下新建子包 `impl`，然后实现类的名称就是接口名称并添加 `Impl` 后缀，如：
    - 接口名：`com.joe.service.UserService`
    - 实现类：`com.joe.service.impl.UserServiceImpl`

> 父子类关系中，如果创建一个子类，需要先去调用父类的构造器，然而接口没有构造器，所以子普通类或子抽象类不能继承父接口，但是子接口可以继承父接口，因为子类接口也无法被调用构造器。

**源码：** UserService.java
```java
/**
 * @author JoeZhou
 */
public interface UserService {
    String NAME = "赵四";
    String GENDER = "female";

    void methodA();
}
```

**源码：** UserServiceImpl.java
```java
/**
 * @author JoeZhou
 */
public class UserServiceImpl implements UserService {
    @Override
    public void methodA() {
        System.out.println("实现了methodA...");
    }
}
```

**测试：**
```java
@Test
public void userServiceBySubClass() {
    UserService userService = new UserServiceImpl();
    System.out.println(UserService.NAME);
    System.out.println(UserService.GENDER);
    userService.methodA();
}
```

**练习：** 02004-4

# 5. 抽象类和接口的区别

**总结：**
1. 抽象类有构造方法，接口没有构造方法。
2. 抽象类可以有非抽象的方法（部分抽、半残），接口中的方法都是抽象的（全抽、全残）。
3. 接口中的属性都是PSF固定修饰的，而抽象类无此规定。
4. 接口中的方法都是PA固定修饰的，而抽象类无此规定。
5. 抽象类可以继承其它的类，接口不能继承其他类。
6. 类与抽象类是单继承关系（单继承），类可以同时实现多个接口（多实现），且接口和接口之间是多继承。
7. 抽象类和它的子类是 `is a` 的关系，接口和它的实现类是 `like a` 的关系。

**练习：** 02004-5

# 6. 工厂模式

**流程：**
1. 设计接口 `Car` 和接口方法 `drive()`。
2. 设计奔驰实现类 `Benz`。
4. 测试：创建一辆奔驰实例并调用 `drive()`。

**源码：** Car.java
```java
/**
 * @author JoeZhou
 */
public interface Car {
    /**驾驶方法*/
    void drive();
}
```

**源码：** Benz.java
```java
/**
 * @author JoeZhou
 */
public class Benz implements Car {
    @Override
    public void drive() {
        System.out.println("奔驰在跑...");
    }
}
```

**测试：**
```java
@Test
public void factory() {
    new Benz().drive();
}
```

**总结：** `factory()` 即是生产者，负责造车又是使用者，负责开车，这不符合工厂模式的理念。

## 6.1 静态工厂

**概念：** 静态工厂模式（也称简单工厂）的目的就是想要将生产者和使用者分离，生产者只负责生产，使用者只负责使用。

**流程：**
1. 保留接口 `Car` 和奔驰实现类 `Benz`。
2. 设计工厂类 `CarFactory`。
3. 设计工厂方法 `getBenz()`：返回一个奔驰实例。
4. 测试：从工厂类中获取一辆奔驰实例并调用 `drive()`。

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public class CarFactory {
    public static Car getBenz() {
        return new Benz();
    }
    public static Car getBmw() {
        return new Bmw();
    }
}
```

**测试：**
```java
@Test
public void staticFactory() {
    CarFactory.getBenz().drive();
}
```

**总结：** 静态工厂做到了生产者和使用者的分离，但它不满足OCP开闭原则，因为一旦你想再添加一辆新品牌的车，则需要修改实现类 `CarFactory` 的内容。

> OCP开闭原则：`Open-Closed Principle：` 一个软件的实体应当对添加拓展开放，对修改重构关闭。

## 6.2 工厂方法

**概念：** 与静态工厂不同，工厂方法模式不将 `CarFactory` 定义为类，而是定义为接口。

**流程：**
1. 保留接口 `Car` 和奔驰实现类 `Benz`。
2. 设计工厂接口 `CarFactory`。
3. 设计工厂接口方法 `build()`：返回一辆车的实例。
4. 设计奔驰工厂接口实现类 `BenzFactory` 实现 `CarFactory`，专门负责造奔驰。

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public interface CarFactory {
    /**
     * 构建一辆车的实例
     * @return 车的接口实例
     */
    Car build(); 
}
```

**源码：** BenzFactory.java
```java
/**
 * @author JoeZhou
 */
public class BenzFactory implements CarFactory {
    @Override
    public Car build() {
        return new Benz();
    }
}
```

**测试：**
```java
@Test
public void factoryMethod() {
    new BenzFactory().build().drive();
}
```

**总结：** 
- 工厂方法满足OCP原则，因为你添加一辆奥迪，不需要去修改任何一个类或接口的内容，而是再添加一个奥迪类 `AuDi` 和奥迪工厂接口实现类 `AuDiFactory`。
- 但是它的缺点也显而易见，你需要让使用者去new对应的车厂，所以这种模式，理论上优于静态工厂，但实际开发中还是静态工厂用的比较多。

## 6.3 抽象工厂

**概念：** 抽象工厂模式在大型的项目中才会遇得到，这种工厂模式并不是对单独的产品（发动机/轮胎/内饰）进行操作，而是对一条产品族（发动机+轮胎）进行整体操作。

**流程：**
1. 设计一个轮胎的接口 `Tires` 和两个轮胎的实现类：`GoodTires` 和 `BadTires`。
2. 设计一个发动机的接口 `Engine` 和两个发动机的实现类：`GoodEngine` 和 `BadEngine`。
3. 设计一个车厂接口 `CarFactory`，负责制造轮胎和发动机等，有两个实现类：`GoodCarFactory` 和 `BadCarFactory`。
4. 在使用的时候，创造一个好车厂或者坏车厂，就可以决定创造出来的零件都是好的或都是坏的。

**源码：** Tires.java
```java
/**
 * @author JoeZhou 
 */
public interface Tires {
    void info();
}
```

**源码：** GoodTires.java
```java
/**
 * @author JoeZhou 
 */
public class GoodTires implements Tires {
    @Override
    public void info() {
        System.out.println("好轮胎...");		
    }
}
```

**源码：** BadTires.java
```java
/**
 * @author JoeZhou
 */
public class BadTires implements Tires {
    @Override
    public void info() {
        System.out.println("坏轮胎...");
    }
}
```

**源码：** Engine.java
```java
/**
 * @author JoeZhou 
 */
public interface Engine {
    void info();
}
```

**源码：** GoodEngine.java
```java
/**
 * @author JoeZhou
 */
class GoodEngine implements Engine {
    @Override
    public void info() {
        System.out.println("好发动机...");
    }
}
```

**源码：** BadEngine.java
```java
/**
 * @author JoeZhou
 */
class BadEngine implements Engine {
    @Override
    public void info() {
        System.out.println("坏发动机...");
    }
}
```

**源码：** CarFactory.java
```java
/**
 * @author JoeZhou
 */
public interface CarFactory {
    /**
     * 获取发动机
     * @return 发动机实例
     */
    Engine getEngine();

    /**
     * 获取轮胎
     * @return 轮胎实例
     */
    Tires getTires();
}
```

**源码：** GoodCarFactory.java
```java
/**
 * @author JoeZhou
 */
public class GoodCarFactory implements CarFactory {

    @Override
    public Engine getEngine() {
        return new GoodEngine();
    }

    @Override
    public Tires getTires() {
        return new GoodTires();
    }
}
```

**源码：** BadCarFactory.java
```java
/**
 * @author JoeZhou
 */
public class BadCarFactory implements CarFactory {

    @Override
    public Engine getEngine() {
        return new BadEngine();
    }

    @Override
    public Tires getTires() {
        return new BadTires();
    }
}
```

**测试：**
```java
@Test
public void abstractFactory(){
    // by good
    CarFactory goodFactory = new GoodCarFactory();
    goodFactory.getEngine().info();
    goodFactory.getTires().info();
    
    // by bad
    CarFactory badFactory = new BadCarFactory();
    badFactory.getEngine().info();
    badFactory.getTires().info();
}
```

**总结：** 这种工厂模式满足OCP原则，因为想加一条产品族，不需要改变原来的"车厂+零件"的产品族，而是再去添加一个"水果厂+配料"，或者"粮食厂+粮食"等即可。
