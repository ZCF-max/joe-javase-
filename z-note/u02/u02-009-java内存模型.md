# 1. JVM入门概念

**概念：** JVM是java虚拟出来的一块内存（运行java的场所），但它不是具体的产品，它只是一套规范标准，而 `HotSpot` 才是JDK1.8中，Oracle公司生产的一个JVM的具体实现：
    - JVM采用了那种实现，可以通过 `java -version` 命令查看。
    - 规范和实现的关系，可以对比理解成接口和实现类的关系。
- 运行时数据区：程序运行时，ClassLoader会将class文件加载到JVM中的运行时数据区（Runtime Data Area）中，该区域通常被分为五部分，如果将内存比作一个"小区"，那么：
    - Java栈 `Stack`：相当于小区的物业室，空间小，功能少，但访问方便。
    - Java堆 `Heap`：相当于小区的住宅区，空间大，功能多，但访问麻烦。
    - 方法区 `Method Area`：相当于小区的公告板，谁都可以用，且只存在一个。
    - PC寄存器 `Program Counter Register`：相当于小区的保安，监视并登记每个访问者（线程）的位置。
    - 本地方法栈 `Native Method Stack`：相当于小区的开发商，主要负责和操作系统打交道，因为使用的不是Java语言的原因，一般我们不关心，而且在JDK1.8版本中，此区域已经被整合到了Java栈中。

> 图：02009-1

# 2. PC寄存器

> 思考一个情景：<p>你在读一本非常喜欢的书，但是每过一阵子，你会受到你母亲大人的无情打断，去楼下取快递，去扫个地，去擦个玻璃等等等等...<p>那么每次当你被打断的时候，你最好使用一个书签，记录下你当前读到了书的哪一页，当你回来的时候，根据这个页数，可以继续阅读你的书...<p>线程也是一样，一个线程在做一项工作的时候，不知道会被打断多少次，因此它也需要一个“书签”，在它每次被打断的时候，能够记录当前程序运行到的“行号”，以便自己被重新唤醒时，能够准确地续接之前的工作，这个“书签”，就是PC寄存器。

**概念：** 
- PC寄存器也叫程序计数器，它占用很小的一块内存空间，它由JVM直接管理，不需要我们管理。
- PC寄存器是线程私有的，即每个线程中都有独立的PC寄存器。
- PC寄存器记录的是字节码指令的行号位置，其所在的线程会按照它的指示进行工作。
- PC寄存器只适用于非本地方法，如果线程执行的是本地方法（Native方法），则PC寄存器始终为空。
- PC寄存器初始值为0，当线程执行任务时，详细的步骤模拟如下：
    1. 字节码解释器（专门操作字节码的一个家伙）开始工作...
    2. PC寄存器自增：0 => 1
    3. 所在线程执行第1行字节码指令...
    4. 第1行字节码指令执行完毕...
    5. PC寄存器自增：1 => 2
    6. 所在线程执行第2行字节码指令...
    7. 第2行字节码指令执行完毕...
    8. ...
- 此区域是唯一一个在JVM规范中没有规定出现 `OutOfMemoryError`（OOM）情况的区域。

# 3. 栈内存

**概念：** JVM栈是负责执行java方法的一块内存区域，被每一个线程所私有，随线程的创建而创建。
- 一个线程中的每个方法在执行时都会创建一个对应的栈帧 `Stack Frame`，一个方法开始被调用到执行完成的过程，就对应着一个栈帧在JVM栈中从入栈到出栈的过程（FILO）。
- 不同线程之间所包含的栈帧是不允许存在相互调用的。
- 在一条活动线程中，只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，被称为当前栈帧。

> 本地方法栈：负责执行本地方法的一块内存区域，使用的是 `native` 方法，底层并不是java语言，不用我们操心，而且不同的JVM实现对栈区域的实现方式是不同的，比如 `HotSpot` 就把本地方法栈和JVM栈合二为一了。

## 3.1 栈帧组成

**概念：** 一个栈帧中主要包含：局部变量表、操作数栈、动态链接和方法出口。
- 局部变量表 `Local Variable Table`，也叫本地变量表，是一种线性表的数据结构。
    - 局部变量表存放的是在编译期就可知的各种基本数据类型和对象引用，一般指的就是方法的参数或者方法内的局部变量。
    - 一个方法需要在帧中分配多大的局部变量空间是在编译期就可以确定的。
    - 方法在运行期间局部变量表的大小是不会改变的。
- 操作数栈：用来保存计算过程的中间结果，如5*6，会得出一个30，这个30是个临时数据，并没有装在任何一个变量中，会暂时存放在这里。
- 动态链接：存放的是对象的引用。
- 帧数据区：装着访问常量池的指针和访问异常处理表的指针。

**源码：** 分别分析下面这三个方法的局部变量表大小并查看字节码验证。
```java
/**
 * @author JoeZhou
 */
public class LocalVariableTableTest {

    public static void main(String[] args) {
        String unit = new String("元");
        int money = getMoney();
        add(money, unit);
    }

    private static int getMoney() {
        return 10;
    }

    private static void add(int money, String unit) {
        System.out.println(money + unit);
    }
}

```

**字节码：**
```class
LOCALVARIABLE args [Ljava/lang/String; L0 L4 0
    LOCALVARIABLE unit Ljava/lang/String; L1 L4 1
    LOCALVARIABLE money I L2 L4 2
    MAXSTACK = 3
    MAXLOCALS = 3
```

## 3.2 栈帧工作流程

举个例子，分析如下源码
```java
public static void main(String[] args) {
    int a = 2;
    int b = 3;
    int c = (a + b) * 4;
    System.out.println(c);
}
```

本案例中字节码指令对照表，更多指令内容见附件
iconst_n 将字面量n压入操作数栈的栈顶
istore_n 将栈顶元素弹出，并存储到局部变量表的n号位置
iload_n 将局部变量表中的n号位置取出，并压入操作数栈的栈顶
iadd 将栈顶的两个元素弹出，相加，然后将结果压入操作数栈的栈顶
imul 将栈顶的两个元素弹出，相乘，然后将结果压入操作数栈的栈顶
getstatic #n 从常量池的#n位置获取静态属性，并将其值压入操作数栈的栈顶
invokevirtual #n 从常量池的#n位置获取实例方法（非静态），调用实例方法
return 本方法结束

对应的字节码指令流程为：可以通过"javap -v -p 类名.class"的命令查看字节码指令

main方法被调用
int a = 2;
iconst_2：将字面量"2"压入操作数栈顶
istore_1：将栈顶元素"2"弹出并存储到局部变量表的1号位置（a=2）
int b = 3;
iconst_3：将字面量"3"压入操作数栈顶
istore_2：将栈顶元素"3"弹出并存储到局部变量表的2号位置（b=3）
int c = (a + b) * 4;
iload_1：将局部变量表的1号位置元素"2"取出，压入操作数栈顶
iload_2：将局部变量表的2号位置元素"3"取出，压入操作数栈顶，此时"2"在"3"的上方
iadd：将栈顶的两个元素"2"和"3"分别弹出，进行相加，再将结果"5"，压入操作数栈栈顶
iconst_4：将字面量"4"压入操作数栈，此时"4"在"5"的上方
imul：将栈顶的两个元素"4"和"5"相乘，再将结果"20"，压入操作数栈栈顶
istore_3：将栈顶元素"20"弹出并存储到局部变量表的3号位置（c=20）
System.out.println(c);
getstatic #2：获取静态属性System.out，并将其压入栈顶，这个静态属性从常量池中获取，位置是#2。
istore_3：将局部变量表的3号位置元素"20"取出，压入操作数栈顶，此时"20"在"System.out"上方。
invokevirtual #3：将栈顶的两个元素弹出，然后调用静态属性System.out的实例方法println()输出"20"，这个实例方法也从常量池获取，位置是#3。
return：方法结束。

## 3.2 栈内存溢出

概念：
- 栈内存中的变量在出了作用域后会自动销毁，所以不用担心它的回收问题。
- 栈的大小啊可以固定也可以动态拓展，如果线程请求的栈调用深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。

测试：测试栈帧深度

/**
 * @author JoeZhou
 */
public class StackDepthTest {
    private static int num = 0;

    public static void main(String[] args) {
        try {
            fn();
        } catch (Throwable e) {
            System.out.println("栈深：" + num);
            e.printStackTrace();
        }
    }

    private static void fn() {
        num++;
        fn();
    }
}






















# 2. 查看字节码

**概念：** 字节码文件中有很多比较重要的信息，比尔 `LineNumberTable` 是行号表，每个方法都有一个行号表，记录了字节码偏移量，即源码行号与字节码行号之间的对应关系，如line 1:0，记录的是源码中1号位置对应字节码中的0号位置。

## 2.1 使用javap查看字节码

**概念：** 可以通过 `javap -l 类`  命令来查看这个文件的字节码。

**流程：**
1. 在桌面新建HelloWorld.java
```java
public class HelloWorld {
    public static void main(String[] args){
        System.out.println("Hello World!");
    }
}
```

2. 通过 `javac` 命令编译这个文件，得到HelloWorld.class。
3. 通过 `javap -l`  命令查看这个文件的字节码。

## 2.2 使用IDEA查看字节码

**概念：** 可以通过IDEA的 `view` - `bytecode` 来查看文件的字节码，但前提是必须运行过一次。

1. 新建HelloWorld.java
```java
public class HelloWorld {
    public static void main(String[] args){
        System.out.println("Hello World!");
    }
}
```
2. 运行HelloWorld.java
3. `view` - `bytecode`

