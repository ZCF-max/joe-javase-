# 1. String工具类

**概念：** 一个String对象的长度和内容都是不可变的，虽然使用"+"可以达到改变内容的目的，但实质会产生一个或多个新的字符串，如果这种改变很频繁，那就会特别浪费内存，如果你的操作中需要频繁进行字符串的拼接，不建议使用 "+"。

**测试：** 使用 "+" 拼接10万次字符串计算耗时
```java
@Test
public void plusSignStitchingTimeConsuming(){
    // 获取时间戳：距离1970年1月1日 0点0时0分 一个毫秒数。
    long startTime = System.currentTimeMillis();

    String str = "";
    for (int i = 0; i < 100000; i++) {
        str = str + i;
    }

    long endTime = System.currentTimeMillis();
    System.out.println("总耗时：" + (endTime - startTime) + "毫秒");
}
```

## 1.1 StringBuilder

**概念：**
- StringBuilder是jdk1.5版本提出来的一个类，它是一个可变长的字符串类，可以预分配缓冲区，我们可以通过它来进行频繁的字符串拼接操作。
- 创建方式：`StringBuilder stringBuilder = new StringBuilder("a");`
- 拼接方式：`append()`。
- 虽然在JDK1.8版本中，"+"的底层代码，也是在调用StringBuilder这个类的append()方法，但是多次调用"+"的时候，会创建多次StringBuilder，一样会导致效率低下，这里的优化仍未做到最好，所以在效率上，使用StringBuider仍然要比使用"+"，更优秀。

**测试：** 使用StringBuilder拼接10万次字符串计算耗时
```java
@Test
public void stringBuilderStitchingTimeConsuming(){
    long startTime = System.currentTimeMillis();
    StringBuilder stringBuilder = new StringBuilder("");
    for (int i = 0; i < 100000; i++) {
        stringBuilder.append(i);
    }
    long endTime = System.currentTimeMillis();
    System.out.println("总耗时：" + (endTime - startTime) + "毫秒");
}
```

> 时间戳：距离1970年1月1日 0点0时0分 一个毫秒数。

## 1.2 StringBuilder常用API

**概念：**
- `replace(n1, n2, "a")`：将n1到n2之间的元素，全部替换成字符串"a"。
- `insert(n1, "a")`：在n1之后，插入字符串"a"。
- `delete(n1, n2)`：将n1到n2之间的元素，全部删除。
- `deleteCharAt(n1)`：删除n1位置上的元素。
- `substring(n1, n2)`：截取出n1到n2之间的所有元素并返回。
- `reverse()`：水平翻转字符串。
- `toString()`：以字符串形式展示。

```!
以上范围均包括n1，但是不包括n2。
```

**练习：** 01010-1-2

## 1.3 StringBuffer

**概念：** StringBuffer是JDK1.0时代就存在的老员工了，它可以算是StringBuilder的亲生哥哥，它和StringBuilder的方法都是类似的，唯一的区别是，StringBuffer是线程安全的，而StringBuilder是线程不安全的。

**练习：** 01010-1-3

# 2. 数学工具类

**概念：** `java.lang.Math` 工具类提供了大量用于数学运算的方法，Math类是final类，因此不能从Math类继承，Math类中的方法都是static方法，因此不必创建Math类的对象就可以直接使用类的方法。
- `Math.abs(-10)`：绝对值。
- `Math.sqrt(16)`：平方根。
- `Math.cbrt(8)`：立方根。
- `Math.ceil(2.1)`：向上取整。
- `Math.floor(2.9)`：向下取整。
- `Math.max(1, 6)`：最大值。
- `Math.min(1, 6)`：最小值。
- `Math.pow(2, 3)`：a的b次幂。
- `Math.round(2.4)`：四舍五入。
- `Math.random()`：随机数：每次随机都生成一个[0-1)之间的数字。

> 随机数生成的代码，更建议使用 `new Random().nextInt(5);`，此时可以直接随机生成一个0到5范围内的int值。

**练习：** 01010-2

# 3. Scanner工具类

**概念：** `java.util.Scanner` 是JDK1.5之后引入的功能类，负责接收控制台上输入的字符，将其转换为相应数据类型的数据，并存储到相应的变量中。
- Scanner的特性规定我们在new它的时候，传一个固定的值 `System.in` 进去，代表输入流；
    - `Scanner scanner = new Scanner(System.in);` 
    - `scanner.close();`
    - `scanner.nextInt()`：接收控制台传递过来的整数。
    - `scanner.nextDouble()`：接收控制台传递过来的浮点数。
    - `scanner.next()`：接收控制台传递过来的字符串。

> IDEA中无法使用Junit测试Scanner，请换成main方法测试。

**练习：** 01010-3

# 4. Arrays工具类

**概念：** `java.util.Arrays` 类包含用来操作数组的各种方法：
- `toString(int[] arr)`：返回一维数组内容的字符串表示形式。
- `deepToString(int[][] arr)`：返回二维数组内容的字符串表示形式。
- `equals(int[] arrA, int[] arrB)`： 返回参数中的两个数组是否相同。
- `fill(int[] arr, int b, int c, int d)`： 从b位置到c位置，将d充满arr数组，bc可省略。
- `binarySearch(int[] arr, char key)`：在arr数组中，用二进制搜索法搜索key。
- `sort(int[] arr, int b, int c)`：从b位置到c位置，升序排列数组arr，bc可省略。
- `copyOf(int[] arr, int length)`：复制数组，底层调用的 `System.arraycopy()`。

**测试：**
```java
@Test
public void toString(){
    int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    System.out.println(Arrays.toString(arr));
}

@Test
public void deepToString(){
    int[][] arr = {{1}, {1, 2}, {1, 2, 3}};
    System.out.println(Arrays.deepToString(arr));    
}

@Test
public void equals(){
    int[] arr1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int[] arr2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int[] arr3 = {1};
    System.out.println(Arrays.equals(arr1, arr2));
    System.out.println(Arrays.equals(arr1, arr3));     
}

@Test
public void fill(){
    int[] arr = new int[5];
    Arrays.fill(arr, 0, arr.length, 13);
    System.out.println(Arrays.toString(arr));      
}

@Test
public void binarySearch(){
    int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    System.out.println(Arrays.binarySearch(arr, 5));       
}

@Test
public void sort(){
    int[] arr = {133, 12, 5, 4, 2, 6, 21, 561, 453, 10};
    Arrays.sort(arr);
    System.out.println(Arrays.toString(arr));  
}

@Test
public void copyOf(){
    int[] arrA = {1, 2, 3};
    int[] arrB = Arrays.copyOf(arrA, arrA.length);
    System.out.println(Arrays.toString(arrB)); 
}
```

# 5. 日期工具类

**概念：** `java.util.Date` 表示指定的日期信息，可以精确到毫秒，Date中许多方法已经过时但仍能使用。
- 构造器： 
    - `public Date()` 默认使用当前系统时间的时间戳。
	- `public Date(long date)` 允许自己指定时间戳。
- 常用API方法：	
    - `void setTime(long time)`：设置自定义日期，参数为时间戳。
    - `long getTime()`：获取时间戳。

**测试：**
```java
@Test
public void build(){
    Date date = new Date();
    System.out.println(date);

    date = new Date(1000L);
    System.out.println(date);

    date.setTime(5000L);
    System.out.println(date.getTime());
}
```

# 6. 日期格式化工具类

**概念：** `java.text.DateFormat` 是一个格式化日期的类。
- 构造器：
    - `DateFormat dateFormate = new SimpleDateFomat()`
    - `DateFormat dateFormate = DateFormat.getInstance();`
- 常用API方法：	
    - `String format(Date date)`：格式化：将Date类型数据按照指定的格式转换成String类型数据。
	- `Date parse(String dateStr)`：解析：将String类型数据按照指定的格式转换成Date类型数据。

**测试：**
```java
@Test
public void format() {
    Date now = new Date();
    String pattern = "yyyy年MM月dd日 hh:mm:ss";
    DateFormat dateFormat = new SimpleDateFormat(pattern);
    String result = dateFormat.format(now);
    System.out.println(result);
}

@Test
public void parse() {
    String olympicDate = "2008-08-08";
    String pattern = "yyyy-MM-dd";
    DateFormat dateFormat = new SimpleDateFormat(pattern);
    Date result = null;
    try {
        result = dateFormat.parse(olympicDate);
    } catch (ParseException e) {
        e.printStackTrace();
    }
    System.out.println(result);
}
```

**练习：** 01010-6

# 7. 日历工具类
 
**概念：** `java.util.Calendar` 是一个抽象基类，主要用于完成日期字段之间的相互操作功能，可以设置和获取日期数据的特定部分。
- 构造方法：
    - `Calendar calendar = new GregorianCalendar();`
    - `Calendar calendar = Calendar.getInstance();`
- 常用API：
    - `setTime(Date date)`：使用给定的Date设置此CalendarA的时间。
    - `getTime()`：转化成Date对象
    - `add(int field, int amount)`: 将日历的field字段添加或较少指定值。
    - `set(int field, int value)`: 将日历的field字段改为value值。
        - `Calendar.MONTH`：老外将12月作为每年的第一个月。
        - `Calendar.DAY_OF_WEEK`：老外将周日作为每周的第一天。
    - `get(int field)`：获得当前时间中field字段的值。

**测试：**
```java
@Test
public void calendarApi() {
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(new Date());
    DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

    // 将年份减去1
    calendar.add(Calendar.YEAR, -1);
    System.out.println(dateFormat.format(calendar.getTime()));

    // 将月份设置为1月
    calendar.set(Calendar.MONTH, 0);
    System.out.println(dateFormat.format(calendar.getTime()));

    int year = calendar.get(Calendar.YEAR);
    int month = calendar.get(Calendar.MONTH);
    int date = calendar.get(Calendar.DATE);
    int week = calendar.get(Calendar.DAY_OF_WEEK);
    int hour = calendar.get(Calendar.HOUR);
    int minute = calendar.get(Calendar.MINUTE);
    int second = calendar.get(Calendar.SECOND);
    System.out.printf("%d-%d-%d 星期%d %d:%d:%s", 
    	year, month + 1, date, week + 1, hour, minute, second);
}
```