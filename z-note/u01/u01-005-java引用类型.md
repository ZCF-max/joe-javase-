# 1. 引用数据类型

**概念：** 除了基本数据类型之外，都是引用数据类型，包括类、数组、接口等等。

## 1.1 String类型

**概念：** `java.lang.String` 是我们学到的第一个引用数据类型，表示字符串。
- 格式：变量类型 变量名 = new 构造函数();
- 理解：变量类型 变量名 = new 变量类型();
    - eg： `A a = new A();`
    - eg： `String str = new String("Hello");`
- 特权：String可以使用基本数据类型的声明方式。

> java.lang 这个包下的所有的类可以直接使用。

## 1.2 API与API文档

**概念：** API（Application Programming Interface）就是应用程序编程接口，而API文档是记录这些接口的工具，习惯性翻阅API文档来学习一个类，是一个程序神的必备技能。
- [API官方概念](https://baike.baidu.com/item/api/10154)
- [JDK8官网API文档](https://docs.oracle.com/javase/8/docs/api/index.html)
- **API学习方法：**
    - 名称：代码需要使用名字去调用它，但是不需要记忆。
    - 修饰：是否为静态？非静态方法使用实例调用，静态方法使用类名调用。
    - 用途：这个必须记住，否则就跟没学一样。 
    - 参数：要求传入什么类型的变量，就传入什么类型的变量，不需要记忆。
    - 返回值：有返回值就用一个对应类型的变量去接收它的返回值，不需要记忆。  

**练习：** 01005-1-2

# 2. 正则表达式概念
 
**概念：** 
- 正则表达式，又称为规则表达式，`Regular Expression`，在代码中一般简写为 `regex` 或者 `RE`，是对字符串操作的一种逻辑公式，是用事先定义好的一些特定字符、及这些特定字符的组合，组成的一个"规则字符串模板"，用来表达对字符串的一种过滤逻辑。
- 正则表达式很灵活、有逻辑，可以迅速地用极简单的方式达到字符串的复杂控制。
- 一个正则表达式由三部分组成：
    - 普通字符：数字和字母，如 `abc` 、 `123` 等。
    - 特殊字符：具有功能的特殊字符，也称为元字符，如 `\d` ， `\s` 等。
    - 限定字符：限定个数的字符，如 `{10}` 、`{5, 9}`  、 `+` 、 `?` 等。
- 字符串对空格是敏感的，不要在字符串中随意使用空格。

> `^` 和 `$` 表示一个正则的开始和结束的精准定位，^表示开头，$表示结尾，需要视情况选择是否使用。

## 2.1 普通字符

**概念：**
- `[abc]`：匹配 "abc" 中的任意一个字符
    - 成功案例：`"a"` 或 `"b"`
    - 失败案例：`"d"` 或 `"ab"`
- `[^abc]`：匹配除 "abc" 以外的任意一个字符
    - 成功案例：`"d"` 或 `"e"`
    - 失败案例：`"a"` 或 `"de"`
- `[a-z]`：匹配a到z之间的任意一个字符
    - 成功案例：`"a"` 或 `"b"`
    - 失败案例：`"A"` 或 `"38"`
- `[^a-z]`：匹配除了a到z之间的任意一个字符
    - 成功案例：`"A"` 或 `"38"`
    - 失败案例：`"a"` 或 `"b"`

> "|" 表示或者，[]不能省略。

**练习：** 01005-2-1

## 2.2 特殊字符

**概念：**
- `.`：匹配除 `\n` 和 `\r` 之外的任意一个字符
    - 成功案例：`"a"` 或 `"%"`
    - 失败案例：`"\n"` 或 `"\r"`
- `\d`：匹配一个数字字符，等价于 `[0-9]`
    - 成功案例：`"0"` 或 `"9"`
    - 失败案例：`"e"` 或 `"10"`
- `\D`：匹配一个非数字字符，等价于 `[^0-9]`
    - 成功案例：`"e"` 或 `"10"`
    - 失败案例：`"0"` 或 `"9"`
- `\n`：匹配一个换行符
    - 成功案例：`"\n"`
    - 失败案例：`"\\n"` 或 `"a"`
- `\t`：匹配一个制表符
    - 成功案例：`"\t"`
    - 失败案例：`"\\t"` 或 `"a"`
- `\w`：匹配Unicode字母、数字和下划线
    - 成功案例：`"_"` 或 `"a"`
    - 失败案例：`"\t"` 或 `"&"`
- `\W`：匹配除了Unicode字母、数字和下划线之外的字符
    - 成功案例：`"\t"` 或 `"&"`
    - 失败案例：`"_"` 或 `"a"`

**练习：** 01005-2-2

## 2.3 限定字符

**概念：**
- `{n}`：恰好匹配n次
- `{n,}`：至少匹配n次
- `{n,m}`：匹配n到m次，n<=m，注意逗号和两个数之间不能有空格
- `*`：匹配前面的子表达式任意次，等价于 `{0,}`
- `+`：匹配前面的子表达式一次或多次，等价于 `{1,}`
- `?`：匹配前面的子表达式零次或一次，等价于 `{0,1}`

> n和m均为非负整数。

**练习：** 01005-2-3

## 2.4 正则三大用途

**概念：**
- 数据验证：用RE和某个字符串进行匹配，通过的返回布尔类型结果来分析该字符串是否满足规则。
    - 配合字符串的 `matches()` 完成验证。
    - `"18210210122".matches("^1\\d{10}$")`
- 替换文本：用RE来识别文档中的特定文本，完全删除它，或者用其他文本替换它。
    - 配合字符串的 `replaceAll()` 完成替换。
    - `"My Name Is 9527".replaceAll("[a-z]", "-");`
    - 这里不要使用 "^" 或者 "$"，的格式，否则将只会替换字符串的第一个或最后一个满足要求的元素。
- 提取子串：用RE从某个字符串中提取一部分内容，这部分内容称为子字符串。
    - 配合字符串的 `split()` 完成字符串切割。
    - `"Test A. Test B. Test C.".split("\\.\\s*");`
    - 这里不要使用 "^" 或者 "$"，的格式，否则将只会替换字符串的第一个或最后一个满足要求的元素。

# 3. JVM内存分布

**概念：** 
- java程序在运行的时候，绝大部分的数据都在一块叫做运行时数据区（Runtime Data Area）的内存区域中活动。
- 运行时数据区，被划分成三块小的区域，分别被称为：
    - 栈内存：stack，相当于小区物业，空间小，功能少，访问方便。
    - 堆内存：heap，相当于小区住宅区，空间大，功能多，访问麻烦。
    - 方法区：Method Area，相当于小区广场，公共区域，所有人都可以访问。

## 3.1 内存地址

**概念：** 
- 基本数据类型全都分布在栈内存中。
- 引用数据类型的值分布在堆内存中，内存地址分布在栈内存中。
- 内存地址也叫引用或者句柄，就像住宅区居民楼的门牌号，全部登记在物业，这样当我去找赵四的时候，只需要去栈中查找赵四家的门牌号就可以直接找到他家，并不需要去一个门一个门去敲问。

**源码：** 分析如下三行代码在内存中的分布：
```java
int a = 100;
double b = 10.5;
String str = new String("java");
```

**练习：** 01005-3-1

## 3.3 相等比较之==

**概念：**
- 基本类型在使用 `==` 进行比较的时候，直接按照数学规则比较变量值。
- 基本类型在使用 `==` 进行比较的时候，会将参与比较的双方都转换成同一类型，然后再进行比较，转换的目标类型，以参与比较的双方类型中，字节数大的一方为准。
- 引用类型在使用 `==` 进行比较的时候，比较的是内存地址。

**源码：** 引用类型的 `==` 比较测试。
```java
@Test
public void ref() {
    String str01 = new String("JoeZhou");
    String str02 = new String("JoeZhou");
    
    // str01 和 str02 有着不同的内存地址，返回F
    System.out.println(str01 == str02);
}
```

## 3.4 相等比较之equals()

- 基本类型没有方法，所以无法使用 `equals()` 方法进行比较。
- `equals()` 方法来自于 `Object` 类（继承），原本的作用也是对内存地址进行比较，但是 `String` 类对其进行了重新改造（Override），使其变成了比较类型和值的一个方法。
- String类中的 `equals()` 方法先比较内存地址，如果内存地址不同，则比较字符串的内容。

# 4. 包装类

**概念：** 八个基本数据类型都有相对应的引用数据类型，叫做包装类。
- `Byte`/`Short`/`Integer`/`Long`/`Float`/`Double` 的父类是 `Number`。
- `Number` 的兄弟类是 `Boolean`，`Character`。

## 4.1 包装类的声明和赋值

**测试：**
```java
@Test
public void build() {
    System.out.println(new Byte((byte)100));
    System.out.println(new Short((short)200));
    System.out.println(new Integer(10000));
    System.out.println(new Long(10000000L));
    System.out.println(new Double(12.5));
    System.out.println(new Float(12.5F));
    System.out.println(new Character('a'));
    
    // System.out.println(new Boolean(true));
    // Boolean类型包装了更建议的一种声明方式
    System.out.println(Boolean.TRUE);
}
```

## 4.2 装箱和拆箱

**概念：** 
- 基本类型转成对应包装类的过程叫做装箱。
- 包装类转成对应基本类型的过程叫做拆箱。
- 在jdk1.5版本之前，需要我们手动拆装箱。
    - 手动拆箱：`Integer.valueOf(num)`
    - 手动装箱：`num.intValue()`
- 在jdk1.5版本之后，JVM自动拆装箱，代码上直接使用等号赋值即可。

**练习：** 01005-4-2