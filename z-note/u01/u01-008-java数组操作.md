# 1. 一维数组

**概念：** 数组就是在堆内存中开辟的一段连续的内存空间：
- 一维数组长度不可改变，内容类型必须一致。
- 一维数组下标从0开始，在知道位置的情况下查询快，操作费事。
- 数组是有默认值的，如int数组中的每个值都默认为0，double数组中的每个值都默认为0.0等。

> 数组内存分布图

## 1.1 一维数组声明

**概念：** 
- 声明一个数组的时候，要么指定内容，要么指定长度，且不可同时指定。
- 数组是引用数据类型，直接输出数组变量，得到的是引用数据类型的内存地址，我们可以利用 `Arrays.toString(arr)` 来快速查看数组的内容的字符串形式。

**测试：** 
```java
@Test
public void build(){
    int[] arrA = new int[]{1, 2, 3};
    int arrB[] = {1, 2, 3};
    int []arrC = new int[3];
    arrC[0]= 1;
    arrC[1]= 2;
    arrC[2]= 3;
    System.out.println(Arrays.toString(arrA));
    System.out.println(Arrays.toString(arrB));
    System.out.println(Arrays.toString(arrC));
}
```

> 因为String的特权导致，char[]是可以直接打印输出的（String的底层就是char数组），所以如果非要查看char[]的内存地址，可以将其拼接一个空字符串再输出，或者对其使用 `toString()`。

## 1.2 一维数组遍历    

**概念：** 
- 遍历方式：遍历指的就是将容器（这里指数组）中的元素一个一个拿出来进行其他操作，一般使用 `for` 或者 `for-each` 循环来遍历一维数组。
- 数组长度：使用 `arr.length` 来查看数组的长度。

**测试：** 
```java
@Test
public void traverseArray() {
    int[] nums = {1, 2, 3};
    
    for (int i = 0, j = nums.length; i < j; i++) {
        System.out.println(nums[i]);
    }
    
    for (int num : nums) {
        System.out.println(num);
    }
}
```

**练习：** 01008-1-3

## 1.3 一维数组复制

**概念：** 数组是引用数据类型，所以复制一个数组和直接递交引用并非是同一个概念，常见的数组复制方式有如下几种：
- 利用 `for` 循环复制数组。
- 利用 `System.arraycopy()` 复制数组。
- 利用 `Arrays.copyOf();` 复制数组，它的底层也是调用的 `System.arraycopy()`。

**测试：**
```java
@Test
public void copyArray() {
    int[] arrA = {1, 2, 3};
    
    // 利用for循环复制数组
    int[] arrB_1 = new int[arrA.length];
    for (int i = 0, j = arrA.length; i < j; i++) {
        arrB_1[i] = arrA[i];
    }
    System.out.println(arrB_1);
    
    // 利用System.arraycopy复制数组
    int[] arrB_2 = new int[arrA.length];
    // 从arrA的0号位置复制，到arrB_2的0号位置粘贴，复制长度arrA.length
    System.arraycopy(arrA, 0, arrB_2, 0, arrA.length);
    System.out.println(Arrays.toString(arrB_2));
    
    // 利用Arrays.copyOf复制数组
    // 从arrA的0号位置复制arrA.length个元素，并返回新数组
    int[] arrB_3 = Arrays.copyOf(arrA, arrA.length);
    System.out.println(Arrays.toString(arrB_3));
}
```

## 1.4 一维数组查找

**概念：** 
- 从一个一维数组中查找某个元素，需要遍历这个数组，用其中的每一个元素和我们要找的元素进行比较，这种方式浪费了大量的时间，很影响效率，所以我们在大量数据中查找某个元素的情况下，会使用到二分法的方式进行查找。
- 采用二分法查找时，数据需是排好序的。

**流程：**
1. 计算查找区间的中间位k：
    - `(高位 + 低位) / 2`。
2. 用 `arr[k]` 与目标查找值进行比较：
    - 若相等，查找成功，返回k。
    - 若 `arr[k]` 比目标值大，则划掉k及k后面位置上的所有元素。
    - 若 `arr[k]` 比目标值小，则划掉k及k前面位置上的所有元素。
    - 重新划分查找区域（重新计算中间位），继续二分查找。

**测试：**
```java
@Test
public void binarySearch(){
    int target = 13;
    int result = -1;
    int[] arr = { 1, 3, 5, 7, 9, 11, 13, 15 };
    int lowIndex = 0;
    int highIndex = arr.length - 1;
    int midIndex = (lowIndex + highIndex) / 2;
    
    while (lowIndex <= highIndex) {
    
        if (arr[midIndex] == target) {
            result = midIndex;
            break;
        } else {
            if (arr[midIndex] < targetEle) {
                lowIndex = midIndex + 1;
            } else {
                highIndex = midIndex - 1;
            }
        }
        
        midIndex = (lowIndex + highIndex) / 2;
    }
    System.out.println(result);
}
```

## 1.5 一维数组排序

### 1.5.1 选择排序 SelectionSort

**概念：** 
- 选择排序是一种简单直观的排序算法，它的工作原理是每一次从无序区中选出最小（或最大）的一个元素，追加到有序区，直到全部无序区的数据元素排完。
- 选择排序是不稳定的排序方法，比如序列 `[5， 5， 3]` 第一轮就将第一个 `5` 与 `3` 交换，导致第一个 `5` 挪动到第二个 `5` 后面。
- 选择排序的核心思想是抢夺：从第一个数开始，依次和后面所有的数进行比较。

**流程：** 以正序为例：{1, 3, 154, 2345, 1345}
1. 用 `arrs[0]` 和后面所有的元素比较，发现小的就抢过来：
    - 第1轮下来，`arrs[0]` 位置上就是整个数组中第1小的元素。
    - `arrs[0]` 组成有序区，其余仍在无序区。
2. 用 `arrs[1]` 和后面所有的元素比较，发现小的就抢过来：
    - 第2轮下来，`arrs[1]` 位置上就是整个数组中第2小的元素。
    - `arrs[0]` 和 `arrs[1]` 组成有序区，其余仍在无序区。
3. 用 `arrs[2]` 和后面所有的元素比较，发现小的就抢过来：
    - 第3轮下来，`arrs[2]` 位置上就是整个数组中第3小的元素。
    - `arrs[0]`、`arrs[1]` 和 `arrs[2]` 组成有序区，其余仍在无序区。
4. ...
5. 一共比较length-1次，无序区没有任何元素了，只剩下有序区，数组就排好序了。

**测试：**
```java
@Test
public void selectionSort(){
    int[] arr = { 101, 2, 23, 133, 412, 23, 412, 51, 235 };
    
    // 每轮都将确定将一个无序区中最小的元素追加到有序区，需要比较N-1次
    for (int i = 0, j = arr.length - 1; i < j; i++) {
    
        // 每一次都拿一个元素和后面所有的元素进行比较
        for (int m = i + 1, n = arr.length; m < n; m++) {
        
            // 只要比arr[x]小，arr[x]就将其抢夺，最终arr[x]一定是无序区最小的元素
            if (arr[i] < arr[m]) {
                int temp = arr[i];
                arr[i] = arr[m];
                arr[m] = temp;
            }
        }
    }
    System.out.println(Arrays.toString(arr));
}
```

### 1.5.2 冒泡排序 BubbleSort

**概念：** 
- 冒泡排序是一种计算机科学领域的较简单的排序算法，它从头开始，不断地比较相邻的两个元素，并进行对应的交换，直到最后排序完成。
- 这个算法的名字由来是因为越大（越小）的元素会经由交换慢慢浮到数列的顶端，故名。
- 冒泡排序的核心思想是交换：相邻的两个数进行比较。

**流程：** 以正序为例：{3, 1, 4, 2, 5};
1. 比较相邻的元素，如果前数比后数大，就交换他们两个。
2. 每一轮的工作内容是：对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。
3. 1轮结束后，数组倒数第1位的元素一定是数组中第1大的数，5个数需要比4次。
4. 2轮结束后，数组倒数第2位的元素一定是数组中第2大的数，需要比3次。
5. 3轮结束后，数组倒数第3位的元素一定是数组中第3大的数，需要比2次。
6. ...
7. 一共要比较4轮（n-1轮）。

**测试：**
```java
@Test
public void bubbleSort(){
    int[] arr = { 101, 2, 23, 133, 412, 23, 412, 51, 235 };
    
    // 每一轮：9个数，两两相比，要比9-1轮
    for (int i = 0, j = arr.length - 1; i < j; i++) {
    
        // 相邻两个数比较，需要比较length-1-i次
        for (int m = 0, n = arr.length - 1 - i; m < n; m++) {
        
            // 前数大于后数就交换，循环一次完毕保证最大的数排最后
            if (arr[m] > arr[m + 1]) {
                int temp = arr[m];
                arr[m] = arr[m + 1];
                arr[m + 1] = temp;
            }
        }
    }
    System.out.println(Arrays.toString(arr));
}
```

### 1.5.3 插入排序 InsertSort

**概念：** 
- 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法，插入排序法。
- 插入排序就是我们生活中按大小个排序的基本排序思想，基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，是稳定的排序方法。
- 原理就是从第二个元素开始，每次都和前一位的元素进行比较，如果小于前面的元素，则交换位置，继续向前比较，直到该元素排到第一位或者不再小于前面的元素，如果不小于前面的元素，则直接继续操作下一个元素。
- 插入排序的核心思想是插队：从第二个数开始，依次和前面的数进行比较。

**流程：** 我们这里以正序为例：{3, 1, 4, 2, 5};（个头小的往前站）
1. 我们假定 `[3]` 是一个排好序的队伍，从第二个元素开始每个元素看做一个新的，想要插队的元素。
2. 第二个元素是 `1`，`1` 要插队，跟队尾的 `3` 比较，赢了，和 `3` 交换位置，得到一个新的队伍 `[1, 3]`。
3. 第三个元素是 `4`，`4` 要插队，先跟队尾的 `3` 比较，输了，不动，得到一个新的队伍 `[1, 3, 4]`。
4. 第四个元素是 `2`，`2` 要插队，先跟队尾的 `4` 比较，赢了，和 `4` 交换，得到一个新的队伍 `[1, 3, 2, 4]`
    - 再和 `3` 比较，赢了，和 `3` 交换，得到新的队伍 `[1, 2, 3, 4]`
    - 再和 `1` 比较，输了，不动，最终得到数组 `[1, 2, 3, 4]`。
5. 第五个元素是 `5`，`5` 要插队，先跟队尾的 `4` 比较，输了，结束。
6. 最终队伍 `[1, 2, 3, 4, 5]`。

**测试：**
```java
@Test
public void insertSort(){
    int[] arrs = {101, 2, 23, 133, 412, 23, 412, 51, 235};
    
    // 从第i个位置开始依次向前比较，i从1开始，因为第0个人无法和它前面的人进行比较
    // 由于你的i是从1开始的，所以判断条件要改为i<arrs.length，不能使用length-1，否则会少比一次
    for (int i = 1, j = arr.length; i < j; i++) {
        
        // 角标为1的人（第二个人），最多需要向前比较1次
        // 角标为2的人（第三个人），最多需要向前比较2次
        // 角标为i的人（第i+1个人），最多需要向前比较i次，所以m = i ; m > 0 ; m--
        for (int m = i; m > 0; m--) {
        
            // 若后面的数小，交换，若后面的数大，直接结束循环，没有再向前比较的必要
            if (arr[m] < arr[m - 1]) {
                int temp = arr[m];
                arr[m] = arr[m - 1];
                arr[m - 1] = temp;
            } else {
                break;
            }
        }
    }
    System.out.println(Arrays.toString(arr));
}
```

# 2. 二维数组

**概念：** 二维数组可以看成是数组的数组，如果将二维数组看成是一个特殊的一维数组，那么这个一维数组的每一个元素都是数组。

## 2.1 二维数组声明

**概念：** 
- 声明一个二维数组的时候，要么指定内容，要么指定长度，且不可同时指定。
- 二维数组中的每个一维数组的长度可以不同。
- 可以利用 `Arrays.deepToString(arr)` 快速查看二维数组。

**测试：**
```java
@Test
public void build(){
    int[][] arr_1 = new int[][]{{1}, {4, 67}, {80}};
    int[] arr_2[] = {{1}, {4, 67}, {80}};
    int [][]arr_3 = new int[1][2];
    arr_3[0][0]= 1;
    arr_3[0][1]= 22;
    arr_3[0][2]= 313;
    arr_3[1][0]= 34;
    arr_3[1][1]= 311;
    arr_3[1][2]= 35;
    System.out.println(Arrays.deepToString(arr_1));
    System.out.println(Arrays.deepToString(arr_2));
    System.out.println(Arrays.deepToString(arr_3));
}
```

## 2.2 二维数组遍历

**概念：** 
- 遍历方式：指的就是将容器（这里指数组）中的元素一个一个拿出来进行其他操作，一般使用两个 `for` 或者 `for-each` 循环来遍历二维数组。
- 数组长度：使用 `arr.length` 来查看二维数组中一维数组的个数。

**测试：**
```java
@Test
public void traverseArray() {
    int[][] arr = {{1}, {4, 67}, {5}, {16, 17, 18, 40}};
    for (int i = 0, j = arr.length; i < j; i++) {
        for (int m = 0; m < arr[i].length; m++) {
            System.out.print(arr[i][m] + "\t");
        }
    }
    
    for (int[] e1 : arr) {
        for (int e2 : e1) {
            System.out.print(e2 + "\t");
        }
    }
}
```

**练习：** 01008-2-2