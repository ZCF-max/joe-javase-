# 1. 一维数组

**概念：** 数组就是在堆内存中开辟的一段连续的内存空间：
- 一维数组长度不可改变，内容类型必须一致。
- 一维数组下标从0开始，在知道位置的情况下查询快，操作费事。
- 数组是有默认值的，如int数组中的每个值都默认为0，double数组中的每个值都默认为0.0等。

> 数组内存分布图

## 1.1 一维数组声明

**概念：** 
- 声明一个数组的时候，要么指定内容，要么指定长度，且不可同时指定。
- 数组是引用数据类型，直接输出数组变量，得到的是引用数据类型的内存地址，我们可以利用 `Arrays.toString(arr)` 来快速查看数组的内容的字符串形式。

**测试：** 
```java
@Test
public void build(){
    int[] arrA = new int[]{1, 2, 3};
    int arrB[] = {1, 2, 3};
    int []arrC = new int[3];
    arrC[0]= 1;
    arrC[1]= 2;
    arrC[2]= 3;
    System.out.println(Arrays.toString(arrA));
    System.out.println(Arrays.toString(arrB));
    System.out.println(Arrays.toString(arrC));
}
```

> 因为String的特权导致，char[]是可以直接打印输出的（String的底层就是char数组），所以如果非要查看char[]的内存地址，可以将其拼接一个空字符串再输出，或者对其使用 `toString()`。

## 1.2 一维数组遍历

**概念：** 
- 遍历方式：遍历指的就是将容器（这里指数组）中的元素一个一个拿出来进行其他操作，一般使用 `for` 或者 `for-each` 循环来遍历一维数组。
- 数组长度：使用 `arr.length` 来查看数组的长度。

**测试：** 
```java
@Test
public void traverseArray() {
    int[] nums = {1, 2, 3};
    for (int i = 0, j = nums.length; i < j; i++) {
        System.out.println(nums[i]);
    }
    for (int num : nums) {
        System.out.println(num);
    }
}
```

**练习：** 01008-1-3

## 1.3 一维数组复制

**概念：** 数组是引用数据类型，所以复制一个数组和直接递交引用并非是同一个概念，常见的数组复制方式有如下几种：
- 利用 `for` 循环复制数组。
- 利用 `System.arraycopy()` 复制数组。
- 利用 `Arrays.copyOf();` 复制数组，它的底层也是调用的 `System.arraycopy()`。

**测试：**
```java
@Test
public void copyArray() {
    int[] arrA = {1, 2, 3};
    
    // 利用for循环复制数组
    int[] arrB_1 = new int[arrA.length];
    for (int i = 0, j = arrA.length; i < j; i++) {
        arrB_1[i] = arrA[i];
    }
    System.out.println(arrB_1);
    
    // 利用System.arraycopy复制数组
    int[] arrB_2 = new int[arrA.length];
    // 从arrA的0号位置复制，到arrB_2的0号位置粘贴，复制长度arrA.length
    System.arraycopy(arrA, 0, arrB_2, 0, arrA.length);
    System.out.println(Arrays.toString(arrB_2));
    
    // 利用Arrays.copyOf复制数组
    // 从arrA的0号位置复制arrA.length个元素，并返回新数组
    int[] arrB_3 = Arrays.copyOf(arrA, arrA.length);
    System.out.println(Arrays.toString(arrB_3));
}
```

## 1.4 一维数组查找

**概念：** 
- 从一个一维数组中查找某个元素，需要遍历这个数组，用其中的每一个元素和我们要找的元素进行比较，这种方式浪费了大量的时间，很影响效率，所以我们在大量数据中查找某个元素的情况下，会使用到二分法的方式进行查找。
- 采用二分法查找时，数据需是排好序的。

**流程：**
1. 计算查找区间的中间位k：
    - `(高位 + 低位) / 2`。
2. 用 `arr[k]` 与目标查找值进行比较：
    - 若相等，查找成功，返回k。
    - 若 `arr[k]` 比目标值大，则划掉k及k后面位置上的所有元素。
    - 若 `arr[k]` 比目标值小，则划掉k及k前面位置上的所有元素。
    - 重新划分查找区域（重新计算中间位），继续二分查找。

**测试：**
```java
@Test
public void binarySearch(){
    int target = 13;
    int result = -1;
    int[] arr = { 1, 3, 5, 7, 9, 11, 13, 15 };
    int lowIndex = 0;
    int highIndex = arr.length - 1;
    int midIndex = (lowIndex + highIndex) / 2;
    
    while (lowIndex <= highIndex) {
    
        if (arr[midIndex] == target) {
            result = midIndex;
            break;
        } else {
            if (arr[midIndex] < targetEle) {
                lowIndex = midIndex + 1;
            } else {
                highIndex = midIndex - 1;
            }
        }
        
        midIndex = (lowIndex + highIndex) / 2;
    }
    System.out.println(result);
}
```

# 2. 二维数组

**概念：** 二维数组可以看成是数组的数组，如果将二维数组看成是一个特殊的一维数组，那么这个一维数组的每一个元素都是数组。

## 2.1 二维数组声明

**概念：** 
- 声明一个二维数组的时候，要么指定内容，要么指定长度，且不可同时指定。
- 二维数组中的每个一维数组的长度可以不同。
- 可以利用 `Arrays.deepToString(arr)` 快速查看二维数组。

**测试：**
```java
@Test
public void build(){
    int[][] arr_1 = new int[][]{{1}, {4, 67}, {80}};
    int[] arr_2[] = {{1}, {4, 67}, {80}};
    int [][]arr_3 = new int[1][2];
    arr_3[0][0]= 1;
    arr_3[0][1]= 22;
    arr_3[0][2]= 313;
    arr_3[1][0]= 34;
    arr_3[1][1]= 311;
    arr_3[1][2]= 35;
    System.out.println(Arrays.deepToString(arr_1));
    System.out.println(Arrays.deepToString(arr_2));
    System.out.println(Arrays.deepToString(arr_3));
}
```

## 2.2 二维数组遍历

**概念：** 
- 遍历方式：指的就是将容器（这里指数组）中的元素一个一个拿出来进行其他操作，一般使用两个 `for` 或者 `for-each` 循环来遍历二维数组。
- 数组长度：使用 `arr.length` 来查看二维数组中一维数组的个数。

**测试：**
```java
@Test
public void traverseArray() {
    int[][] arr = {{1}, {4, 67}, {5}, {16, 17, 18, 40}};
    for (int i = 0, j = arr.length; i < j; i++) {
        for (int m = 0; m < arr[i].length; m++) {
            System.out.print(arr[i][m] + "\t");
        }
    }
    
    for (int[] e1 : arr) {
        for (int e2 : e1) {
            System.out.print(e2 + "\t");
        }
    }
}
```

**练习：** 01008-2-2

# 3. 位组

java.util.BitSet可以用位来存储布尔值（每一位的默认值为false），可以使用索引访问，位组可以自动扩容，每次扩容64。

BitSet bitSet = new BitSet();// 默认初始容量64
bitSet.set(0);// 将位组中的1号位的false改为true
bitSet.set(12);// 将位组中的13号位的false改为true
bitSet.set(64);// 位组容量超出，set()可以导致位组自动扩容至64+64=128
System.out.println(bitSet.size());// 位组尺寸扩容为128
System.out.println(bitSet.get(0));// 获取位组中1号位的值 -> true
System.out.println(bitSet.get(1));// 获取位组中2号位的值 -> false
System.out.println(bitSet.get(500));// 获取位组中501号位的值 -> false
System.out.println(bitSet.size());// 位组未扩容，仍未128，get()不会导致位组扩容


案例：设计一个方法可以判断一年中的第N天是否是法定节假日
import java.util.BitSet;
import org.junit.jupiter.api.Test;
/**
 * @ClassName: HolidayUtil
 * @author: joe
 * @date: 2018年12月25日下午3:02:27
 * @Description: 法定节假日工具类
 */
public class HolidayUtil {
	private static BitSet bitSet;// 位组

	// 实例化位组，默认容量365，对位模拟一年中的每一天，然后将一年中的第1天，第15天，第50天...等法定节假日天数
    // 对应位置set到位组中
	static {
		bitSet = new BitSet(365);// 每一位默认值false。
		int[] holidays = { 1, 15, 50, 148, 185, 246, 281, 316, 326, 359 };
		for (int i = 0, j = holidays.length; i < j; i++) {
			bitSet.set(holidays[i]);
		}
	}

	/**
	 * @Description 判断一年中的第day天是否是节假日。
	 * @param day 一年中的天数。
	 * @return true代表是节假期日，反之不是。
	 */
	public static boolean isHoliday(int day) {
		return bitSet.get(day);
	}

	@Test
	public void holidayTest() {
		System.out.println(HolidayUtil.isHoliday(16));
	}
}

# 4. 自定义栈

## 4.1 入栈push
```java
public void push(int value){
    int[] t_arrs = new int[arrs.length+1];
    for(int i=0,j=arrs.length;i<j;i++){
        t_arrs[i] = arrs[i];
    }
    t_arrs[arrs.length] = value;
    arrs = t_arrs;
}
```

## 4.2 出栈pop
```java
public int pop(){
    int lastElement = arrs[arrs.length-1];
    int[] t_arrs = new int[arrs.length-1];
    for(int i=0,j=arrs.length;i<j;i++){
        t_arrs[i] = arrs[i];
    }
    arrs = t_arrs;
    return lastElement;
}
```

## 4.3 查看栈顶peek
```java
public int peek(){
    return arrs[arrs.length-1];
}
```

## 4.4 判断栈是否为空
```java
public boolean isEmpty(){
    return arrs.length == 0;
}
```

# 5. 自定义队列

## 5.1 入队add
```java
public void add(int value){
    int[] t_arrs = new int[arrs.length+1];
    for(int i=0,j=arrs.length;i<j;i++){
        t_arrs[i] = arrs[i];
    }
    t_arrs[arrs.length] = value;
    arrs = t_arrs;
}
```

## 5.2 出队poll
```java
public void poll(){
    int firstElement = arrs[0];
    int[] t_arrs = new int[arrs.length-1];
    for(int i=0,j=t_arrs.length;i<j;i++){
        t_arrs[i] = arrs[i+1];
    }
    arrs = t_arrs;
}
```
