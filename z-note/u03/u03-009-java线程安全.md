# 1. 线程安全概念
 
**概念：** 当多线程并发访问时，程序有可能得不到正确的数据结果，即为线程不安全。
- 同步与异步：比如你和赵四一起做同一套数学模拟题，异步就是你们将卷子复制一套，然后一人做半套题，最后拼成一份答案，同步就是你做几道，将卷子扔给赵四，赵四做几道再扔给你，循环交替，直到卷子做完。
    - 异步：互不干扰，资源利用率高，因为整个过程中没有人会长时间处于等待状态，但是不安全，因为有可能两个人题目刷重。
    - 同步：安全，不会刷重题目，但是效率相对而言会低一些，但有些时候，我们不得不牺牲一点效率因素，来提升安全因素。
- 线程不安全原因：线程安全问题多由异步造成：
    - 比如赵四账户有1万元余额
    - 今天别人说好要给他转账5000元（线程A）
    - 他也要给别人转账2000元（线程B）
    - 线程A执行，10000 + 5000 = 15000 但是还未来得及更新账户余额，线程就进入了等待状态
    - 线程B执行，10000 - 2000 = 8000，但是还未来得及更新账户余额，线程就进入了等待状态
    - 线程A继续执行，更新账户余额为15000
    - 线程B继续执行，更新账户余额为8000
    - 最终，经过赵四一顿操作，余额最终为8000元
- 线程安全建议：
    - 尽量对共享资源使用同步的操作，如代码加锁等。
    - 尽量对共享资源使用原子性的操作，如使用JDK提供的原子类等。
    - 尽量少用共享资源，多用线程私有资源，如使用ThreadLocal等。

**源码：** thread/sync/TicketSellTest.java

# 2. synchronized

**概念：** 关键字synchronized可以将代码进行线程同步隔离，处于同步隔离区的代码，只能被所有线程排队执行，牺牲效率以保证数据安全。
- 本质：synchronized的本质是非公平锁，在字节码指令级：
    - 使用 `monitorenter` 指令来表示进入和离开隔离区，即获取锁。
    - 使用 `monitorexit` 指令表示离开隔离区，即释放锁。
- 用法：
    - 可以在方法签名中添加 `synchronized` 修饰，对整个方法加锁。
    - 可以使用 `synchronized(锁类型){}` 同步代码块对部分代码加锁。
    - 除了String，Integer和Long之外，都可以作为同步锁的类型。
    - 锁实例建议填写final，因为一旦运行中途锁实例被改变了，同步效果会立即消失。
    - 只有多个线程使用的是同一把锁时才会发生同步现象。
- 原则：粒度尽量小，数量尽量少，只在拥有共享数据的地方加锁。
- `synchronized` 也可以保证可见性，但不能禁止指令重排。

**源码：** thread/sync/TicketSellProTest.java

## 2.1 同步方法的锁类型

**概念：** 
- synchronized修饰成员方法时使用的是this锁。
- synchronized修饰静态方法时使用的是当前类的字节码锁。

**源码：** thread/sync/LockTypeTest.java

## 2.2 锁的可重入性

**概念：** synchronized的锁具有重入性，即在 `synchronized methodA()` 中可以调用 `synchronized methodA()`，因为是同一个线程申请的这把锁，允许重入同步代码区。
- 锁的重入流程：如果因重入而获取了5次锁，则对应的必须要释放5次重入锁，所以锁的重入次数必须被记录下来：
    - 在hotspot实现中，加非OS锁时会在线程栈中生成一个LR（Lock Record），将锁实例的mark-word信息进行备份（主要就是实例的hashcode）因为加锁后，锁的信息会覆盖掉这些信息。
    - 每重入一次，则都会再次入栈一个空的LR，重入5次锁，则入栈5个空LR。
    - 每释放一次锁，弹出1个空LR，5个空LR均被弹出，则表示全部重入锁释放完毕。
    - 最后再释放最后一个带有备份信息的LR（释放前还原备份信息），完成完整的同步操作。
- OS锁也可以重入，但重入次数不通过LR记录，而是通过底层的一个变量来完成。

**源码：** thread/sync/ReentryTest.java

## 2.3 异常释放锁

**概念：** syn同步代码如果爆发了异常会释放锁，此时其他等待进入的线程则有可能获取到锁，进入到同步代码中。

**源码：** thread/sync/ReentryTest.java

## 2.4 死锁
 
**概念：** 
- 假设吃饭的时候，我有一根筷子，你有一根筷子，我需要你给我凑成一双，我吃饭，你需要我给你凑成一双，你吃饭，这时候就会僵持不下，发生死锁，线程也是一样，A线程持有一个B的锁，B线程持有一个A的锁，二者谁也不肯释放锁，就会发生死锁。
- 死锁的现象我们应该积极避免，应该按照锁的hashcode进行排列，hashcode大的先锁，hashcode小的后锁，所有线程都按照这个规矩办事，就不会出现死锁问题了。

**源码：** thread/sync/DeadLockTest.java

## 2.5 DCL饱汉单例模式

- 饿汉单例本身就是线程安全的，饱汉单例本身就是线程不安全的。
- 我们可以使用DCL（Double Check Lock）模式来优化饱汉单例模式，使其变为线程安全的。
- 必须添加volatile来禁止指令重排否则有可能线程A将实例分配空间，赋属性a初始值0，然后直接astore关联栈变量，然后再赋值a真正的值10（重排），如果在astore指令之后，线程B插队，发现实例不为null，直接拿去用，调用属性a得到的是个0，然后线程A中才继续执行赋真正的值10，然后解锁，整个过程读到错误数据，是不安全的。

**源码：** thread/sync/DclSingletonTest.java

# 3. 原子类

**概念：** 
- 加锁是比较消耗性能的，我们可以使用java并发包中提供的原子类来更简单，更高效，且线程安全地操作一个共享数据变量。
- 原子类都在 `java.util.concurrent.atomic` 包下，都是利用CAS自旋完成的原子性。
- 对共享数据num进行10个线程并发自增100次，则：
    - 如果使用 `num++`，则最后一条输出结果一定小于1000，因为中途会因为线程争抢而丢失数据。
    - 如果使用 `num.incrementAndGet()`，则最后一条输出结果一定等于1000。

> num++不是原子性操作，在指令级层面，它至少经历了取出值，自增，重新赋值这三件指令。

**源码：** thread/sync/AtomicStart.java

## 3.1 基本类型原子类

**概念：** 想要线程安全地操作基本类型可以使用对应的原子类，AtomicBoolean/AtomicInteger/AtomicLong。
- **初始化：** 以`AtomicInteger`为例，它的构造器中需要放入一个int类型的初始值。
- **使用：**
    - `get()`：获取当前变量值。
    - `incrementAndGet()`：自增当前变量值元素并返回自增后结果。
    - `addAndGet(int delta)`：对当前变量值自增 `delta` 后返回计算结果。
    - `accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)`：自定义计算过程
        - p1：函数式接口中的初始right值。
        - p3：函数式接口，需要两个int型运算参数，返回一个int型结果。

**源码：** thread/sync/AtomicIntegerDemo.java

## 3.2 基本类型数组原子类

**概念：** 如果想要对基本类型的数组进行原子计算，则可以使用AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray：
- **初始化：** 以`AtomicIntegerArray`为例，它的构造器中需要放入一个int类型的数组。
- **使用：**
    - `get(int i)`：通过角标获取元素。
    - `incrementAndGet(int i)`：通过角标自增元素并返回自增后结果。
    - `addAndGet(int i, int delta)`：通过角标自增 `delta` 后返回计算结果。
    - `accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction)`：自定义计算过程
        - p1：数组角标。
        - p2：初始right值。
        - p3：函数式接口，需要两个int型运算参数，返回一个int型结果。
 
**源码：** thread/sync/AtomicIntegerArrayDemo.java

## 3.3 Double和Long的升级原子类

概念：DoubleAdder和LongAdder对Double和Long的原子更新性能进行优化提升，但是它们只有简单的自增，添加和自减方法。
- DoubleAdder和LongAdder底层使用了分段锁技术，在高并发情况下，效率会更高，比如假设有1000个线程，分成5段，则每段执行200个线程，最后将5段结果汇总并返回。

**源码：** thread/sync/LongAdderTest.java

## 3.4 引用类型原子类

**概念：** 
- 如果想对某个类中的属性进行原子操作，则可以使用引用类型原子类：
    - 属性为 `int`，使用AtomicIntegerFieldUpdater
    - 属性为 `long`，使用AtomicLongFieldUpdater
    - 属性为引用数据类型，如 `String`/`Integer`/`Long` 等，使用AtomicReferenceFieldUpdater
- 使用引用类型原子类注意事项：
    - 成员属性必须volatile修饰，表示该属性在线程之间立即可见。
    - 成员属性不能被static或final修饰。
- 如果很在乎CAS的ABA问题，可以替换如下两种：
    - AtomicMarkableReference：带版本戳的原子引用类型，版本戳为boolean类型。
    - AtomicStampedReference：带版本戳的原子引用类型，版本戳为int类型。

源码：thread/sync/AtomicLongFieldUpdaterDemo.java

> 操作字符串类型的name，更换使用AtomicReferenceFieldUpdater即可。

# 4. ThreadLocal的使用

**概念：** 线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。为每个线程单独存放一份变量副本，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。只要线程处于活动状态并且ThreadLocal实例可访问，那么每个线程都拥有对其本地线程副本的隐式引用变量一个线程消失后，它的所有副本线程局部实例受垃圾回收（除非其他存在对这些副本的引用）

一般用的比较多的是
1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。
2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。将某个值设置到当前线程的一个map容器中，其他线程你是获取不到的。
3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值，如果你的ThreadLocal使用完了，一定要记得remove掉，否则会产生内存泄露问题。
4、ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。