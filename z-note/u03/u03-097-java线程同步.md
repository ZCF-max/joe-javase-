# 1. 线程同步
 
**概念：** 当多线程并发访问时，程序有可能得不到正确的数据结果时，即为线程不安全。
- **同步与异步：** 比如你和赵四一起做同一套数学模拟题，异步就是你们将卷子复制一套，然后一人做半套题，最后拼成一份答案，同步就是你做几道，将卷子扔给赵四，赵四做几道再扔给你，循环交替，直到卷子做完。
    - 异步：互不干扰，资源利用率高，因为整个过程中没有人会长时间处于等待状态，但是不安全，因为有可能两个人题目刷重。
    - 同步：安全，不会刷重题目，但是效率相对而言会低一些，但有些时候，我们不得不牺牲一点效率因素，来提升安全因素。  - 
- **线程不安全原因：** 线程安全问题多由异步造成：
    - 比如赵四账户有1万元余额
    - 今天别人说好要给他转账5000元（线程A）
    - 他也要给别人转账2000元（线程B）
    - 线程A执行，10000 + 5000 = 15000 但是还未来得及更新账户余额，线程就进入了等待状态
    - 线程B执行，10000 - 2000 = 8000，但是还未来得及更新账户余额，线程就进入了等待状态
    - 线程A继续执行，更新账户余额为15000
    - 线程B继续执行，更新账户余额为8000
    - 最终，经过赵四一顿操作，余额最终为8000元

# 2. 售票系统案例

**源码：** TicketSellTest.java
```java
/**@author JoeZhou*/
public class TicketSellTest {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        t1.setName("江北售票点：");
        t2.setName("香坊售票点：");
        t1.start();
        t2.start();
    }
}

/**@author Joe*/
class Ticket implements Runnable {

    /** 票号 */
    private Integer ticketNo = 0;

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);
                sell();
            } catch (InterruptedException e) { 
                e.printStackTrace(); 
            }
        }
    }

    private void sell() {
        int max = 100;
        if(ticketNo < max){
           System.out.println(Thread.currentThread().getName() + "卖了第" + (++ticketNo) + "张票"); 
        }
    }
}
```

tips：发现因为线程之间互相争抢资源，所以会出现两个售票点重复卖票的情况。

# 3. synchronized

**概念：** 
- 关键字synchronized可以将代码进行同步，其本质是锁，加锁后，当线程A访问此代码时，获取这把锁，其他线程将无法访问这个线程，只有当线程A访问结束之后，释放锁，其他线程才能接着访问，synchronized有两种用法：
- 同步整个方法：在方法上添加 `synchronized` 修饰，对整个方法加锁。
    - `private synchronized void sell(){...}`
- 同步部分代码：使用 `synchronized(){}` 只对涉及到共享数据的部分代码加锁，小括号中是锁的类型。
    - `synchronized(this){...}`
    - `synchronized(){}` 中的锁类型不能使用String Integer和Long
    
**源码：** 
```java
private void sell(){
    synchronized(this){
        int max = 100;
        if(ticketNo < max){
            System.out.println(Thread.currentThread().getName() + "卖了第" + (++ticketNo) + "张票"); 
		}
    }
}
```

## 3.1 同步方法的锁类型

**概念：** 
- synchronized修饰普通方法时使用的是this锁，修饰静态方法时，使用的是类对象锁。
- 同步方法的原理其实就是锁，但只有多个线程使用的是同一种锁时才会发生同步现象。


```java
/**
* 测试同步方法的锁的类型，我们让线程A走同步代码块，让线程B走同步方法，如果仍旧发生同步现象，则代表同步方法中的锁和测试中同步代码块中的锁一致。
@author Joe*/
public class LockTypeTest {
    public static void main(String[] args) {
        LockTypeRunnable r = new LockTypeRunnable();
        Thread t1 = new Thread(r);
        Thread t2 = new Thread(r);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
}

/**@author Joe*/
class LockTypeRunnable implements Runnable {

    private Integer tickets = 0;

    @Override
    public void run() {
        String t1 = "t1";
        while (true) {
            try {
                Thread.sleep(1000);
                if (Thread.currentThread().getName().equals(t1)) {
                    // 同步方法
                    sell();
                } else {
                    // 同步代码块
                    synchronized (this) {
                        int max = 100;
                        if (tickets < max) {
                            System.out.println(Thread.currentThread().getName() + "卖了第" + (++tickets) + "张票");
                        }
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private synchronized void sell() {
        int max = 100;
        if (tickets < max) {
            System.out.println(Thread.currentThread().getName() + "卖了第" + (++tickets) + "张票");
        }
    }
}
```

## 3.2 静态方法的锁类型

## 3.3 可重入锁

syn时候可重入锁，m1()是同步的，m2()是同步的，在m1()中可以调用m2()，因为是同一个线程申请的这把锁，允许重入。

**源码：** sync/ReentryTest.java

## 3.4 异常释放锁

syn同步代码如果爆发了异常会释放锁，此时其他等待进入的线程则有可能获取到锁，进入到同步代码中。

**源码：** sync/ReentryTest.java


# 3. 死锁
 
**概念：** 
- 假设吃饭的时候，我有一根筷子，你有一根筷子，我需要你给我凑成一双，我吃饭，你需要我给你凑成一双，你吃饭，这时候就会僵持不下，发生死锁，线程也是一样，A线程持有一个B的锁，B线程持有一个A的锁，二者谁也不肯释放锁，就会发生死锁。
- 死锁的现象我们应该积极避免，应该按照锁的hashcode进行排列，hashcode大的先锁，hashcode小的后锁，所有线程都按照这个规矩办事，就不会出现死锁问题了。

**源码：**
```java
/**@author Joe*/
public class DeadLockTest {
	public static void main(String[] args) {
		DeadLockRunnable r = new DeadLockRunnable();
		new Thread(r).start();
		new Thread(r).start();
	}
}

class DeadLockRunnable implements Runnable {

	private final Object obj1 = new Object();
    private final Object obj2 = new Object();

	@Override
	public void run() {
        String t1 = "Thread-0";
		if (Thread.currentThread().getName().equals(t1)) {
			synchronized (obj1) {
				System.out.println("if -- obj1");
				synchronized (obj2) {
					System.out.println("if -- obj2");
				}
			}
		} else {
			synchronized (obj2) {
				System.out.println("else -- obj2");
				synchronized (obj1) {
					System.out.println("else -- obj1");
				}
			}
		}
	}
}
```