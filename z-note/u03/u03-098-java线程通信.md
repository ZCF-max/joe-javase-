# 1. 线程等待

案例：我有个资源，一个线程往这个资源里写入，另一个线程从这个资源中读出。

源码：ReadWriteTest


案例升级：上面的代码在运行过程中会出现数据错位，比如 "赵四 --- male" 或者 "zhaosi ---- 男" 的情况，如何使用同步解决这个问题。提示：让两个线程同步的前提是，两个线程可以获得相同的锁，res对象本身就是共享资源，直接拿res当锁，即可完成两个线程的同步。

读写案例 - 同步版本
在写的线程中，while循环下加synchronized (res) {}锁
while(true){
    synchronized (res) {
        // ...写的代码
    }
}


在读的线程中，while循环下加synchronized (res) {}锁
while(true){
    synchronized (res) {
        // ...读的代码
    }
}


案例再升级：将之前的读写案例，改为写一个，读一个，交替运行。

[方法提示]
wait() 让某个线程等待，此时该线程会加入到线程池进行等待
notify() 让某个线程被唤醒，只能唤醒一个，而且是在线程池中随机唤醒
notifyAll() 唤醒线程池中的所有等待线程
tips：这三个方法是Object类中的，不是Thread类中的，而且只能在同步的前提下中使用。

思路：

在资源类设置一个标志变量hasRes，标识当前是否有数据，默认为false
[写线程] 中，写之前判断当前是否有数据
如果有数据，[写线程] 等待：res.wait()
如果没数据
写数据
把hasRes改成true
唤醒 [读线程]：res.notifiy()
[读线程] 中，读之前判断当前是否有数据
如果有数据
读数据
把hasRes改成false
唤醒 [写线程]：res.notifiy()
如果没数据，[读线程] 等待：res.wait()

代码：资源类添加hasRes属性和set/get方法
class Res{
    //... 其余代码略
    private boolean hasRes = false;
    
    public boolean isHasRes() { return hasRes; }
    public void setHasRes(boolean hasRes) { this.hasRes = hasRes; }
}


代码：在写线程的同步代码块中添加如下代码：
while(true){
    synchronized (res) {
        
        // 当前有数据，写的线程等待
        // 当前无数据，写数据、改变标志位、唤醒读的线程
        if(res.isHasRes()){
            res.wait();
        }else{
            // todo ...写数据的代码，略
            res.setHasRes(true);
            res.notify();
        }
    }
}


代码：在读线程的同步代码块中添加如下代码：
while(true){
    synchronized (res) {
        
        // 当前有数据，读数据、改变标志位、唤醒写的线程
        // 当前无数据，读的线程等待
        if(res.isHasRes()){
            // todo ...读数据的代码，略
            res.setHasRes(false);
            res.notify();
        }else{
            res.wait();
        }
    }
}


tips：sleep()和wait()的区别

sleep()可以理解为，你上厕所上到一半，在厕所里睡着了，这时候别人想上厕所也进不来，必须等你睡醒出来或者强行叫醒你[interreput()]。
wait()可以理解为，你刚进厕所突然发现忘了带纸，只能先出去拿纸，等一会儿再来上厕所，这个时候别人可以插队进来。

区别1：这两个方法来自不同的类分别是Thread和Object。sleep是Thread的静态方法，需要当前线程来控制，而wait是作用在某个对象。
区别2：sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
区别3：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。
- Notify不释放锁


# 2. 停止线程

想停止一个线程，只能等待run方法结束（stop()方法已经过时，容易产生线程状态的不一致），开启线程就一定跟循环相关，所以我们用更改变标志位的方法就可以结束循环，就可以结束run，而如果要被停止的线程处于挂起状态，则需要强行使用interrupt()方法来获取一个异常，然后在异常处理中决定是否要终止线程，但是并不建议使用interrupt()来控制业务逻辑。

 	下面我们在主线程中停止子线程。
package com.joe.thread;

/**@author JoeZhou*/
public class KillThreadTest {
    public static void main(String[] args) throws InterruptedException {
        KillThreadRunner r = new KillThreadRunner();
        Thread t1 = new Thread(r);
        t1.start();
        Thread.sleep(1000);
        System.out.println("主线程改变子线程flag...");
        r.setFlag(true);
    }
}

/**@author Joe*/
class KillThreadRunner implements Runnable {
    private boolean flag = false;

    @Override
    public synchronized void run() {
        while (!flag) {
            System.out.println("子线程运行...");
        }
        System.out.println("子线程结束...");
    }

    public boolean isFlag() {return flag;}
    public void setFlag(boolean flag) {this.flag = flag;}
}


问题：当线程体wait或者sleep时，处于挂起状态，这时候的线程仍然存活，但是标志位的方法已经不能用了。
解决：使用interrupt方法清除挂起状态(会抛异常，可以在异常处理中更改标识符结束循环)。

步骤1：线程体中添加synchronized并改写如下代码：
@Override
public synchronized void run() {
    while (!flag) {
        try {
            // wait()必须在同步方法中才能使用
            wait();
        } catch (InterruptedException e) {
            // 爆发异常后，改变标志位，否则子程序还是不结束
            flag = true;
            e.printStackTrace();
        }
        System.out.println("子线程运行...");
    }
    System.out.println("子线程结束...");
}


步骤2：将上面案例中的r.setFlag(true);变成t1.interrupt();
// r.setFlag(true);// 改变子线程循环标志位true
t1.interrupt();// 清除子线程挂起状态，并打断

# LockSupport

LockSupport是并发包中提供的更灵活的控制线程等待和唤醒的工具类。

unpack-pack 比 wait-notify 更灵活，unpack可以具体指定唤醒哪个线程
notify只能随机唤醒

unpack()如果在pack()之前被调用，则pack()会失效

**源码：** communication/LockSupportTest.java

# CountDownLatch

await(),进入等待的状态
countDown(),计数器减一
应用场景：启动三个线程计算，需要对结果进行累加。

**源码：** communication/CountDownLatch.java

# CyclicBarrier

		允许一组线程相互等待达到一个公共的障碍点，之后再继续执行
		
		跟countDownLatch的区别
			CountDownLatch一般用于某个线程等待若干个其他线程执行完任务之后，它才执行；不可重复使用
			CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；可重用的

**源码：** communication/CountDownLatch.java

# Exchanger

	Exchanger
		用于交换数据

		它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger的重点是成对的线程使用exchange()方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是【成对】的。

**源码：** communication/ExchangerDemo.java

# Semaphore

	Semaphore--信号量
		控制并发数量
		使用场景：接口限流

**源码：** communication/SemaphoreDemo.java