# 1. 线程等待

案例：我有个资源，一个线程往这个资源里写入，另一个线程从这个资源中读出。

读写案例 - 未同步版本
package com.joe.thread;
/**@author Joe*/
public class ReadWriteTest {
	public static void main(String[] args) {

        // 共享资源，写在这里是为了让两个线程共享同一个res
		Res res = new Res();
        
        // 在创建Input线程类的时候将共享资源传入
		WriteRes write = new WriteRes(res);
  
        // 在创建Output线程类的时候将共享资源传入
		ReadRes read = new ReadRes(res);
		new Thread(write).start();
		new Thread(read).start();
	}
}

/**@author Joe*/
class WriteRes implements Runnable {
    
    /** 共享资源 */
	private Res res;
 
    /** 中英文切换写入标志，false时写中文，true时写英文 */
	private boolean flag = false;

    /** 通过构造方法获取共享资源res，并传递给当前类属性res */
	public WriteRes(Res res) {
		this.res = res;
	}

	@Override
	public void run() {
        // 无限写
		while (true) {
			if (flag) {
				res.setName("zhaosi");
				res.setGender("male");
				flag = false;
			} else {
				res.setName("赵四");
				res.setGender("男");
				flag = true;
			}
		}
	}
}

/**@author Joe*/
class ReadRes implements Runnable {
    
    /** 共享资源 */
	private Res res;

    /** 通过构造方法获取共享资源res，并传递给当前类属性res */
	public ReadRes(Res res) {
		this.res = res;
	}

	@Override
	public void run() {
        // 无限读
		while (true) {
			System.out.print(res.getName());
			System.out.print(" ---- ");
			System.out.println(res.getGender());
		}
	}
}

/**@author Joe*/
class Res {
	private String name;
	private String gender;
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public String getGender() {return gender;}
	public void setGender(String gender) {this.gender = gender;}
}


案例升级：上面的代码在运行过程中会出现数据错位，比如 "赵四 --- male" 或者 "zhaosi ---- 男" 的情况，如何使用同步解决这个问题。提示：让两个线程同步的前提是，两个线程可以获得相同的锁，res对象本身就是共享资源，直接拿res当锁，即可完成两个线程的同步。

读写案例 - 同步版本
在写的线程中，while循环下加synchronized (res) {}锁
while(true){
    synchronized (res) {
        // ...写的代码
    }
}


在读的线程中，while循环下加synchronized (res) {}锁
while(true){
    synchronized (res) {
        // ...读的代码
    }
}


案例再升级：将之前的读写案例，改为写一个，读一个，交替运行。

[方法提示]
wait() 让某个线程等待，此时该线程会加入到线程池进行等待
notify() 让某个线程被唤醒，只能唤醒一个，而且是在线程池中随机唤醒
notifyAll() 唤醒线程池中的所有等待线程
tips：这三个方法是Object类中的，不是Thread类中的，而且只能在同步的前提下中使用。

思路：

在资源类设置一个标志变量hasRes，标识当前是否有数据，默认为false
[写线程] 中，写之前判断当前是否有数据
如果有数据，[写线程] 等待：res.wait()
如果没数据
写数据
把hasRes改成true
唤醒 [读线程]：res.notifiy()
[读线程] 中，读之前判断当前是否有数据
如果有数据
读数据
把hasRes改成false
唤醒 [写线程]：res.notifiy()
如果没数据，[读线程] 等待：res.wait()

代码：资源类添加hasRes属性和set/get方法
class Res{
    //... 其余代码略
    private boolean hasRes = false;
    
    public boolean isHasRes() { return hasRes; }
    public void setHasRes(boolean hasRes) { this.hasRes = hasRes; }
}


代码：在写线程的同步代码块中添加如下代码：
while(true){
    synchronized (res) {
        
        // 当前有数据，写的线程等待
        // 当前无数据，写数据、改变标志位、唤醒读的线程
        if(res.isHasRes()){
            res.wait();
        }else{
            // todo ...写数据的代码，略
            res.setHasRes(true);
            res.notify();
        }
    }
}


代码：在读线程的同步代码块中添加如下代码：
while(true){
    synchronized (res) {
        
        // 当前有数据，读数据、改变标志位、唤醒写的线程
        // 当前无数据，读的线程等待
        if(res.isHasRes()){
            // todo ...读数据的代码，略
            res.setHasRes(false);
            res.notify();
        }else{
            res.wait();
        }
    }
}


tips：sleep()和wait()的区别

sleep()可以理解为，你上厕所上到一半，在厕所里睡着了，这时候别人想上厕所也进不来，必须等你睡醒出来或者强行叫醒你[interreput()]。
wait()可以理解为，你刚进厕所突然发现忘了带纸，只能先出去拿纸，等一会儿再来上厕所，这个时候别人可以插队进来。

区别1：这两个方法来自不同的类分别是Thread和Object。sleep是Thread的静态方法，需要当前线程来控制，而wait是作用在某个对象。
区别2：sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
区别3：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。
- Notify不释放锁


5. 停止线程

想停止一个线程，只能等待run方法结束（stop()方法已经过时，容易产生线程状态的不一致），开启线程就一定跟循环相关，所以我们用更改变标志位的方法就可以结束循环，就可以结束run，而如果要被停止的线程处于挂起状态，则需要强行使用interrupt()方法来获取一个异常，然后在异常处理中决定是否要终止线程，但是并不建议使用interrupt()来控制业务逻辑。

 	下面我们在主线程中停止子线程。
package com.joe.thread;

/**@author Joe*/
public class KillThreadTest {
    public static void main(String[] args) throws InterruptedException {
        KillThreadRunner r = new KillThreadRunner();
        Thread t1 = new Thread(r);
        t1.start();
        Thread.sleep(1000);
        System.out.println("主线程改变子线程flag...");
        r.setFlag(true);
    }
}

/**@author Joe*/
class KillThreadRunner implements Runnable {
    private boolean flag = false;

    @Override
    public synchronized void run() {
        while (!flag) {
            System.out.println("子线程运行...");
        }
        System.out.println("子线程结束...");
    }

    public boolean isFlag() {return flag;}
    public void setFlag(boolean flag) {this.flag = flag;}
}


问题：当线程体wait或者sleep时，处于挂起状态，这时候的线程仍然存活，但是标志位的方法已经不能用了。
解决：使用interrupt方法清除挂起状态(会抛异常，可以在异常处理中更改标识符结束循环)。

步骤1：线程体中添加synchronized并改写如下代码：
@Override
public synchronized void run() {
    while (!flag) {
        try {
            // wait()必须在同步方法中才能使用
            wait();
        } catch (InterruptedException e) {
            // 爆发异常后，改变标志位，否则子程序还是不结束
            flag = true;
            e.printStackTrace();
        }
        System.out.println("子线程运行...");
    }
    System.out.println("子线程结束...");
}


步骤2：将上面案例中的r.setFlag(true);变成t1.interrupt();
// r.setFlag(true);// 改变子线程循环标志位true
t1.interrupt();// 清除子线程挂起状态，并打断
