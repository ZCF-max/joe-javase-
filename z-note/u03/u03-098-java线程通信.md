# 1. 线程等待

案例：我有个资源，一个线程往这个资源里写入，另一个线程从这个资源中读出。

读写案例 - 未同步版本
package com.joe.thread;
/**@author Joe*/
public class ReadWriteTest {
	public static void main(String[] args) {

        // 共享资源，写在这里是为了让两个线程共享同一个res
		Res res = new Res();
        
        // 在创建Input线程类的时候将共享资源传入
		WriteRes write = new WriteRes(res);
  
        // 在创建Output线程类的时候将共享资源传入
		ReadRes read = new ReadRes(res);
		new Thread(write).start();
		new Thread(read).start();
	}
}

/**@author Joe*/
class WriteRes implements Runnable {
    
    /** 共享资源 */
	private Res res;
 
    /** 中英文切换写入标志，false时写中文，true时写英文 */
	private boolean flag = false;

    /** 通过构造方法获取共享资源res，并传递给当前类属性res */
	public WriteRes(Res res) {
		this.res = res;
	}

	@Override
	public void run() {
        // 无限写
		while (true) {
			if (flag) {
				res.setName("zhaosi");
				res.setGender("male");
				flag = false;
			} else {
				res.setName("赵四");
				res.setGender("男");
				flag = true;
			}
		}
	}
}

/**@author Joe*/
class ReadRes implements Runnable {
    
    /** 共享资源 */
	private Res res;

    /** 通过构造方法获取共享资源res，并传递给当前类属性res */
	public ReadRes(Res res) {
		this.res = res;
	}

	@Override
	public void run() {
        // 无限读
		while (true) {
			System.out.print(res.getName());
			System.out.print(" ---- ");
			System.out.println(res.getGender());
		}
	}
}

/**@author Joe*/
class Res {
	private String name;
	private String gender;
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public String getGender() {return gender;}
	public void setGender(String gender) {this.gender = gender;}
}


案例升级：上面的代码在运行过程中会出现数据错位，比如 "赵四 --- male" 或者 "zhaosi ---- 男" 的情况，如何使用同步解决这个问题。提示：让两个线程同步的前提是，两个线程可以获得相同的锁，res对象本身就是共享资源，直接拿res当锁，即可完成两个线程的同步。

读写案例 - 同步版本
在写的线程中，while循环下加synchronized (res) {}锁
while(true){
    synchronized (res) {
        // ...写的代码
    }
}


在读的线程中，while循环下加synchronized (res) {}锁
while(true){
    synchronized (res) {
        // ...读的代码
    }
}


案例再升级：将之前的读写案例，改为写一个，读一个，交替运行。

[方法提示]
wait() 让某个线程等待，此时该线程会加入到线程池进行等待
notify() 让某个线程被唤醒，只能唤醒一个，而且是在线程池中随机唤醒
notifyAll() 唤醒线程池中的所有等待线程
tips：这三个方法是Object类中的，不是Thread类中的，而且只能在同步的前提下中使用。

思路：

在资源类设置一个标志变量hasRes，标识当前是否有数据，默认为false
[写线程] 中，写之前判断当前是否有数据
如果有数据，[写线程] 等待：res.wait()
如果没数据
写数据
把hasRes改成true
唤醒 [读线程]：res.notifiy()
[读线程] 中，读之前判断当前是否有数据
如果有数据
读数据
把hasRes改成false
唤醒 [写线程]：res.notifiy()
如果没数据，[读线程] 等待：res.wait()

代码：资源类添加hasRes属性和set/get方法
class Res{
    //... 其余代码略
    private boolean hasRes = false;
    
    public boolean isHasRes() { return hasRes; }
    public void setHasRes(boolean hasRes) { this.hasRes = hasRes; }
}


代码：在写线程的同步代码块中添加如下代码：
while(true){
    synchronized (res) {
        
        // 当前有数据，写的线程等待
        // 当前无数据，写数据、改变标志位、唤醒读的线程
        if(res.isHasRes()){
            res.wait();
        }else{
            // todo ...写数据的代码，略
            res.setHasRes(true);
            res.notify();
        }
    }
}


代码：在读线程的同步代码块中添加如下代码：
while(true){
    synchronized (res) {
        
        // 当前有数据，读数据、改变标志位、唤醒写的线程
        // 当前无数据，读的线程等待
        if(res.isHasRes()){
            // todo ...读数据的代码，略
            res.setHasRes(false);
            res.notify();
        }else{
            res.wait();
        }
    }
}


tips：sleep()和wait()的区别

sleep()可以理解为，你上厕所上到一半，在厕所里睡着了，这时候别人想上厕所也进不来，必须等你睡醒出来或者强行叫醒你[interreput()]。
wait()可以理解为，你刚进厕所突然发现忘了带纸，只能先出去拿纸，等一会儿再来上厕所，这个时候别人可以插队进来。

区别1：这两个方法来自不同的类分别是Thread和Object。sleep是Thread的静态方法，需要当前线程来控制，而wait是作用在某个对象。
区别2：sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
区别3：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。
- Notify不释放锁
