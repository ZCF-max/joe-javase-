# 1. Collection容器

**概念：** `java.util.Collection` 继承自 `java.lang.Iterable`，表示java的容器类，方便我们更灵活地组织和操纵数据，它有三个常用的子接口：`List`，`Queue` 和 `Set`。

# 2. List接口

**概念：** List是有序的一种容器，也称为序列，此接口的用户可以对列表中每个元素的插入位置进行精确地控制，用户可以根据元素的整数索引（在列表中的位置）来访问元素，并搜索列表中的元素。
- List接口在 `iterator()`、`add()`、`remove()`、`equals()` 和 `hashCode()` 方法的协定上加了一些其他约定，超过了 `Collection` 接口中指定的约定。

## 2.1 ArrayList实现类

**概念：**  ArrayList是List接口的大小可变数组的实现，是有顺序的，允许重复的元素和null值，初始默认容量为10的，底层是数组结构。
- 构造：
    - `ArrayList()`：构造一个初始容量为10的ArrayList。
    - `ArrayList(int initialCapacity)`：构造一个指定初始容量的ArrayList。
- 方法：
    - `boolean add(E e)`：将e追加到列表末尾。
    - `void add(int index, E e);`：将e插入到列表的index位置上。
    - `boolean addAll(Collection<? extends E> c)`：将集合c整体追加到列表末尾。
    - `boolean addAll(int index, Collection<? extends E> c)`：将集合c整体插入到列表的index位置上。
    - `E get(int index)`：获取index位置上的元素。
    - `int indexOf(Object o)`：返回o在列表中第一次出现的位置。
    - `int lastIndexOf(Object o)`：返回o在列表中最后一次出现的位置。
    - `boolean equals(Object o)`：判断两个列表内容是否相同。
    - `boolean contains(Object o)`：判断列表中是否包含o。
    - `boolean containsAll(Collection<?> c)`：判断列表中是否包含c集合的内容。
    - `boolean isEmpty()`：判断列表是否为空。
    - `int size()`：返回列表长度。
    - `Object[] toArray()`：将列表转换为Object数组格式。
    - `E set(int index, E e)`：将index位置上的元素替换成e。
    - `List<E> subList(int a, int b)`：在原列表中从位置a截取到位置b，包括a不包括b。
    - `E remove(int index)`：移除原列表中index位置上的元素。
    - `boolean remove(Object o)`：移除原列表中的o元素。
    - `boolean removeAll(Collection<?> c)`：移除原列表中和集合c相同的元素。
    - `boolean retainAll(Collection<?> c)`：仅保留原列表中和集合c相同的元素。
    - `void clear()`：清空列表中所有元素。
- 遍历：除了使用for或foreach循环外，我们更建议使用迭代器来遍历列表：    
    - `ArrayList` 可以通过 `listIterator(int pos)` 获得列表的迭代器对象，默认指针在0号位置之前的位置。
    - 迭代器可以通过 `hasNext()` 和 `next()` 来配合完成迭代效果。
    - 迭代器可以通过 `hasPrevious()` 和 `previous()` 来配合完成反向迭代效果。
    - 迭代器支持使用 `set(E e)` 来完成当前位置的内容替换，该操作会向后移动指针。
    - 迭代器支持使用 `remove()` 来完成当前位置的内容删除，该操作会向后移动指针。
    - `ListIterator` 是 `Iterator` 接口的子类，只能遍历list，用法和 `Iterator` 一致。

**源码：** collection/ArrayListTest.java


## 2.2 Iterator迭代器遍历

接口Iterator本身井非数据结构，但它定义了一种连续地检索数据结构中的元素的方式，是以定义好的顺序遍历一系列元素的标谁方式。迭代器通常被称为“轻量级”对象，因为创建它的代价小。

了解Iterator接口的工作原理将有助于理解其他Java数据结构，它拥有两个比较常用的方法hashNext()和next()。

public boolean hasNext();// 判断结构中是否还包含其他元素，调用该方法来查看是否可以继续遍历结构。
public Object next();// 获得结构中的下一个元素。


tips：如果在调用next()时，结构中已经没有更多的元素，那么next()将引发noSuchElementException异常，为避免产生这种异常，应结合使用hasNext()和next()来确保还有元素可检索。

hasNext()和next()结合遍历List
@Test
public void testIterator() {
	// 准备一个list类型的数据结构
	ArrayList arrayList = new ArrayList();
	arrayList.add("日本");
	arrayList.add("中国");
	arrayList.add("印度");

	Iterator iter = arrayList.iterator();// 将数据结构转换为迭代器对象，初始指针在0号位置，未指向任何元素
	iter.next();// 指针后移一次，指向（1）号元素"日本"
	iter.remove();// 根据指针当前所在位置（1），删除元素"日本"

	while (iter.hasNext()) {// 遍历迭代器中余下的元素
		System.out.println(iter.next());// next()方法返回的是Object
	}
}


迭代器总结：

Java中的Iterator只能单向移动。
"数据结构.iterator()" 方法可以将某个数据结构转换为迭代器对象。
第一次调用Iterator对象的next()方法时，它返回序列的第一个元素。
使用next()获得数据结构中的下一个元素。
使用hasNext()检查数据结构中是否还有元素。
使用remove()将迭代器新返回的元素删除。

## 2.3 LinkedList

LinkedList是List接口的链接列表实现，实现了所有可选的列表操作，并且允许所有元素（包括 null），此实现不是同步的。

[常用方法集合]
方法名 功能 备注
push() 头部添加 返回void 等效于addFirst() 1.6
add()addFirst()addLast() 追加头部添加尾部添加 返回boolean 等效于addLast()返回void返回void
offer()offerFirst()offerLast() 追加头部添加尾部添加 返回boolean 1.5返回boolean 1.6返回boolean 1.6
element() 查看头 返回头 空列表抛异常 1.5
get(0)getFirst()getLast() 查看0号元素查看头查看尾 返回指定元素 空列表抛异常返回头 空列表抛异常返回头 空列表抛异常
peek()peekFirst()peekLast() 查看头查看头查看尾 返回头 空列表返回null 1.5返回头 空列表返回null 1.6返回头 空列表返回null 1.6
poll()pollFirst()pollLast() 取走头取走头取走尾 返回头 空列表返回null 1.5返回头 空列表返回null 1.6返回尾 空列表返回null 1.6
set(a,b) a号位置内容修改为b 
pop()remove())remove(0))remove(a))removeFirst()removeLast()removeFirstOccurrence(a)removeLastOccurrence(a) 取走头取走头取走0号元素删除元素a取走头取走尾删除第一次出现的元素a删除最后一次出现的元素a 返回头 空列表抛异常 1.6返回头 空列表抛异常 1.5返回指定元素返回boolean类型返回头 空列表抛异常返回尾 空列表抛异常返回布尔类型返回布尔类型

LinkedList特殊方法测试代码：这里主要使用LinkedList独有的方法，父接口List中的方法同上。
@Test
public void LinkedListTest() {
	LinkedList<String> list = new LinkedList<>();

	// create
	list.add("中国");
	list.add("美国");
	list.add("英国");
	list.add("意大利");
	list.addFirst("德国");// 将元素添加到开头 返回值void
	list.addLast("日本");// 将元素添加到结尾 返回值void
	list.offer("奥地利");// 将元素添加到结尾 返回值是boolean 1.5
	list.offerLast("俄罗斯");// 将元素添加到结尾 返回值是boolean 1.6
	list.offerFirst("乌克兰");// 将元素添加到开头 返回值是boolean 1.6
	list.push("匈牙利");// 等效于addFirst(E)

	// retrieve
	System.out.println(list.get(0));// 获取0号元素
	System.out.println(list.element());// 获取头，不移除头，1.5，空列表抛异常
	System.out.println(list.getFirst());// 返回头 空列表抛异常
	System.out.println(list.getLast());// 返回尾 空列表抛异常
	System.out.println(list.peek());// 获取头，不移除头，1.5，空列表返回null
	System.out.println(list.peekFirst());// 获取头，不移除头，1.6，空列表返回null
	System.out.println(list.peekLast());// 获取尾，不移除尾，1.6，空列表返回null
	System.out.println(list.poll());// 获取头，移除头，1.5，空列表返回null
	System.out.println(list.pollFirst());// 获取头，移除头，1.6，空列表返回null
	System.out.println(list.pollLast());// 获取尾，移除尾，1.6，空列表返回null

	// update
	System.out.println(list.set(1, "法国"));// 修改指定位置的元素，返回原元素

	// delete
	System.out.println(list.pop());// 获取并删除头，等效于removeFirst()，1.6
	System.out.println(list.remove());// 删除头，1.5，返回被删除的元素
	System.out.println(list.remove(0));// 根据角标删除，返回被删除的元素
	System.out.println(list.remove("意大利"));// 根据元素删除，返回boolean类型
	System.out.println(list.removeFirst());// 删除头，返回被删除的元素
	System.out.println(list.removeLast());// 删除尾，返回被删除的元素
	System.out.println(list.removeFirstOccurrence("日本"));// 删除第一次出现的元素，返回布尔类型
	System.out.println(list.removeLastOccurrence("中国"));// 删除最后一次出现的元素，返回布尔类型
}


LinkedList和ArrayList效率比较
ArrayList<Integer> arr1 = new ArrayList<>();

long start1 = System.currentTimeMillis();
for (int i = 0; i < 100000; i++) {
    arr1.add(0, i);
}
long end1 = System.currentTimeMillis();

long start2 = System.currentTimeMillis();
LinkedList<Integer> arr2 = new LinkedList<>();
for (int i = 0; i < 100000; i++) {
    arr2.add(0, i);
}
long end2 = System.currentTimeMillis();

System.out.println("ArrayList用时：" + (end1 - start1));
System.out.println("LinkedList用时：" + (end2 - start2));	


tips：LinkedList的存储机制决定了它比ArrayList更适合大量数据的中间连续插入工作。
tips：链表适合大量的中间插入操作，数组适合大量的中间查询操作。

# 3. Set

Set接口和List接口都是Collection的子接口。Set叫做集合 ，List叫做列表。所以它们有大量重复的方法（Collection接口中方法都有），同属于容器类，即支持泛型而且随便装，另外Set不支持重复数据，并且最多包含一个null元素，且set是无序的(注入和输出不同)，且Set不同步。

## 3.1 HashSet

HashSet底层满足Hash分布，无序不同步，是最常用的一种Set实现类。

```java
@Test
public void test() {
	// 1. hashSet允许null值
	// 2. hashSet不允许重复值（自动去重）
	// 3. hashSet无序（进去的时候跟出来的时候不一样），遵循他自己的顺序（hash分布）
	Set<String> set = new HashSet<>();
    System.out.println(set.hashCode());// 集合.hashCode()返回的是集合中所有元素的hashCode()之和，初始时候没有元素，所以这里打印0
	set.add("赵四");
    System.out.println(set.hashCode());// 集合中存在赵四，所有元素hashCode()之和为1144838
	set.add("赵四");
    System.out.println(set.hashCode());// hashCode()之和仍为1144838，说明set对于重复元素直接忽略
	set.add("刘能");
	set.add("广坤");
	set.add(null);
	for(String e : set) {
		System.out.println(e);
	}
}
```

**练习：** 03003-3

## 3.2 TreeSet

## 3.3 EnumSet

**概念：** java.util.EnumSet能通过静态方法 `allOf(Week.class)` 将 `Week` 中的所有枚举常量放到 `EnumSet` 中。

**源码：**
```java
EnumSet<Week> weekSet = EnumSet.allOf(Week.class);
for (Week day : weekSet) {
    System.out.print(day.toString() + "\t");
}
```

# 4. Map

```java
Map
    |__ HashMap
    |__ HashTable
    |__ TreeMap
```


将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射到一个值。

## 4.1 HashMap

HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 

HashMap常用API方法
@Test
public void test() {
	Map<String, Object> map = new HashMap<>();

	// create
	map.put("gongzuo", "");
	map.put("gongzuo", "singer");// 相同的key会覆盖，就相当于修改操作
	map.put("job", "singer");// 相同的value无所谓
	map.put("t", null);// HashMap的value允许null
	map.put(null, "k");// HashMap的key允许key
	map.put(null, null);// 相同的null的也会发生覆盖
	Map<String, Object> map2 = new HashMap<String, Object>();
	map2.put("a", 1);
	map2.put("b", 2);
	map.putAll(map2);// putAll代表将另一个Map整合到自己的Map中

	System.out.println(map);// map可以直接打印
	System.out.println(map.get("gongzuo"));// 通过key查询value
	System.out.println(map.containsKey("gongzuo"));// 查询map中是否有指定的key
	System.out.println(map.containsValue("singer"));// 查询map中是否有指定的value
	System.out.println(map.isEmpty());// 查询map是否为空map
	System.out.println(map.size());// 查询map中的键值对个数
	System.out.println(map.values());// 查询map中的所有value的collection集合
	System.out.println(map.keySet());// 查询map中的所有key的set集合

	// 获取map的entrySet形式后遍历map
	Set<Entry<String, Object>> set = map.entrySet();
	for (Entry<String, Object> e : set) {
		System.out.println(e.getKey() + ":" + e.getValue());
	}

	// delete
	map.remove("job");// 根据key删除同key的所有键值对
	map.remove(null);// 如果想删除null，不能加双引号
	map.clear();// 清空所有map中的键值对
}

练习 03003-4 

## 4.2 TreeMap

## 4.3 EnumMap

**概念：** `java.util.EnumMap` 可以将枚举常量作为 `KEY`，将一个字符串作为 `VALUE`。

**源码：**
```java
EnumMap<Week, String> map = new EnumMap<>(Week.class);
map.put(Week.MON, "星期一");
map.put(Week.TUE, "星期二");
map.put(Week.WED, "星期三");
map.put(Week.THU, "星期四");
map.put(Week.FRI, "星期五");
map.put(Week.SAT, "星期六");
map.put(Week.SUN, "星期日");
    
Set<Map.Entry<Week,String>> set = map.entrySet();
for (Map.Entry<Week,String> e : set){
    System.out.println(e.getKey() + " : " + e.getValue());
}    
```


# 2. Stack容器

**概念：** `java.util.Stack` 类继承自 `Vector` 类，是栈结构的工具类，提供了许多栈结构的API方法：
- `E push(E item)`：将元素推送到此栈结构的栈顶，并返回此元素。
- `E pop()`：移除并返回栈顶元素，对空栈进行此操作，会抛 `EmptyStackException` 异常。
- `E peek()`：返回栈顶元素（不移除），对空栈进行此操作，会抛 `EmptyStackException` 异常。
- `boolean empty()`：测试此栈是否为空。
- `int search(Object o)`：返回o距离栈顶(1)的位置，-1表示o不存在。

**源码：** generic/StackTest.java

# 3. Queue容器
        
**概念：** `java.util.Queue` 接口继承自 `Collection` 接口，是队列结构的工具接口，提供了许多队列结构的API方法：
- `boolean add(E e)`：将指定的元素加入到对列中，如果添加成功返回true。
- `boolean offer(E e)`：将指定的元素加入到对列中，如果添加成功返回true
    - 当队列有容量限制的时候，此方法通常优于 `add()`。
- `E remove()`：移除并返回队列头元素，对空队进行此操作，会抛 `NoSuchElementException` 异常。
- `E poll()`：移除并返回队列头元素，对空队进行此操作，会返回null。
- `E element()`：返回队列头元素（不移除），对空队列进行此操作，会抛 `NoSuchElementException` 异常。
- `E peek()`：返回队列头元素（不移除），对空队列进行此操作，会返回null。

> 队列通常是以FIFO的方式操作元素的，但是优先级队列或LIFO队列等特殊队列例外。

**源码：** generic/QueueTest.java