# 1. Collection容器

**概念：** `java.util.Collection` 继承自 `java.lang.Iterable`，表示java的容器类，方便我们更灵活地组织和操纵数据，它有三个常用的子接口：`List`，`Queue` 和 `Set`。

# 2. List接口

**概念：** List接口是相对有序（输入和输出相同）的一种容器，也称为序列，此接口的用户可以对列表中每个元素的插入位置进行精确地控制，用户可以根据元素的整数索引（在列表中的位置）来访问元素，并搜索列表中的元素。

## 2.1 ArrayList实现类

**概念：**  ArrayList是List接口的大小可变数组的实现，是有顺序的，实现了List中所有允许的API方法，允许重复的元素和null值，初始默认容量为10的，底层是数组结构。
- 构造：
    - `ArrayList()`：构造一个初始容量为10的ArrayList。
    - `ArrayList(int initialCapacity)`：构造一个指定初始容量的ArrayList。
- 方法：
    - `boolean add(E e)`：将e追加到列表末尾。
    - `void add(int index, E e);`：将e插入到列表的index位置上。
    - `boolean addAll(Collection<? extends E> c)`：将集合c整体追加到列表末尾。
    - `boolean addAll(int index, Collection<? extends E> c)`：将集合c整体插入到列表的index位置上。
    - `E get(int index)`：获取index位置上的元素。
    - `int indexOf(Object o)`：返回o在列表中第一次出现的位置。
    - `int lastIndexOf(Object o)`：返回o在列表中最后一次出现的位置。
    - `boolean equals(Object o)`：判断两个列表内容是否相同。
    - `boolean contains(Object o)`：判断列表中是否包含o。
    - `boolean containsAll(Collection<?> c)`：判断列表中是否包含c集合的内容。
    - `boolean isEmpty()`：判断列表是否为空。
    - `int size()`：返回列表长度。
    - `Object[] toArray()`：将列表转换为Object数组格式。
    - `E set(int index, E e)`：将index位置上的元素替换成e。
    - `List<E> subList(int a, int b)`：在原列表中从位置a截取到位置b，包括a不包括b。
    - `E remove(int index)`：移除原列表中index位置上的元素。
    - `boolean remove(Object o)`：移除原列表中的o元素。
    - `boolean removeAll(Collection<?> c)`：移除原列表中和集合c相同的元素。
    - `boolean retainAll(Collection<?> c)`：仅保留原列表中和集合c相同的元素。
    - `void clear()`：清空列表中所有元素。
- 遍历：可以使用for或者for-each进行遍历。

**源码：** collection/ArrayListTest.java

## 2.2 LinkedList实现类

**概念：** LinkedList是List接口的链表的实现，实现了List中所有允许的API方法，允许重复的元素和null值，底层是链表结构。
- 构造：`LinkedList()`：构造一个初始链表。
- 方法：这里主要使用LinkedList专属的方法，父接口List中的方法同ArrayList。
    - `void addFirst(E e)`：将e添加到链表开头。
    - `void push(E e)`：将e添加到链表开头，底层调用的 `addFirst()`。
    - `boolean offerFirst(E e)`：将e添加到链表开头，底层调用的 `addFirst()`。
    - `void addLast(E e)`：将e添加到链表结尾。
    - `boolean offer(E e)`：将e添加到链表结尾，底层调用的 `add()`。
    - `boolean offerLast(E e)`：将e添加到链表结尾，底层调用的 `addLast()`。
    - `E get(int index)`：获取index位置上的元素。
    - `E getFirst()`：查看链表头，空列表抛异常。
    - `E element()`：查看链表头，底层调用的 `getFirst()`。
    - `E peek()`：查看链表头，空列表返回null，1.5版本。
    - `E peekFirst()`：查看链表头，空列表返回null，1.6版本。
    - `E getLast()`：查看链表尾，空列表抛异常。
    - `E peekLast()`：查看链表尾，空列表返回null，1.6版本。  
    - `E set(int index, E e)`：将index位置上的元素替换成e。
    - `E poll()`：移除头并返回头，空列表返回null，1.5版本。
    - `E pollFirst()`：移除头并返回头，空列表返回null，1.6版本。
    - `E removeFirst()`：移除头并返回头，空列表抛异常。
    - `E pop()`：移除头并返回头，底层调用的 `removeFirst()`，1.5版本。
    - `E remove()`：移除头并返回头，底层调用的 `removeFirst()`，1.6版本。    
    - `E removeLast()`：移除尾并返回尾，空列表抛异常           
    - `E pollLast()`：移除尾并返回尾，空列表返回null，1.6版本。
    - `E remove(int index)`：根据角标获取并删除元素。
    - `E remove(Object o)`：根据内容获取并删除元素。
    - `boolean removeFirstOccurrence(Object o)`：删除第一次出现的指定元素。
    - `boolean removeLastOccurrence(Object o)`：删除最后一次出现的指定元素。
- 遍历：可以使用for或者for-each进行遍历。

**源码：** collection/LinkedListTest.java

## 2.3 Stack实现类

**概念：** Stack类继承自Vector类（List的一个同步实现），是栈结构的工具类：
- 构造：`Stack()` 实例化一个空栈。
- 方法：
    - `E push(E item)`：将元素推送到此栈结构的栈顶，并返回此元素。
    - `E peek()`：查看栈顶元素，对空栈进行此操作，会抛异常。
    - `E pop()`：移除并返回栈顶元素，对空栈进行此操作，会抛异常。
    - `boolean empty()`：测试此栈是否为空。
- 遍历：可以使用for-each进行遍历。

**源码：** collection/StackTest.java

# 3. Set接口

**概念：** Set接口是相对无序（输入和输出不同）的一种容器，且不支持重复数据，并且最多包含一个null元素。

## 3.1 HashSet实现类

**概念：** HashSet底层满足Hash分布，无序不同步，是最常用的一种Set实现类。
- 构造：
- 方法：大部分的方法和List是一致的。
    - `int hashCode()`：对于集合来说，返回的是集合中所有元素的hashCode之和，空集合返回0。
- 遍历：可以使用for-each来遍历

**源码：** collection/HashSetTest.java

## 3.2 TreeSet实现类

**概念：** TreeSet的底层是二叉树结构，可以对存储的内容进行排序，线程不同步。
- TreeSet会对实现了 `Comparable` 的接口的类进行自然排序（默认可改），如String、Integer等。
- TreeSet允许指定自定义的比较器并作用在集合中元素的排序过程中。
- 如果我们要添加的元素即没有实现 `Comparable` 接口，TreeSet中也没有指定自定义比较器，则无法使用TreeSet存贮。

**源码：** collection/TreeSetTest.naturalSort()

### 3.2.1 实现比较能力

**概念：** 如果想让某个自定义类也具有能比较的能力，可以效仿String或Integer，让该类实现 `Comparable` 接口，然后在重写方法中定义比较规则：
- 重写：`int compareTo(T o)`
    - param1: 参与比较的参数，它会与上一个o进行比较。 
    - return: 返回正整数表示p1在前，负整数表示p2在前，0表示相等并去重。 

**源码：** collection/TreeSetTest.sortByComparable()

### 3.2.2 自定义比较器

**概念：** TreeSet在构造的时候，可以直接指定一个 `java.util.Comparator` 的实现类作为比较器，然后在重写方法中定义比较规则：
- 构造：`TreeSet(Comparator<? super E> comparator)`
- 重写：`int compare(T o1, T o2)`
    - param1: 参与比较的第1个参数。
    - param2: 参与比较的第2个参数。
    - return: 返回正整数表示p1在前，负整数表示p2在前，0表示相等并去重。

**源码：** collection/TreeSetTest.sortByComparator()

## 3.3 EnumSet

**概念：** EnumSet能通过静态方法 `allOf(Week.class)` 将 `Week` 中的所有枚举常量转成一个Set结构。

**源码：**
```java
EnumSet<Week> weekSet = EnumSet.allOf(Week.class);
for (Week day : weekSet) {
    System.out.print(day.toString() + "\t");
}
```

# 4. Queue容器
        
**概念：** `java.util.Queue` 接口继承自 `Collection` 接口，是队列结构的工具接口，提供了许多队列结构的API方法：
- `boolean add(E e)`：将指定的元素加入到对列中，如果添加成功返回true。
- `boolean offer(E e)`：将指定的元素加入到对列中，如果添加成功返回true
    - 当队列有容量限制的时候，此方法通常优于 `add()`。
- `E remove()`：移除并返回队列头元素，对空队进行此操作，会抛 `NoSuchElementException` 异常。
- `E poll()`：移除并返回队列头元素，对空队进行此操作，会返回null。
- `E element()`：返回队列头元素（不移除），对空队列进行此操作，会抛 `NoSuchElementException` 异常。
- `E peek()`：返回队列头元素（不移除），对空队列进行此操作，会返回null。

> 队列通常是以FIFO的方式操作元素的，但是优先级队列或LIFO队列等特殊队列例外。

**源码：** generic/QueueTest.java

# 5. Map

```java
Map
    |__ HashMap
    |__ HashTable
    |__ TreeMap
```


将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射到一个值。

## 5.1 HashMap

HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 

HashMap常用API方法
@Test
public void test() {
	Map<String, Object> map = new HashMap<>();

	// create
	map.put("gongzuo", "");
	map.put("gongzuo", "singer");// 相同的key会覆盖，就相当于修改操作
	map.put("job", "singer");// 相同的value无所谓
	map.put("t", null);// HashMap的value允许null
	map.put(null, "k");// HashMap的key允许key
	map.put(null, null);// 相同的null的也会发生覆盖
	Map<String, Object> map2 = new HashMap<String, Object>();
	map2.put("a", 1);
	map2.put("b", 2);
	map.putAll(map2);// putAll代表将另一个Map整合到自己的Map中

	System.out.println(map);// map可以直接打印
	System.out.println(map.get("gongzuo"));// 通过key查询value
	System.out.println(map.containsKey("gongzuo"));// 查询map中是否有指定的key
	System.out.println(map.containsValue("singer"));// 查询map中是否有指定的value
	System.out.println(map.isEmpty());// 查询map是否为空map
	System.out.println(map.size());// 查询map中的键值对个数
	System.out.println(map.values());// 查询map中的所有value的collection集合
	System.out.println(map.keySet());// 查询map中的所有key的set集合

	// 获取map的entrySet形式后遍历map
	Set<Entry<String, Object>> set = map.entrySet();
	for (Entry<String, Object> e : set) {
		System.out.println(e.getKey() + ":" + e.getValue());
	}

	// delete
	map.remove("job");// 根据key删除同key的所有键值对
	map.remove(null);// 如果想删除null，不能加双引号
	map.clear();// 清空所有map中的键值对
}

练习 03003-4 

## 5.2 TreeMap

TreeMap是基于红黑树（Red-Black tree）的Map实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。
public static void main(String[] args) {
    TreeMap<String,Object> map = new TreeMap<String,Object>();
    map.put("1","a");
    map.put("3","c");
    map.put("2","b");
    map.put("5","e");

    System.out.println(map.ceilingEntry("2"));// 查询大于[等于]给定值的所有值中的最小Entry
    System.out.println(map.ceilingKey("4"));// 查询大于[等于]给定值的所有值中的最小key
    System.out.println(map.higherEntry("2"));// 查询大于给定值的所有值中的最小Entry
    System.out.println(map.higherKey("2"));// 查询大于给定值的所有值中的最小Key

    System.out.println(map.floorEntry("4")); // 查询小于[等于]给定值的所有值中的最大Entry
    System.out.println(map.floorKey("2"));// 查询小于[等于]给定值的所有值中的最大Key 
    System.out.println(map.lowerEntry("4"));// 查询小于给定值的所有值中的最大Entry
    System.out.println(map.lowerKey("2"));// 查询小于给定值的所有值中的最大Key

    System.out.println(map.comparator());// 查询map的比较器实例，如果没有返回null

    System.out.println(map.descendingMap());// 逆序排列所有Entry
    System.out.println(map.descendingKeySet());// 逆序排列所有key

    System.out.println(map.firstEntry());// 查询第一个Entry
    System.out.println(map.firstKey());// 查询第一个key
    System.out.println(map.lastEntry());// 查询最后一个Entry
    System.out.println(map.lastKey());// 查询最后一个ke

    System.out.println(map.headMap("4"));// 将map截取到指定值(不包括指定值)
    System.out.println(map.headMap("4", true));// 将map截取到指定值(包括指定值)
    System.out.println(map.tailMap("3"));// 将map从指定值开始截取(包括指定值)
    System.out.println(map.tailMap("3",false));// 将map从指定值开始截取(不包括指定值)
    
    System.out.println(map.subMap("2","4"));// 从p1截取到p2，默认左闭右开
    System.out.println(map.subMap("2",false,"3",true));// 从p1截取到p2，左开右闭
}

## 5.3 EnumMap

**概念：** `java.util.EnumMap` 可以将枚举常量作为 `KEY`，将一个字符串作为 `VALUE`。

**源码：**
```java
EnumMap<Week, String> map = new EnumMap<>(Week.class);
map.put(Week.MON, "星期一");
map.put(Week.TUE, "星期二");
map.put(Week.WED, "星期三");
map.put(Week.THU, "星期四");
map.put(Week.FRI, "星期五");
map.put(Week.SAT, "星期六");
map.put(Week.SUN, "星期日");
    
Set<Map.Entry<Week,String>> set = map.entrySet();
for (Map.Entry<Week,String> e : set){
    System.out.println(e.getKey() + " : " + e.getValue());
}    
```

# 6. 迭代器

**概念：** 除了使用for或foreach循环外，我们更建议使用迭代器来遍历列表：    
- `ArrayList` 通过 `iterator()` 获得 `Iterator` 实例： 
    - `Iterator` 默认指针在0号位置之前。
    - `hasNext()` + `next()` ：配合完成列表的迭代。
    - 它可以通过 `remove()`：删除当前指针所在位置的内容。
- `ArrayList` 通过 `listIterator()` 获得 `ListIterator` 实例：
    - 它是 `Iterator` 接口的子类，只能遍历list，允许使用 `Iterator` 的所有API方法。
    - `listIterator(int pos)` 可以灵活地指定初始指针的位置。
    - `hasPrevious()` 和 `previous()`：配合完成列表的反向迭代，`ListIterator` 专属。
    - `set(E e)`：替换当前指针所在位置的内容，`ListIterator` 专属。

源码：collection/IteratorTest.java


> Iterator迭代器的效率比for和foreach更高。