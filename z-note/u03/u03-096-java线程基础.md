# 1. 进程与线程

**概念：** 
- 进程：OS进行分配和管理资源的基本单位。
    - 启动一个程序至少启动了一个进程。
    - 每启动一个进程，OS都会为其分配独立的数据空间，建立数据表来维护代码段、堆栈段和数据段。
    - 进程间切换开销大。
- 线程：进程的一条执行路径，是CPU调度和分派的基本单位，也被称为轻量级进程。
    - 启动一个进程至少启动了一个线程。
    - 线程有自己的堆栈和局部变量，但没有独立的数据空间，但它们共享所在进程的代码和数据。
    - 线程间切换开销小。

# 2. 线程分类

**概念：** 线程分为前台线程和后台线程。

- 前台线程中，先执行主线程，然后JVM随机分配时间片，最后子线程交替运行。
- 后台线程也叫守护线程，后台线程是依赖前台线程的，如果所有的前台线程都死了，那么后台线程自动退出(JVM就退出了)，只要有一个前台线程活动，那么后台线程就活动。

## 2.1 前台线程

**概念：** 前台线程可以通过三种方式来创建：
- 继承Thread类方式创建线程，方式比较单一，因为无法再去继承其他的类。
    - 可以使用匿名内部类进行优化
- 实现Runnable接口方式创建线程
    - 可以使用匿名内部类进行优化
    - 可以使用lambda表达式进行优化

**源码：** thread/ForegroundThreadTest.java

## 2.2 后台线程

概念：主线程循环50次，子线程无限循环，将子线程设置成守护线程，如果主线程结束之后，子线程也结束，则子线程设置守护成功
守护线程

**源码：** thread/DaemonThreadTest.java

# 3. Thread类API

**概念：** 
- `public void start()`：手动启动线程(并不一定立刻执行，等JVM随机分配时间片)
- `Boolean isAlive()`：测试线程是否还活着
- `static Thread currentThread()`：返回当前正在执行的线程对象的引用
- `void setName(String name)`：设置该线程的名字
- `String getName()`：返回该线程的名称
- `void setPriority(int newPriority)`：设置线程优先级
    - MAX_PRIORITY
    - NORM_PRIORITY
    - MIN_PRIORITY
- `int getPriority()`：获取线程优先级
- `static void sleep(long millis)`：在指定的毫秒数内让当前正在执行的线程休眠
    - `TimeUnit.SECONDS.sleep(1L)`：是sleep的上层封装

**源码：** thread/ThreadApiTest.java

# 4. JVM内存模型

概念：
- 计算机底层通信模型：计算机底层的硬件（CPU）和软件（内存）之间是通过IO桥和总线来进行通信连接的：
    - CPU通过系统总线连接到IO-Bridge。
    - 内存通过内存总线连接到IO-Bridge。
    - 其他组成部分如USB，显卡，磁盘，网卡驱动等，通过IO总线连接到IO-Bridge。
- CPU内部结构：一颗CPU中存在多个核（双核，四核，八核等），每个核都能独立的运行一个线程，每个核都独立有自己的一级缓存和二级缓存，多核共享三级缓存，多颗CPU共享同一个内存。
- CPU读数据：CPU在读数据的时候，为了提高效率，会一次性从内存中读取64个字节，称为一个缓存行。

// TODO: 缓存行对其

# 5. volatile关键字

```java
/**
 * @author JoeZhou
 */
public class VolatileTest {

    public static void main(String[] args) throws InterruptedException {
        VolatileDemo volatileDemo = new VolatileDemo();
        new Thread(volatileDemo).start();
        Thread.sleep(2000L);
        volatileDemo.setFlag(true);
        System.out.println("thread-main:over");

    }

}

class VolatileDemo implements Runnable {

    private /*volatile*/ boolean flag;

    @Override
    public void run() {
        while (!flag) {
        }
    }

    void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

## 1.2 线程声明周期

**概念：** 
- 初始(NEW)：新创建了一个线程对象，调用start()后可以进入RUNNABLE状态。
- 可运行(RUNNABLE)：处于RUNNABLE状态的线程才有资格被线程调度器选中：
    - READY是就绪状态，如果被线程调度器选中执行，则进入RUNNING状态。
    - 如果由RUNNING状态退回到READY状态，则称线程被挂起。
- 被阻塞(BLOCKED)：
    - RUNNABLE状态的线程等待进入同步代码块的锁时的状态就是BLOCKED状态。
    - BLOCKED状态只有在线程获取了同步代码块的锁之后才能解除。
- 等待(WAITING)：
    - RUNNABLE状态的线程被调用了 `wait()`，`join()`，`LockSupport.park()` 后就处于WAITING状态。
    - 可以使用对应的 `notify()`，`notifyAll()`，`LockSupport.park()` 来解除一个线程的WAITING状态。
- 计时等待(TIME_WAITING)：
    - RUNNABLE状态的线程被调用了 `sleep(t)`,`wait(t)`，`join(t)`，`LockSupport.parkNanos()`，，`LockSupport.parkUntil()` 后就处于TIME_WAITING状态。
    - TIME_WAITING可以在指定的时间内自行解除。
- 终止(TERMINATED)：表示该线程已经执行完毕。























