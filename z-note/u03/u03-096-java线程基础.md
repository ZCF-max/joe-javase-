# 1. 概念入门

## 1.1 进程与线程

**概念：** 
- 进程：OS进行分配和管理资源的基本单位。
    - 启动一个程序至少启动了一个进程。
    - 每启动一个进程，OS都会为其分配独立的数据空间，建立数据表来维护代码段、堆栈段和数据段。
    - 进程间切换开销大。
- 线程：进程的一条执行路径，是CPU调度和分派的基本单位，也被称为轻量级进程。
    - 启动一个进程至少启动了一个线程。
    - 线程有自己的堆栈和局部变量，但没有独立的数据空间，但它们共享所在进程的代码和数据。
    - 线程间切换开销小。

## 1.2 线程声明周期

**概念：** 
- 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
- 运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
    - 阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。
	- 等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
	- 超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，它可以在指定的时间内自行返回。
- 终止(TERMINATED)：表示该线程已经执行完毕。

# 2. 线程分类


**概念：** 线程分为前台线程和后台线程。

- 前台线程中，先执行主线程，然后JVM随机分配时间片，最后子线程交替运行。
- 后台线程也叫守护线程，后台线程是依赖前台线程的，如果所有的前台线程都死了，那么后台线程自动退出(JVM就退出了)，只要有一个前台线程活动，那么后台线程就活动。

## 2.1 前台线程

**概念：** 前台线程可以通过三种方式来创建：
- 继承Thread类方式创建线程，方式比较单一，因为无法再去继承其他的类。
    - 使用匿名内部类进行优化
- 实现Runnable接口方式创建线程
    - 使用匿名内部类进行优化
    - JDK1.8 lambda表达式写法

```java
new Thread() {
    @Override
    public void run() {
        for (int i = 1; i < 10; i++) {
            System.out.println(Thread.currentThread());
        }
    }
}.start();
```

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        for (int i = 1; i < 10; i++) {
            System.out.println(Thread.currentThread());
        }
    }
}).start();
```

```java
new Thread(() -> {
    for (int i = 0, j = 99; i < j; i++) {
        System.out.println(Thread.currentThread());
    }
}).start();
```

## 2.2 后台线程

概念：主线程循环50次，子线程无限循环，将子线程设置成守护线程，如果主线程结束之后，子线程也结束，则子线程设置守护成功
```java
/*** @author Joe*/
public class DaemonThreadTest {
    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            while (true) {
                System.out.println(Thread.currentThread());
            }
        });

        // 把t1设置成了守护线程，如果想把某一个线程设置为守护线程，必须在启动之前去设置
        t1.setDaemon(true);
        t1.start();
        
        for (int i = 0, j = 50; i < j; i++) {
            System.out.println(Thread.currentThread() + " : " + i);
        }
    }
}
```

# 3. Thread类API

```java
// 手动启动线程(并不一定立刻执行，等JVM随机分配时间片)
public void start();

// 测试线程是否还活着
public final Boolean isAlive();

// 返回当前正在执行的线程对象的引用
public static Thread currentThread();

// 设置该线程的名字
public final void setName(String name);

// 返回该线程的名称
public final String getName();

// 设置线程优先级 [MAX_PRIORITY][NORM_PRIORITY][MIN_PRIORITY]
public final void setPriority(int newPriority);

// 获取线程优先级
public final int getPriority();

// 在指定的毫秒数内让当前正在执行的线程休眠
// TimeUnit.SECONDS.sleep(1L);是sleep的上层封装
public static void sleep(long millis);
```

# 4. JVM内存模型


# 5. volatile关键字


























