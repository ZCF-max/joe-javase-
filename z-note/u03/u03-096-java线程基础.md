# 1. 进程与线程

**概念：** 
- 进程：OS进行分配和管理资源的基本单位。
    - 启动一个程序至少启动了一个进程。
    - 每启动一个进程，OS都会为其分配独立的数据空间，建立数据表来维护代码段、堆栈段和数据段。
    - 进程间切换开销大。
- 线程：进程的一条执行路径，是CPU调度和分派的基本单位，也被称为轻量级进程。
    - 启动一个进程至少启动了一个线程。
    - 线程有自己的堆栈和局部变量，但没有独立的数据空间，但它们共享所在进程的代码和数据。
    - 线程间切换开销小。
- 线程切换：CPU的工作就是从内存中将指令一条一条拿过来执行，如果没有指令，CPU就处于空闲状态，多线程模式下，每个线程都要争抢CPU，每个线程在CPU执行一会儿，执行完了，需要让出CPU资源，这个过程叫做线程切换。

# 2. 线程声命周期

**概念：** 
- 初始(NEW)：新创建了一个线程对象，调用start()后可以进入RUNNABLE状态。
- 可运行(RUNNABLE)：处于RUNNABLE状态的线程才有资格被线程调度器选中：
    - READY是就绪状态，如果被线程调度器选中执行，则进入RUNNING状态。
    - 如果由RUNNING状态退回到READY状态，则称线程被挂起。
- 被阻塞(BLOCKED)：
    - RUNNABLE状态的线程等待进入同步代码块的锁时的状态就是BLOCKED状态。
    - BLOCKED状态只有在线程获取了同步代码块的锁之后才能解除。
- 等待(WAITING)：
    - RUNNABLE状态的线程被调用了 `wait()`，`join()`，`LockSupport.park()` 后就处于WAITING状态。
    - 可以使用对应的 `notify()`，`notifyAll()`，`LockSupport.park()` 来解除一个线程的WAITING状态。
- 计时等待(TIME_WAITING)：
    - RUNNABLE状态的线程被调用了 `sleep(t)`,`wait(t)`，`join(t)`，`LockSupport.parkNanos()`，，`LockSupport.parkUntil()` 后就处于TIME_WAITING状态。
    - TIME_WAITING可以在指定的时间内自行解除。
- 终止(TERMINATED)：表示该线程已经执行完毕。

**源码：** thread/start/ThreadStateTest.java

# 3. 线程分类

**概念：** 线程分为前台线程和后台线程。

## 3.1 前台线程

**概念：** 前台线程中，先执行主线程，然后JVM随机分配时间片，最后子线程交替运行，基本创建方式有三种：
- 继承Thread类方式创建线程，方式比较单一，因为无法再去继承其他的类。
    - 可以使用匿名内部类进行优化
- 实现Runnable接口方式创建线程
    - 可以使用匿名内部类进行优化
    - 可以使用lambda表达式进行优化

**源码：** thread/start/ForegroundThreadTest.java

## 3.2 后台线程

**概念：** 后台线程也叫守护线程，后台线程是依赖前台线程的，如果所有的前台线程都死了，那么后台线程自动退出(JVM就退出了)，只要有一个前台线程活动，那么后台线程就活动。

**源码：** thread/start/DaemonThreadTest.java

# 4. Thread常用API

## 4.1 线程状态

- `public void start()`：手动启动线程(并不一定立刻执行，等JVM随机分配时间片)
- `Boolean isAlive()`：测试线程是否还活着
- `static Thread currentThread()`：返回当前正在执行的线程对象的引用
- `void setName(String name)`：设置该线程的名字
- `String getName()`：返回该线程的名称
- `void setPriority(int newPriority)`：设置线程优先级
- `int getPriority()`：获取线程优先级

**源码：** thread/start/ThreadBaseApiTest.java

## 4.2 线程睡眠

- `static void sleep(long millis)`：在指定的毫秒数内让当前正在执行的线程休眠
    - `TimeUnit.SECONDS.sleep(1L)`：是sleep的上层封装
    - sleep()之后线程会回到就绪状态。

**源码：** thread/start/ThreadBaseApiTest.java

## 4.3 线程插队

当A线程读到了B线程的join()方法，会停下来，等B死掉后，再执行，join一般用于临时加入一个线程方法，yeild()用于让出一个时间片(不明显)，就比如食堂排队打饭，我调用join方法可以插队买饭，而我调用yield方法是让给你一次机会，让你排在我的前面买饭。

join()方法写在哪个线程中，就插队哪个线程。

join()方法如果写在start()之前，不报错，但是是没有插队效果的。

**源码：** thread/start/ThreadBaseApiTest.java
```java
public class JoinThreadTest {
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            for (int i = 0, j = 10; i < j; i++) {
                System.out.println(Thread.currentThread());
            }
        };

        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        
        // t1插队前需要先启动，否则无法完成插队效果
        t1.start();
        
        // t1插队，此时主线程会挂起，直到t1死去才继续运行
        t1.join();
        
        // 主线程被t1插队，所以t1执行完之前，t2不会被启动
        t2.start();

        // 主线程
        for (int i = 0, j = 10; i < j; i++) {
            System.out.println(Thread.currentThread());
        }
    }
}
```

## 4.3 线程让步

- `static void yeild()`：当前让出一次时间片返回到就绪状态，其他线程此时有机会抢到CPU资源。

**源码：** thread/start/ThreadBaseApiTest.java

# 5. JVM内存模型

**概念：**
- 计算机底层通信模型：计算机底层的硬件（CPU）和软件（内存）之间是通过IO桥和总线来进行通信连接的：
    - CPU通过系统总线连接到IO-Bridge。
    - 内存通过内存总线连接到IO-Bridge。
    - 其他组成部分如USB，显卡，磁盘，网卡驱动等，通过IO总线连接到IO-Bridge。
- CPU结构：CPU核心主要由运算器（负责计算过程），控制器（负责收发计算指令）和寄存器（保存计算中间信息）组成：
    - 一颗CPU中存在多个核心（双核，四核，八核等），每个核心都能独立运行至少一个线程。
        - inter发明了超线程技术，让一个核心可以模拟两个线程，但一般情况下，在效率方面来说，四核八线程远不及八核效率高。
    - 每个核心都独立有自己的一级缓存L1和二级缓存L2，所有核心共享一个三级缓存L3。
    - 多颗CPU共享同一个主内存。
- CPU读取数据流程：
    - 先尝试从L1读取，读取成功返回数据，速度极快，一个CPU的L1越大，性能越高。
    - L1读取失败，则尝试从L2读取，读取成功返回数据，失败则从L3读取，读取成功返回数据。
    - L3读取失败，则从主存中读取，速度相对低。

# 6. volatile关键字

**概念：** volatile修饰的变量有两种效果，即保证可见性和禁止指令重排序。

## 5.1 保证可见性

**概念：** volatile的底层使用的是MESI协议，即CPU缓存一致性协议，所以当volatile修饰的变量被某个线程改动后，会原子性地将改动后的值写回主存，并会立刻通知其他所有同样在使用该变量的线程，请重新到主存中获取最新的值。

**源码：** start/EnsureVisibilityByVolatileTest.java

> 尽量仅使用volatile修饰基本数据类型，修饰引用数据类型时只对其本身的改动立即可见，对引用数据类型内部的属性的改变不生效。

## 5.2 禁止指令重排序

**概念：** 只要最终的结果不影响，有时候JVM为了提高程序的运行速度，可能会将代码的指令进行重新的排序执行，但这也许会对我们的代码逻辑产生影响，而volatile会对指令添加内存屏障，所以volatile修饰的变量会禁止JVM对其进行指令重排序。

**源码：** start/OrderReorderingTest.java

## 5.3 高速缓存行

**概念：** CPU在读数据的时候，为了提高效率，不会只读取目标值，而是连带着目标值相邻的，共64个字节的内容一并进行读取和回写操作，整行的内容称为一个高速缓存行，灵活运行缓存行可以提高程序效率，比如尽量将读的数据 `a` 和写的数据 `volatile b` 人为分开到不同的缓存行中，否则频繁的对 `b` 进行改动会连带着 `a` 一起在缓存和主存中不断的来回传输，影响读数据a的效率。

**源码：** start/CacheLinePaddingTest.java



7. 线程调度类

java.util.Timer 和 java.util.TimerTask这两个类可以负责java中的定时和调度相关内容。

Timer中的schedule(TimerTask task,long delay,long period)方法负责定时，读音[si gai zhu ler]，参数1是你的任务类，参数2是几毫秒后执行，参数3是周期，每隔多少毫秒执行一次。

Timer中的cancel()方法负责结束定时任务。

案例：设计我的闹钟程序，每天早上6点，闹钟响起，控制台输入"q"结束闹钟。
public class 我的闹钟{
	public static void main(String[] args) throws IOException {
		Timer timer = new Timer();// 定时对象
		MyTask myTask = new MyTask();// 定时任务
		timer.schedule(myTask, 0, 1000);// 0毫秒后，每隔1000毫秒执行一次myTask
		if (System.in.read() == 'q') {
			// timer.cancel(); // 关闭schedule
			myTask.setFlag(false);// 闹钟设置为不响
		}
	}
}

class MyTask extends TimerTask {
	private boolean flag = false;// 闹钟标志位 - 不响
	@Override
	public void run() {
		String dateStr = new SimpleDateFormat("hhmmss").format(new Date());// 获取系统时间格式化成时分秒
		// System.out.println(dateStr);
		if ("060000".equals(dateStr)) {// 每日早晨6点
			flag = true;// 闹钟标志位 - 响
		}
		if (flag) {
			System.out.println("起床了.....");
		}
	}
	public boolean isFlag() {return flag;}
	public void setFlag(boolean flag) {this.flag = flag;}
}






















