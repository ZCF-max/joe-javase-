# 1. 进程与线程

**概念：** 
- 进程：OS进行分配和管理资源的基本单位。
    - 启动一个程序至少启动了一个进程。
    - 每启动一个进程，OS都会为其分配独立的数据空间，建立数据表来维护代码段、堆栈段和数据段。
    - 进程间切换开销大。
- 线程：进程的一条执行路径，是CPU调度和分派的基本单位，也被称为轻量级进程。
    - 启动一个进程至少启动了一个线程。
    - 线程有自己的堆栈和局部变量，但没有独立的数据空间，但它们共享所在进程的代码和数据。
    - 线程间切换开销小。
- 线程切换：CPU的工作就是从内存中将指令一条一条拿过来执行，如果没有指令，CPU就处于空闲状态，多线程模式下，每个线程都要争抢CPU，每个线程在CPU执行一会儿，执行完了，需要让出CPU资源，这个过程叫做线程切换。

# 2. 线程分类

**概念：** 线程分为前台线程和后台线程。

- 前台线程中，先执行主线程，然后JVM随机分配时间片，最后子线程交替运行。
- 后台线程也叫守护线程，后台线程是依赖前台线程的，如果所有的前台线程都死了，那么后台线程自动退出(JVM就退出了)，只要有一个前台线程活动，那么后台线程就活动。

## 2.1 前台线程

**概念：** 前台线程可以通过三种方式来创建：
- 继承Thread类方式创建线程，方式比较单一，因为无法再去继承其他的类。
    - 可以使用匿名内部类进行优化
- 实现Runnable接口方式创建线程
    - 可以使用匿名内部类进行优化
    - 可以使用lambda表达式进行优化

**源码：** thread/start/ForegroundThreadTest.java

## 2.2 后台线程

概念：主线程循环50次，子线程无限循环，将子线程设置成守护线程，如果主线程结束之后，子线程也结束，则子线程设置守护成功
守护线程

**源码：** thread/start/DaemonThreadTest.java

# 3. Thread常用API

**概念：** 
- `public void start()`：手动启动线程(并不一定立刻执行，等JVM随机分配时间片)
- `Boolean isAlive()`：测试线程是否还活着
- `static Thread currentThread()`：返回当前正在执行的线程对象的引用
- `void setName(String name)`：设置该线程的名字
- `String getName()`：返回该线程的名称

- `void setPriority(int newPriority)`：设置线程优先级
    - MAX_PRIORITY
    - NORM_PRIORITY
    - MIN_PRIORITY
- `int getPriority()`：获取线程优先级
- `static void sleep(long millis)`：在指定的毫秒数内让当前正在执行的线程休眠
    - `TimeUnit.SECONDS.sleep(1L)`：是sleep的上层封装
    - sleep()之后线程会回到就绪状态。
- `static void yeild()`：当前让出一次时间片返回到就绪状态，其他线程此时有机会抢到CPU资源。

**源码：** thread/start/ThreadBaseApiTest.java


6. 线程插队让步

当A线程读到了B线程的join()方法，会停下来，等B死掉后，再执行，join一般用于临时加入一个线程方法，yeild()用于让出一个时间片(不明显)，就比如食堂排队打饭，我调用join方法可以插队买饭，而我调用yield方法是让给你一次机会，让你排在我的前面买饭。

join()方法写在哪个线程中，就插队哪个线程。

join()方法如果写在start()之前，不报错，但是是没有插队效果的。

yield()方法是静态的，使用的时候请使用Thread.yield();

```java
public class JoinThreadTest {
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            for (int i = 0, j = 10; i < j; i++) {
                System.out.println(Thread.currentThread());
            }
        };

        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        
        // t1插队前需要先启动，否则无法完成插队效果
        t1.start();
        
        // t1插队，此时主线程会挂起，直到t1死去才继续运行
        t1.join();
        
        // 主线程被t1插队，所以t1执行完之前，t2不会被启动
        t2.start();

        // 主线程
        for (int i = 0, j = 10; i < j; i++) {
            System.out.println(Thread.currentThread());
        }
    }
}
```

# 4. JVM内存模型

概念：
- 计算机底层通信模型：计算机底层的硬件（CPU）和软件（内存）之间是通过IO桥和总线来进行通信连接的：
    - CPU通过系统总线连接到IO-Bridge。
    - 内存通过内存总线连接到IO-Bridge。
    - 其他组成部分如USB，显卡，磁盘，网卡驱动等，通过IO总线连接到IO-Bridge。
- CPU内部结构：一颗CPU中存在多个核（双核，四核，八核等），每个核都能独立的运行一个线程，每个核都独立有自己的一级缓存和二级缓存，多核共享三级缓存，多颗CPU共享同一个内存。
- CPU读数据：CPU在读数据的时候，为了提高效率，会一次性从内存中读取64个字节，称为一个缓存行。

// TODO: 缓存行对其



# 5. volatile关键字

**概念：** volatile修饰的变量的改动对所有线程都立即可见。

- 加了syn之后就不用再加volatile了

> 尽量仅使用volatile修饰基本数据类型，修饰引用数据类型时只对其本身的改动立即可见，对引用数据类型内部的属性的改变不生效。

```java

```

## 1.2 线程声明周期

**概念：** 
- 初始(NEW)：新创建了一个线程对象，调用start()后可以进入RUNNABLE状态。
- 可运行(RUNNABLE)：处于RUNNABLE状态的线程才有资格被线程调度器选中：
    - READY是就绪状态，如果被线程调度器选中执行，则进入RUNNING状态。
    - 如果由RUNNING状态退回到READY状态，则称线程被挂起。
- 被阻塞(BLOCKED)：
    - RUNNABLE状态的线程等待进入同步代码块的锁时的状态就是BLOCKED状态。
    - BLOCKED状态只有在线程获取了同步代码块的锁之后才能解除。
- 等待(WAITING)：
    - RUNNABLE状态的线程被调用了 `wait()`，`join()`，`LockSupport.park()` 后就处于WAITING状态。
    - 可以使用对应的 `notify()`，`notifyAll()`，`LockSupport.park()` 来解除一个线程的WAITING状态。
- 计时等待(TIME_WAITING)：
    - RUNNABLE状态的线程被调用了 `sleep(t)`,`wait(t)`，`join(t)`，`LockSupport.parkNanos()`，，`LockSupport.parkUntil()` 后就处于TIME_WAITING状态。
    - TIME_WAITING可以在指定的时间内自行解除。
- 终止(TERMINATED)：表示该线程已经执行完毕。


- `String getState()`：返回该线程的声明周期状态

**源码：** thread/start/ThreadStateTest.java
























