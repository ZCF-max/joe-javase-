# 1. NIO概念入门

## 1.1 IO底层流程

**概念：** OS可以执行所有的CPU指令，包括很多危险操作，所以为了程序的健壮性，CPU指令需要被分类：
- 内核态：位于内核内存空间，间由OS直接使用。
- 用户态：位于用户内存空间，如果想访问内核态指令，必须向OS申请。

> IO的数据读取真实流程：磁盘上的数据读取到内核空间，然后再读取到用户空间。

## 1.2 IO常见模型

**概念：**
- IO模型：阻塞式IO模型：当用户发起一个read请求后，必须等到read出了结果，才可以去做别的事情。
- NIO模型：非阻塞式IO模型：当用户发起一个read请求后，立刻得到结果，这个结果是你要读的硬盘数据是否已经加载到了内核空间，如果已经加载到了，开始从内核空间读取数据到用户空间（这个过程是阻塞的），如果没有加载到，每隔一段时间就重问一遍（间隔轮询），这种模式下，因为每次都会立刻得到结果而无需等待，所以不会阻塞，用户可以做其他的事情。
- NIO复用模型：同时执行并监听多个NIO，哪个NIO的内核空间从硬盘上成功加载到了数据，执行哪个NIO。
- AIO，异步IO模型：多个IO独立进行工作，互不干扰。

## 1.3 NIO

**概念：** NIO（Non-Block IO）是从jdk1.4版本开始引入的一个新的IO流API，可以替代标准的Java IO API，自带一个缓冲区，可以进行更加高效的文件读写操作。
- 对比IO：
    - NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同。
    - IO面向流，NIO面向缓冲区。
    - IO是阻塞的，读或者写的时候都会阻塞当前线程，NIO是非阻塞的，可以同时读和写。
    - IO是单向的，要么读，要么写，NIO是双向的，同一个NIO实例，既可以读也可以写。
- 在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 

# 2. NIO核心之Buffer缓冲

**概念：** 
- Buffer是NIO的核心之一，就像一个数组，可以保存多个相同类型的数据，且支持双向操作。
- Buffer根据数据类型不同(boolean除外) ，有以下Buffer的常用子类：
    - ByteBuffer/ShortBuffer/IntBuffer/LongBuffer
    - FloatBuffer/DoubleBuffer/CharBuffer

## 2.1 Buffer创建方式

**概念：** Buffer有两种类型：
- 直接缓冲区：DirectBuffer
    - DirectBuffer位于计算机本地内存（native），与JVM无关，创建和销毁的开销比较大，也不容易被控制。
    - DirectBuffer的传输效率高，因为本地内存和内核空间因为都在同一OS中，可以进行直接进行通信。
    - DirectBuffer的内存回收工作需要自己想办法解决。
    - 创建方式：`XXXBuffer.ballocateDirect(1024)`：必须指定初始缓冲区容量大小。
- 非直接缓冲区：HeapBuffer
    - HeapBuffer也叫Java堆缓冲区，位于JVM的堆内存中，创建和销毁的开销比较小，容易控制。
    - HeapBuffer的传输效率低，因为JVM属于另一块虚拟的OS，想要和本机OS的内核空间进行数据传输，需要先再开辟一块本地内存作为中间媒介，这块本地内存被称为中间缓冲区。
    - HeapBuffer的内存回收工作由JVM的GC管理，不用我们操心。
    - 创建方式：`XXXBuffer.allocate(1024)`：必须指定初始缓冲区容量大小。
- `buffer.isDirect()`：判断一个缓冲区实例是否是直接缓冲区。

**源码：** nio/BufferTest.build()

## 2.2 Buffer核心属性

**概念：** Buffer有四个核心属性：
- `capacity`: 缓冲区最大容量，且一旦声明不能改变。
    - 理解：你只能装这么多个字节的数据。
    - 设置：必须在构造缓冲区的时候指定。
    - 获取：`Buffer capacity()`。
- `limit`: 缓冲区中可以操作的数据上限位置。
    - 理解：你只能读这么多个字节的数据，或者写这么多个字节的数据。
    - 设置：`void limit(int pos)`：默认等于最大容量。
    - 获取：`int limit()`
- `position`: 缓冲区中当前操作的数据的位置（当前指针）。
    - 理解：你当前已经读，或者写到这个位置了。
    - 设置：`Buffer position(int pos)`：默认为0。
    - 获取：`int position()`
- `mark`: 当前指针的备份标记。
    - 理解：你在这个位置做了个标记。
    - 设置：`void mark()`：将当前指针position备份给mark。
    - 获取：`void reset()`：将mark值赋值给当前位置position，指针回到标记的位置。

> 0 <= mark <= position <= limit <= capacity

**源码：** nio/BufferTest.coreAttributes()

## 2.3 Buffer基础操作

**概念：** 以 `ByteBuffer` 为例：
- `ByteBuffer put(byte[] src)`: 将字节数组的全部内容传输到它的缓冲区中。
- `byte[] array()`：返回缓冲区内容的字节数组形式，不会移动指。
- `Buffer flip()`：翻转缓冲区，切换为读模式：
    - `limit = position`
    - `position = 0`
    - `mark = -1`：将mark标记废除。
- `byte get()`：获取缓冲区中的数据，每获取一个字节，指针后移一个字节。
- `byte get(index i)`：获取缓冲区中指定位置上的字节，但不会移动指针。
- `Buffer rewind()`：position归0，将mark标记废除。
- `Buffer clear()`：position归0，将limit归回capacity位置，将mark标记废除。
- `boolean hasRemaining()`：缓冲区中仍有未读数据。
- `int remaining()`：返回缓冲区中未读数据的个数。

**源码：** nio/BufferTest.bufferApi()

# 3. NIO核心之Channel通道

**概念：** 阻塞式IO的两端是APP和硬盘数据，而非阻塞式NIO的两端是Buffer和硬盘数据，然后APP从Buffer中读，或向Buffer中写，而 `java.nio.channels.Channel` 就是java中表示nio通道的接口。
- Channel常用实现类：
    - FileChannel：文件操作的通道。
    - SocketChannel：TCP协议连接的客户端通道。
    - ServerSocketChannel：TCP协议连接的服务端通道。
    - DatagramChannel：UDP协议连接通道。
- Channel常用API方法：
    - `int read(ByteBuffer dst)`：将硬盘文件数据读到缓冲区，读完返回-1。
    - `int write(ByteBuffer src)`：从缓冲区向硬盘文件数据输出数据。

## 3.1 FileChannel

**概念：** FileChannel通道负责连接硬盘文件数据和Buffer。

**测试：** 通过FileChannel将 `nio-src.txt` 文件中的内容拷贝到 `nio-dest.txt` 中。
```java
@Test
public void fileChannel() throws IOException {
    String srcPath = "D:" + File.separator + "java-io" + File.separator + "nio-src.txt";
    String destPath = "D:" + File.separator + "java-io" + File.separator + "nio-dest.txt";
    FileInputStream fis = new FileInputStream(srcPath);
    FileOutputStream fos = new FileOutputStream(destPath);
    FileChannel fisChannel = fis.getChannel();
    FileChannel fosChannel = fos.getChannel();
    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
    while (true) {
        byteBuffer.clear();
        int read = fisChannel.read(byteBuffer);
        if (read == -1) {
            break;
        }
        byteBuffer.flip();
        fosChannel.write(byteBuffer);
    }
    fosChannel.close();
    fisChannel.close();
    fis.close();
    fos.close();
}
```

## 3.2 SocketChannel

> 创建一个Socket地址连接需要使用new InetSocketAddress()构造，客户端需要在执行构造的同时指定一个包含了字符串IP和数字端口号的Socket地址，而服务端只需在使用之前绑定(bind)一个指定了端口号的Socket地址即可。

**概念：** SocketChannel是负责连接TCP客户端的通道，和它相对应的是ServerSocketChannel，是负责连接TCP服务端的通道。
- ServerSocketChannel常用API方法：
    - `static ServerSocketChannel open()`：打开一个ServerSocketChannel的通道。
    - `ServerSocketChannel bind(SocketAddress local)`：对通道绑定一个Socket地址。
    - `SocketChannel accept()`：服务端通道等待接收数据，该方法会阻塞。
- SocketChannel常用API方法：
    - `static SocketChannel open(SocketAddress remote)`：打开的一个SocketChannel的通道并连接到指定Socket地址。

**源码：** BlockSocketServer.java
```java
/**
 * @author JoeZhou
 */
public class BlockSocketServer {
    public static void main(String[] args) throws IOException {
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open()
                .bind(new InetSocketAddress(9999));
        System.out.println("ready to accept data...");
        SocketChannel socketChannel = serverSocketChannel.accept();
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        while (socketChannel.read(byteBuffer) != -1) {
            byteBuffer.flip();
            for (int i = 0, j = byteBuffer.limit(); i < j; i++) {
                System.out.print((char) byteBuffer.get());
            }
            System.out.println();
            byteBuffer.clear();
        }
        socketChannel.close();
        serverSocketChannel.close();
    }
}
```
    
**源码：** BlockSocketClient.java
```java
/**
 * @author JoeZhou
 */
public class BlockSocketClient {
    public static void main(String[] args) throws IOException {
        SocketChannel socketChannel = SocketChannel.open(
                new InetSocketAddress("127.0.0.1", 9999));
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str;
        while ((str = br.readLine()) != null) {
            byteBuffer.put(("=> " + str).getBytes());
            byteBuffer.flip();
            socketChannel.write(byteBuffer);
            byteBuffer.clear();
        }
        br.close();
        socketChannel.close();
    }
}
```
    
**练习：** 03007-3-2

# 4. NIO核心之Selector选择

**概念：** Selector可以监控多个Channel状态并作出对应处理，是设计非阻塞IO模型的最佳选择。
- Channel对应状态有四种：
    - `CONNECT`：Channel已经准备好完成连接序列了（IP，端口等搭建完成）。
    - `ACCEPT`：Channel已经准备好可以被其他Channel连接了（可以调用 `accept()` 了）。
    - `READ`：Channel已经准备好可以进行读取数据的操作了（可以调用 `read()` 了）。
    - `WRITE`：Channel已经准备好可以进行写数据的操作了（可以调用 `write()` 了）。
- 获取方式：`Selector.open()`。
- Selector常用API方法：
    - `int select()`：返回选择器中已经处于就绪状态（可以进行IO操作）的状态个数，这个状态被记作是一个`SelectionKey`。
    - `Set<SelectionKey> selectedKeys()`：返回选择器中已经处于就绪状态（可以进行IO操作）的 `SelectionKey` 的Set集合。
- SelectionKey常用API方法：
    - `boolean isAcceptable()`：判断是否是OP_ACCEPT状态。
    - `boolean isReadable()`：判断是否是OP_READ状态。
    - `SelectableChannel channel()`：获取当前状态下的Channel。

**源码：** NonBlockSocketClient.java
```java
/**
 * @author JoeZhou
 */
public class NonBlockSocketClient {
    public static void main(String[] args) throws IOException {
        SocketChannel socketChannel = SocketChannel.open(
                new InetSocketAddress("127.0.0.1", 9002));
        socketChannel.configureBlocking(false);
        CharBuffer charBuffer = CharBuffer.allocate(1024);
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        CharsetEncoder charsetEncoder = StandardCharsets.UTF_8.newEncoder();
        String str;
        while ((str = br.readLine()) != null) {
            charBuffer.put("=> " + str);
            charBuffer.flip();
            socketChannel.write(charsetEncoder.encode(charBuffer));
            charBuffer.clear();
        }
        br.close();
        socketChannel.close();
    }
}
```

**源码：** NonBlockSocketClient.java
```java
public static void main(String[] args) throws IOException {
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open()
            .bind(new InetSocketAddress(9002));
    serverSocketChannel.configureBlocking(false);
    System.out.println("ready to accept data...");
    CharsetDecoder charsetDecoder = StandardCharsets.UTF_8.newDecoder();
    Selector selector = Selector.open();
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
    SocketChannel socketChannel = null;
    while (selector.select() > 0) {
        Iterator<SelectionKey> it = selector.selectedKeys().iterator();
        while (it.hasNext()) {
            SelectionKey selectionKey = it.next();
            if (selectionKey.isAcceptable()) {
                socketChannel = serverSocketChannel.accept();
                socketChannel.configureBlocking(false);
                socketChannel.register(selector, SelectionKey.OP_READ);
            }
            else if (selectionKey.isReadable()) {
                socketChannel = (SocketChannel) selectionKey.channel();
                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                while (socketChannel.read(byteBuffer) > 0) {
                    byteBuffer.flip();
                    CharBuffer charBuffer = charsetDecoder.decode(byteBuffer);
                    for (int i = 0, j = charBuffer.limit(); i < j; i++) {
                        System.out.print(charBuffer.get());
                    }
                    System.out.println();
                    byteBuffer.clear();
                }
            }
            it.remove();
        }
    }
    if (socketChannel != null) {
        socketChannel.close();
    }
    serverSocketChannel.close();
}
```

