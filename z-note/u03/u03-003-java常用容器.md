
# 2. Collection容器

概念：容器可以帮助我们更灵活地组织和操纵数据，`java.util.Collection` 包下给我们提供了一些更好的数据结构，它是 `java.lang.Iterable` 接口的一个子接口，提供了一些容器类，子类关系如下图

```
Iterable
    |__Collection
        |__ List
            |__ ArrayList
            |__ LinkedList
            |__ Vector
                |__ Stack
        |__ Queue
        |__ Set
            |__ HashSet
            |__ TreeSet
Map
    |__ HashMap
    |__ HashTable
    |__ TreeMap
```


# 3. List与ArrayList

概念：List是有序的collection，也称为序列，此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。

List 接口在 iterator()、add()、remove()、equals() 和 hashCode() 方法的协定上加了一些其他约定，超过了 Collection 接口中指定的约定。

ArrayList 是 List 接口的大小可变数组的实现，是有顺序的，允许重复的元素和null值，初始默认容量为10的，不同步的数组列表容器，底层是数组结构。ArrayList实现了所有可选列表操作，并允许包括null在内的所有元素。除了实现List接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。

## 3.1 创建ArrayList

List<String> list = new ArrayList<String>(50);// 指定初始容量
List<String> list = new ArrayList<String>();// 默认容量10


tips：最好使用多态的写法创建ArrayList，为后期修改提供方便，使用ArrayList list = new ArrayList()方法，优势是会多出一些ArrayList自己特有的方法，缺点是后期一旦改成其他的实现类，如LinkedList，那么你的list类型就也要随之改变，如果其他地方使用着你的list，则也要随之改动，耦合度高，而像List list = new ArrayList()这样面向接口的写法，就可以避免这样的问题。

## 3.2 ArrayList相关API方法

```java
@Test
public void ArrayListTest() {
	// create
	List<String> list1 = new ArrayList<String>();// 初始化
	list1.add("中国"); // 将"中国"追加到列表中
	list1.add("印度"); // 将"印度"追加到列表中
	list1.add(1, "美国");// 将"美国"插入到1号位置，原1号位置依次向后挪

	List<String> list2 = new ArrayList<String>();
	list2.add("加拿大");
	list2.add("英国");
	list1.addAll(list2);// 两个list的合并：将list2中的所有元素追加到list1中

	List<String> list3 = new ArrayList<String>();
	list3.add("日本");
	list3.add("韩国");
	list1.addAll(1, list3);// 两个list的合并：将list3中的所有元素插入到1号位置，原1号位置依次后挪

	// retrieve
	System.out.println(list1.get(5));// 返回list1中5号位的元素
	System.out.println(list1.indexOf("中国"));// 返回list1中第一次出现"中国"的位置
	System.out.println(list1.lastIndexOf("中国"));// 返回list1中最后一次出现"中国"的位置
	System.out.println(list2.equals(list3));// list2和list3元素是否相同
	System.out.println(list1.contains("日本"));// 返回list1中是否包含"日本"
	System.out.println(list1.containsAll(list3));// 返回list1中是否包含与list3相同的内容
	System.out.println(list1.isEmpty());// 返回list1是否为空列表
	System.out.println(list1.size());// 查看返回list1元素个数
	System.out.println(Arrays.toString(list1.toArray()));// 转成Object[]数组，并查看

	// update
	list1.set(0, "中华人民共和国"); // 将0号位置的元素修改为"中华人民共和国"

	// delete
	list1.subList(0, 5);// 从0到5截取，包括左不包括右
	list1.remove(1);// 删除1号位置元素
	list1.remove("印度");// 删除"印度"
	list1.removeAll(list3);// 删除与list3相同的元素
	list1.retainAll(list2);// 删除元素，只剩下与list2相同的元素
	list1.clear();// 将list中的元素都清空
}
```



3.3 Iterator迭代器遍历

接口Iterator本身井非数据结构，但它定义了一种连续地检索数据结构中的元素的方式，是以定义好的顺序遍历一系列元素的标谁方式。迭代器通常被称为“轻量级”对象，因为创建它的代价小。

了解Iterator接口的工作原理将有助于理解其他Java数据结构，它拥有两个比较常用的方法hashNext()和next()。

public boolean hasNext();// 判断结构中是否还包含其他元素，调用该方法来查看是否可以继续遍历结构。
public Object next();// 获得结构中的下一个元素。


tips：如果在调用next()时，结构中已经没有更多的元素，那么next()将引发noSuchElementException异常，为避免产生这种异常，应结合使用hasNext()和next()来确保还有元素可检索。

hasNext()和next()结合遍历List
@Test
public void testIterator() {
	// 准备一个list类型的数据结构
	ArrayList arrayList = new ArrayList();
	arrayList.add("日本");
	arrayList.add("中国");
	arrayList.add("印度");

	Iterator iter = arrayList.iterator();// 将数据结构转换为迭代器对象，初始指针在0号位置，未指向任何元素
	iter.next();// 指针后移一次，指向（1）号元素"日本"
	iter.remove();// 根据指针当前所在位置（1），删除元素"日本"

	while (iter.hasNext()) {// 遍历迭代器中余下的元素
		System.out.println(iter.next());// next()方法返回的是Object
	}
}


迭代器总结：

Java中的Iterator只能单向移动。
"数据结构.iterator()" 方法可以将某个数据结构转换为迭代器对象。
第一次调用Iterator对象的next()方法时，它返回序列的第一个元素。
使用next()获得数据结构中的下一个元素。
使用hasNext()检查数据结构中是否还有元素。
使用remove()将迭代器新返回的元素删除。

3.4 ArrayList遍历

@Test
public void ArrayListIterator() {
	List<String> list = new ArrayList<String>();
	list.add("中国");
	list.add("印度");
	list.add("美国");

	System.out.println("\n\n使用for遍历list...");
	for (int i = 0, j = list.size(); i < j; i++) {
		System.out.print(list.get(i) + "\t");
	}

	System.out.println("\n\n使用foreach遍历list...");
	for (String e : list) {
		System.out.print(e + "\t");
	}

    // ListIterator是List接口提供的特殊的迭代器，是Iterator的子类，只能遍历list，用法和iterator一致
    // ListIterator除了Iterator接口提供的正常操作外，还额外提供了hasPrevious()、previous()、set()等方法
	System.out.println("\n\n使用listIterator遍历list...");
	ListIterator<String> lit1 = list.listIterator();// 获取list迭代器对象，指针置于首位
	while (lit1.hasNext()) {// 如果有下一个元素
		String e = lit1.next();// 获取下一个元素
		if ("中国".equals(e)) {// 如果当前元素是"中国"，则改为"中华人民共和国"
			lit1.set("中华人民共和国");
		}
		if ("印度".equals(e)) {// 如果当前元素是"印度'，则删除这个元素
			lit1.remove();
		}
		System.out.print(e + "\t");// 此时输出的结果仍是["中国 印度 美国"]，但原list中的元素已经改为["中华人民共和国 美国"]
	}

	System.out.println("\n\n使用listIterator反向遍历list...");
	ListIterator<String> lit2 = list.listIterator(2);// 获取list迭代器对象，指针置于2号位置
	while (lit2.hasPrevious()) {// 如果有上一个元素
		System.out.print(lit2.previous() + "\t");// 获取上一个元素并打印
	}
}


练习：请你仿照ArrayList，再配合泛型来写一个访客接待系统，思路如下：

设计 Student 类，用于存放学生信息（属性包括姓名 name 和年龄 age ），充当访客。
设计MyArrayList<T>容器类，用于接待访客。
设计一个 total 属性，用来纪录总访客人数，初始值为0。
设计一个 arrayInitSize 属性，用来纪录初始数组长度，初始值为0。
设计有参构造 MyArrayList(int arrayInitSize)，将参数值赋值给 arrayInitSize 属性，并创建该长度下的访客数组arr。	
设计无参构造 MyArrayList()，设定默认初始数组长度为10。
设计add(T t)方法，负责添加一个访客 t，添加前比较当前访客总人数 total 和数组长度 arr.length 的大小
如果当前访客总人数 total < 数组长度 arr.length：说明数组未满，还有空位置。
直接将新来的访客 t 放到数组中。
如果当前访客总人数 total >= 数组长度arr.length：说明数组装满了，需要扩容后，再追加新访客 t。
新建一个新的数组 arr_temp，长度是之前数组长度+10。
将原数组arr按位复制到新数组 arr_temp 中。
将新来的访客 t 追加到新数组 arr_temp 中。
将新数组的引用 arr_temp 改为原数组的引用 arr。
总访客人数总访客人数 total++。	
提供get(int index)方法，可以通过角标来直接获取访客，获取前比较当前访客总人数 total 和用户目标的角标 index。
如果当前访客总人数 total <= index：说明数组越界，抛异常。
如果当前访客总人数 total > index：说明合理，直接返回数组的第 index 位元素。
测试：添加100个访客，获取第99个访客的信息。

public class MyArrayList<T> {
	private T[] array = null;// 底层数组
	private int total = 0;// 总访客人数

	public MyArrayList() {
		this(10);
	}

	public MyArrayList(int size) {
		array = (T[]) new Object[size];// 创建一个size长度的数组
	}

	/**
	 * 添加访客信息
	 * @param t 待添加的访客
	 */
	public void add(T t) {
		if (total >= array.length) {// 总人数大于等于数组长度，表示数组已满员，需要扩容后才能添加新访客
			T[] arr_temp = (T[]) new Object[array.length + 10];// 创建一个扩容10的新数组
			System.arraycopy(array, 0, arr_temp, 0, array.length);// 将原数组的值按位复制到新数组中
			arr_temp[total] = t;// 追加新访客到数组中
			array = arr_temp;// 将新数组引用赋值给原数组
		} else {// 数组未满
			array[total] = t;// 直接追加新访客到数组中
		}
		total++;// 无论是否扩容，总体访客人数必须加1
	}
	/**
	 * 获取访客信息
	 * @param index 访客所在的角标
	 * @return 对应角标位置的访客
	 */
	public T get(int index) {
		if (total <= index) {// 总人数小于等于目标角标：表示获取访客时数组越界
			throw new IndexOutOfBoundsException("你要的我给不起...");
		} else {
			return array[index];// 返回对应位置的访客
		}
	}
    
    // 测试方法
 	public static void main(String[] args) {
		MyArrayList<Student> list = new MyArrayList<Student>();
		for (int i = 0; i < 100; i++) {// 循环创建100个访客并放入list中
			list.add(new Student("张三" + i, "" + i));
		}
		System.out.println(list.get(99));
		System.out.println(list.get(100));// exception
	}
}
class Student {
	private String name;
	private String age;
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public String getAge() {return age;}
	public void setAge(String age) {this.age = age;}
	public Student(String name, String age) {
		this.name = name;
		this.age = age;
	}
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
}


4. Set与HashSet

# 6. 枚举SET

**概念：** java.util.EnumSet能通过静态方法 `allOf(Week.class)` 将 `Week` 中的所有枚举常量放到 `EnumSet` 中。

**源码：**
```java
EnumSet<Week> weekSet = EnumSet.allOf(Week.class);
for (Week day : weekSet) {
    System.out.print(day.toString() + "\t");
}
```



Set接口和List接口都是Collection的子接口。Set叫做集合 ，List叫做列表。所以它们有大量重复的方法（Collection接口中方法都有），同属于容器类，即支持泛型而且随便装，另外Set不支持重复数据，并且最多包含一个null元素，且set是无序的(注入和输出不同)，且Set不同步。

HashSet底层满足Hash分布，无序不同步，是最常用的一种Set实现类。

@Test
public void test() {
	// 1. hashSet允许null值
	// 2. hashSet不允许重复值（自动去重）
	// 3. hashSet无序（进去的时候跟出来的时候不一样），遵循他自己的顺序（hash分布）
	Set<String> set = new HashSet<>();
    System.out.println(set.hashCode());// 集合.hashCode()返回的是集合中所有元素的hashCode()之和，初始时候没有元素，所以这里打印0
	set.add("赵四");
    System.out.println(set.hashCode());// 集合中存在赵四，所有元素hashCode()之和为1144838
	set.add("赵四");
    System.out.println(set.hashCode());// hashCode()之和仍为1144838，说明set对于重复元素直接忽略
	set.add("刘能");
	set.add("广坤");
	set.add(null);
	for(String e : set) {
		System.out.println(e);
	}
}


HashSet练习题
import java.util.*;
public class WrappedString {
    private String s;
    public WrappedString(String s) { this.s = s; }
    public static void main(String[] args) {
        HashSet<Object> hs = new HashSet<Object>();
        WrappedString ws1 = new WrappedString("aardvark");
        WrappedString ws2 = new WrappedString("aardvark");
        String s1 = new String("aardvark");
        String s2 = new String("aardvark");
        hs.add(ws1); hs.add(ws2); hs.add(s1); hs.add(s2);
        System.out.println(hs.size()); 
    } 
}


A. 0
B. 1
C. 2
D. 3
E. 4
F. Compilation fails.
G. An exception is thrown at runtime.
答案：D tips：hashSet去重复是调用的equals方法，equals方法是继承自Object，是判断内存地址是否相同的。String重写了equals方法，只比较类型和值是否一样。
5. Map与HashMap

# 7. 枚举MAP

**概念：** `java.util.EnumMap` 可以将枚举常量作为 `KEY`，将一个字符串作为 `VALUE`。

**源码：**
```java
EnumMap<Week, String> map = new EnumMap<>(Week.class);
map.put(Week.MON, "星期一");
map.put(Week.TUE, "星期二");
map.put(Week.WED, "星期三");
map.put(Week.THU, "星期四");
map.put(Week.FRI, "星期五");
map.put(Week.SAT, "星期六");
map.put(Week.SUN, "星期日");
    
Set<Map.Entry<Week,String>> set = map.entrySet();
for (Map.Entry<Week,String> e : set){
    System.out.println(e.getKey() + " : " + e.getValue());
}    
```

将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射到一个值。

HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 

HashMap常用API方法
@Test
public void test() {
	Map<String, Object> map = new HashMap<>();

	// create
	map.put("gongzuo", "");
	map.put("gongzuo", "singer");// 相同的key会覆盖，就相当于修改操作
	map.put("job", "singer");// 相同的value无所谓
	map.put("t", null);// HashMap的value允许null
	map.put(null, "k");// HashMap的key允许key
	map.put(null, null);// 相同的null的也会发生覆盖
	Map<String, Object> map2 = new HashMap<String, Object>();
	map2.put("a", 1);
	map2.put("b", 2);
	map.putAll(map2);// putAll代表将另一个Map整合到自己的Map中

	System.out.println(map);// map可以直接打印
	System.out.println(map.get("gongzuo"));// 通过key查询value
	System.out.println(map.containsKey("gongzuo"));// 查询map中是否有指定的key
	System.out.println(map.containsValue("singer"));// 查询map中是否有指定的value
	System.out.println(map.isEmpty());// 查询map是否为空map
	System.out.println(map.size());// 查询map中的键值对个数
	System.out.println(map.values());// 查询map中的所有value的collection集合
	System.out.println(map.keySet());// 查询map中的所有key的set集合

	// 获取map的entrySet形式后遍历map
	Set<Entry<String, Object>> set = map.entrySet();
	for (Entry<String, Object> e : set) {
		System.out.println(e.getKey() + ":" + e.getValue());
	}

	// delete
	map.remove("job");// 根据key删除同key的所有键值对
	map.remove(null);// 如果想删除null，不能加双引号
	map.clear();// 清空所有map中的键值对
}


小练习

t01. 请将map.keySet()的返回值遍历出来，要求带value一齐遍历。
public class Test1 {
    public static void main(String[] args) {

        Map<String,Object> map = new HashMap<String,Object>();
        map.put("a","1");
        map.put("b","2");
        map.put("c","3");

        Set<String> set = map.keySet();
        Iterator<String> it = set.iterator();
        while(it.hasNext()){
            String key = it.next();
            Object value = map.get(key);
            System.out.println(key + ":" + value);
        }
        for (String key : set) {
            Object value = map.get(key);
            System.out.println(key + ":" + value);
        }
    }
}


小练习

t01. "aabawebaaabbeecc"中，出现的次数，如a出现2次，b出现1次...字母和该字母出现的次数之间存在着映射关系，所以可以使用Map集合。

思路提示：

1.将字符串转换成字符数组，因为要对每一个字母进行操作
2.定义一个hashmap
3.遍历字符数组
3-1 将每一个字母作为键去map集合获取
3-2 如果返回null，说明map中还没有这个字母，则可以将该字母和1存入map
3-3 如果返回不是null，说明该字母在map中已经存在，且有了对应次数，那么就获取该次数进行自增，然后将该字母和自增后的次数存入map
3-4 输出

@Test
public void test2() {
	Map<Character, Integer> map = new HashMap<>();
	// a=6 b=4 w=1 e=3 c=2
	char[] chars = "aabawebaaabbeecc".toCharArray();
	Integer value = 0;
	for (Character key : chars) {
		value = map.get(key);
		if (value == null) {
			map.put(key, 1);
		} else {
			map.put(key, ++value);
		}
	}
	System.out.println(map);
}