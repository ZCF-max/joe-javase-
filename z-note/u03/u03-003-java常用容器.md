# 1. Collection容器

概念：容器可以帮助我们更灵活地组织和操纵数据，`java.util.Collection` 包下给我们提供了一些更好的数据结构，它是 `java.lang.Iterable` 接口的一个子接口，提供了一些容器类，子类关系如下图

```
Iterable
    |__Collection
        |__ List
            |__ ArrayList
            |__ LinkedList
            |__ Vector
                |__ Stack
        |__ Queue
        |__ Set
            |__ HashSet
            |__ TreeSet
Map
    |__ HashMap
    |__ HashTable
    |__ TreeMap
```

# 2. List

概念：List是有序的collection，也称为序列，此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。

List 接口在 iterator()、add()、remove()、equals() 和 hashCode() 方法的协定上加了一些其他约定，超过了 Collection 接口中指定的约定。

## 2.1 ArrayList

ArrayList 是 List 接口的大小可变数组的实现，是有顺序的，允许重复的元素和null值，初始默认容量为10的，不同步的数组列表容器，底层是数组结构。ArrayList实现了所有可选列表操作，并允许包括null在内的所有元素。除了实现List接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。

创建ArrayList

List<String> list = new ArrayList<String>(50);// 指定初始容量
List<String> list = new ArrayList<String>();// 默认容量10

tips：最好使用多态的写法创建ArrayList，为后期修改提供方便，使用ArrayList list = new ArrayList()方法，优势是会多出一些ArrayList自己特有的方法，缺点是后期一旦改成其他的实现类，如LinkedList，那么你的list类型就也要随之改变，如果其他地方使用着你的list，则也要随之改动，耦合度高，而像List list = new ArrayList()这样面向接口的写法，就可以避免这样的问题。

ArrayList相关API方法

```java
@Test
public void ArrayListTest() {
	// create
	List<String> list1 = new ArrayList<String>();// 初始化
	list1.add("中国"); // 将"中国"追加到列表中
	list1.add("印度"); // 将"印度"追加到列表中
	list1.add(1, "美国");// 将"美国"插入到1号位置，原1号位置依次向后挪

	List<String> list2 = new ArrayList<String>();
	list2.add("加拿大");
	list2.add("英国");
	list1.addAll(list2);// 两个list的合并：将list2中的所有元素追加到list1中

	List<String> list3 = new ArrayList<String>();
	list3.add("日本");
	list3.add("韩国");
	list1.addAll(1, list3);// 两个list的合并：将list3中的所有元素插入到1号位置，原1号位置依次后挪

	// retrieve
	System.out.println(list1.get(5));// 返回list1中5号位的元素
	System.out.println(list1.indexOf("中国"));// 返回list1中第一次出现"中国"的位置
	System.out.println(list1.lastIndexOf("中国"));// 返回list1中最后一次出现"中国"的位置
	System.out.println(list2.equals(list3));// list2和list3元素是否相同
	System.out.println(list1.contains("日本"));// 返回list1中是否包含"日本"
	System.out.println(list1.containsAll(list3));// 返回list1中是否包含与list3相同的内容
	System.out.println(list1.isEmpty());// 返回list1是否为空列表
	System.out.println(list1.size());// 查看返回list1元素个数
	System.out.println(Arrays.toString(list1.toArray()));// 转成Object[]数组，并查看

	// update
	list1.set(0, "中华人民共和国"); // 将0号位置的元素修改为"中华人民共和国"

	// delete
	list1.subList(0, 5);// 从0到5截取，包括左不包括右
	list1.remove(1);// 删除1号位置元素
	list1.remove("印度");// 删除"印度"
	list1.removeAll(list3);// 删除与list3相同的元素
	list1.retainAll(list2);// 删除元素，只剩下与list2相同的元素
	list1.clear();// 将list中的元素都清空
}
```

ArrayList遍历

```java
@Test
public void ArrayListIterator() {
	List<String> list = new ArrayList<String>();
	list.add("中国");
	list.add("印度");
	list.add("美国");

	System.out.println("\n\n使用for遍历list...");
	for (int i = 0, j = list.size(); i < j; i++) {
		System.out.print(list.get(i) + "\t");
	}

	System.out.println("\n\n使用foreach遍历list...");
	for (String e : list) {
		System.out.print(e + "\t");
	}

    // ListIterator是List接口提供的特殊的迭代器，是Iterator的子类，只能遍历list，用法和iterator一致
    // ListIterator除了Iterator接口提供的正常操作外，还额外提供了hasPrevious()、previous()、set()等方法
	System.out.println("\n\n使用listIterator遍历list...");
	ListIterator<String> lit1 = list.listIterator();// 获取list迭代器对象，指针置于首位
	while (lit1.hasNext()) {// 如果有下一个元素
		String e = lit1.next();// 获取下一个元素
		if ("中国".equals(e)) {// 如果当前元素是"中国"，则改为"中华人民共和国"
			lit1.set("中华人民共和国");
		}
		if ("印度".equals(e)) {// 如果当前元素是"印度'，则删除这个元素
			lit1.remove();
		}
		System.out.print(e + "\t");// 此时输出的结果仍是["中国 印度 美国"]，但原list中的元素已经改为["中华人民共和国 美国"]
	}

	System.out.println("\n\n使用listIterator反向遍历list...");
	ListIterator<String> lit2 = list.listIterator(2);// 获取list迭代器对象，指针置于2号位置
	while (lit2.hasPrevious()) {// 如果有上一个元素
		System.out.print(lit2.previous() + "\t");// 获取上一个元素并打印
	}
}
```

练习：03003-2-4

## 2.2 Iterator迭代器遍历

接口Iterator本身井非数据结构，但它定义了一种连续地检索数据结构中的元素的方式，是以定义好的顺序遍历一系列元素的标谁方式。迭代器通常被称为“轻量级”对象，因为创建它的代价小。

了解Iterator接口的工作原理将有助于理解其他Java数据结构，它拥有两个比较常用的方法hashNext()和next()。

public boolean hasNext();// 判断结构中是否还包含其他元素，调用该方法来查看是否可以继续遍历结构。
public Object next();// 获得结构中的下一个元素。


tips：如果在调用next()时，结构中已经没有更多的元素，那么next()将引发noSuchElementException异常，为避免产生这种异常，应结合使用hasNext()和next()来确保还有元素可检索。

hasNext()和next()结合遍历List
@Test
public void testIterator() {
	// 准备一个list类型的数据结构
	ArrayList arrayList = new ArrayList();
	arrayList.add("日本");
	arrayList.add("中国");
	arrayList.add("印度");

	Iterator iter = arrayList.iterator();// 将数据结构转换为迭代器对象，初始指针在0号位置，未指向任何元素
	iter.next();// 指针后移一次，指向（1）号元素"日本"
	iter.remove();// 根据指针当前所在位置（1），删除元素"日本"

	while (iter.hasNext()) {// 遍历迭代器中余下的元素
		System.out.println(iter.next());// next()方法返回的是Object
	}
}


迭代器总结：

Java中的Iterator只能单向移动。
"数据结构.iterator()" 方法可以将某个数据结构转换为迭代器对象。
第一次调用Iterator对象的next()方法时，它返回序列的第一个元素。
使用next()获得数据结构中的下一个元素。
使用hasNext()检查数据结构中是否还有元素。
使用remove()将迭代器新返回的元素删除。

## 2.3 LinkedList

LinkedList是List接口的链接列表实现，实现了所有可选的列表操作，并且允许所有元素（包括 null），此实现不是同步的。

[常用方法集合]
方法名 功能 备注
push() 头部添加 返回void 等效于addFirst() 1.6
add()addFirst()addLast() 追加头部添加尾部添加 返回boolean 等效于addLast()返回void返回void
offer()offerFirst()offerLast() 追加头部添加尾部添加 返回boolean 1.5返回boolean 1.6返回boolean 1.6
element() 查看头 返回头 空列表抛异常 1.5
get(0)getFirst()getLast() 查看0号元素查看头查看尾 返回指定元素 空列表抛异常返回头 空列表抛异常返回头 空列表抛异常
peek()peekFirst()peekLast() 查看头查看头查看尾 返回头 空列表返回null 1.5返回头 空列表返回null 1.6返回头 空列表返回null 1.6
poll()pollFirst()pollLast() 取走头取走头取走尾 返回头 空列表返回null 1.5返回头 空列表返回null 1.6返回尾 空列表返回null 1.6
set(a,b) a号位置内容修改为b 
pop()remove())remove(0))remove(a))removeFirst()removeLast()removeFirstOccurrence(a)removeLastOccurrence(a) 取走头取走头取走0号元素删除元素a取走头取走尾删除第一次出现的元素a删除最后一次出现的元素a 返回头 空列表抛异常 1.6返回头 空列表抛异常 1.5返回指定元素返回boolean类型返回头 空列表抛异常返回尾 空列表抛异常返回布尔类型返回布尔类型

LinkedList特殊方法测试代码：这里主要使用LinkedList独有的方法，父接口List中的方法同上。
@Test
public void LinkedListTest() {
	LinkedList<String> list = new LinkedList<>();

	// create
	list.add("中国");
	list.add("美国");
	list.add("英国");
	list.add("意大利");
	list.addFirst("德国");// 将元素添加到开头 返回值void
	list.addLast("日本");// 将元素添加到结尾 返回值void
	list.offer("奥地利");// 将元素添加到结尾 返回值是boolean 1.5
	list.offerLast("俄罗斯");// 将元素添加到结尾 返回值是boolean 1.6
	list.offerFirst("乌克兰");// 将元素添加到开头 返回值是boolean 1.6
	list.push("匈牙利");// 等效于addFirst(E)

	// retrieve
	System.out.println(list.get(0));// 获取0号元素
	System.out.println(list.element());// 获取头，不移除头，1.5，空列表抛异常
	System.out.println(list.getFirst());// 返回头 空列表抛异常
	System.out.println(list.getLast());// 返回尾 空列表抛异常
	System.out.println(list.peek());// 获取头，不移除头，1.5，空列表返回null
	System.out.println(list.peekFirst());// 获取头，不移除头，1.6，空列表返回null
	System.out.println(list.peekLast());// 获取尾，不移除尾，1.6，空列表返回null
	System.out.println(list.poll());// 获取头，移除头，1.5，空列表返回null
	System.out.println(list.pollFirst());// 获取头，移除头，1.6，空列表返回null
	System.out.println(list.pollLast());// 获取尾，移除尾，1.6，空列表返回null

	// update
	System.out.println(list.set(1, "法国"));// 修改指定位置的元素，返回原元素

	// delete
	System.out.println(list.pop());// 获取并删除头，等效于removeFirst()，1.6
	System.out.println(list.remove());// 删除头，1.5，返回被删除的元素
	System.out.println(list.remove(0));// 根据角标删除，返回被删除的元素
	System.out.println(list.remove("意大利"));// 根据元素删除，返回boolean类型
	System.out.println(list.removeFirst());// 删除头，返回被删除的元素
	System.out.println(list.removeLast());// 删除尾，返回被删除的元素
	System.out.println(list.removeFirstOccurrence("日本"));// 删除第一次出现的元素，返回布尔类型
	System.out.println(list.removeLastOccurrence("中国"));// 删除最后一次出现的元素，返回布尔类型
}


LinkedList和ArrayList效率比较
ArrayList<Integer> arr1 = new ArrayList<>();

long start1 = System.currentTimeMillis();
for (int i = 0; i < 100000; i++) {
    arr1.add(0, i);
}
long end1 = System.currentTimeMillis();

long start2 = System.currentTimeMillis();
LinkedList<Integer> arr2 = new LinkedList<>();
for (int i = 0; i < 100000; i++) {
    arr2.add(0, i);
}
long end2 = System.currentTimeMillis();

System.out.println("ArrayList用时：" + (end1 - start1));
System.out.println("LinkedList用时：" + (end2 - start2));	


tips：LinkedList的存储机制决定了它比ArrayList更适合大量数据的中间连续插入工作。
tips：链表适合大量的中间插入操作，数组适合大量的中间查询操作。

# 3. Set

Set接口和List接口都是Collection的子接口。Set叫做集合 ，List叫做列表。所以它们有大量重复的方法（Collection接口中方法都有），同属于容器类，即支持泛型而且随便装，另外Set不支持重复数据，并且最多包含一个null元素，且set是无序的(注入和输出不同)，且Set不同步。

## 3.1 HashSet

HashSet底层满足Hash分布，无序不同步，是最常用的一种Set实现类。

```java
@Test
public void test() {
	// 1. hashSet允许null值
	// 2. hashSet不允许重复值（自动去重）
	// 3. hashSet无序（进去的时候跟出来的时候不一样），遵循他自己的顺序（hash分布）
	Set<String> set = new HashSet<>();
    System.out.println(set.hashCode());// 集合.hashCode()返回的是集合中所有元素的hashCode()之和，初始时候没有元素，所以这里打印0
	set.add("赵四");
    System.out.println(set.hashCode());// 集合中存在赵四，所有元素hashCode()之和为1144838
	set.add("赵四");
    System.out.println(set.hashCode());// hashCode()之和仍为1144838，说明set对于重复元素直接忽略
	set.add("刘能");
	set.add("广坤");
	set.add(null);
	for(String e : set) {
		System.out.println(e);
	}
}
```

**练习：** 03003-3

## 3.2 TreeSet

## 3.3 EnumSet

**概念：** java.util.EnumSet能通过静态方法 `allOf(Week.class)` 将 `Week` 中的所有枚举常量放到 `EnumSet` 中。

**源码：**
```java
EnumSet<Week> weekSet = EnumSet.allOf(Week.class);
for (Week day : weekSet) {
    System.out.print(day.toString() + "\t");
}
```

# 4. Map

将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射到一个值。

## 4.1 HashMap

HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 

HashMap常用API方法
@Test
public void test() {
	Map<String, Object> map = new HashMap<>();

	// create
	map.put("gongzuo", "");
	map.put("gongzuo", "singer");// 相同的key会覆盖，就相当于修改操作
	map.put("job", "singer");// 相同的value无所谓
	map.put("t", null);// HashMap的value允许null
	map.put(null, "k");// HashMap的key允许key
	map.put(null, null);// 相同的null的也会发生覆盖
	Map<String, Object> map2 = new HashMap<String, Object>();
	map2.put("a", 1);
	map2.put("b", 2);
	map.putAll(map2);// putAll代表将另一个Map整合到自己的Map中

	System.out.println(map);// map可以直接打印
	System.out.println(map.get("gongzuo"));// 通过key查询value
	System.out.println(map.containsKey("gongzuo"));// 查询map中是否有指定的key
	System.out.println(map.containsValue("singer"));// 查询map中是否有指定的value
	System.out.println(map.isEmpty());// 查询map是否为空map
	System.out.println(map.size());// 查询map中的键值对个数
	System.out.println(map.values());// 查询map中的所有value的collection集合
	System.out.println(map.keySet());// 查询map中的所有key的set集合

	// 获取map的entrySet形式后遍历map
	Set<Entry<String, Object>> set = map.entrySet();
	for (Entry<String, Object> e : set) {
		System.out.println(e.getKey() + ":" + e.getValue());
	}

	// delete
	map.remove("job");// 根据key删除同key的所有键值对
	map.remove(null);// 如果想删除null，不能加双引号
	map.clear();// 清空所有map中的键值对
}

练习 03003-4 

## 4.2 TreeMap

## 4.3 EnumMap

**概念：** `java.util.EnumMap` 可以将枚举常量作为 `KEY`，将一个字符串作为 `VALUE`。

**源码：**
```java
EnumMap<Week, String> map = new EnumMap<>(Week.class);
map.put(Week.MON, "星期一");
map.put(Week.TUE, "星期二");
map.put(Week.WED, "星期三");
map.put(Week.THU, "星期四");
map.put(Week.FRI, "星期五");
map.put(Week.SAT, "星期六");
map.put(Week.SUN, "星期日");
    
Set<Map.Entry<Week,String>> set = map.entrySet();
for (Map.Entry<Week,String> e : set){
    System.out.println(e.getKey() + " : " + e.getValue());
}    
```