# 1. 泛型

**概念：** 泛型的术语意思就是，适用于许多许多的类型，是JDK5引入的概念，实现了参数化类型的概念。
- 设计坐标类，可以操作int类型的坐标值。
- 升级坐标类，可以同时操作int类型，double类型和String类型的坐标。

**测试：** PointTest.java
```java
/**
 * @author JoeZhou
 */
public class PointTest {

    private static class Point {
        private Integer integerX;
        private Integer integerY;

        Integer getIntegerX() {return integerX;}
        void setIntegerX(Integer integerX) {this.integerX = integerX;}
        Integer getIntegerY() {return integerY;}
        void setIntegerY(Integer integerY) {this.integerY = integerY;}
    }

    @Test
    public void build() {
        Point point = new Point();
        point.setIntegerX(10);
        point.setIntegerY(20);
        System.out.println(point.getIntegerX() + " : " + point.getIntegerY());
    }
}
```

## 1.1 菱形语法

**概念：** 泛型声明格式也叫菱形语法，使用菱形语法可以不在坐标类中指定成员的具体类型，而是由外部调用者来决定和显示声明，这样的设计使得类的设计变得更加的灵活和简单。
- 泛型声明：
    - `class 类名<泛型, 泛型, ...>{ }`
    - 构造器名后面不能使用泛型，但是构造器参数可以。
    - 泛型不能使用基本数据类型。
- 泛型使用：
    - 标准写法：`类名<泛型> 实例 = new 类名<泛型>()`
    - 不建议写法：`类名<泛型> 实例 = new 类名()`
    - JDK8写法：`类名<泛型> 实例 = new 类名<>()`
    - 泛型擦除：`类名 实例 = new 类名()`：泛型擦除默认将泛型指定为 `Object`。

**源码：** PointWithGenericTypeTest.java
```java
/**
 * @author JoeZhou
 */
public class PointWithGenericTypeTest {
    
    private static class Point<T> {
        private T x;
        private T y;

        T getX() { return x; }
        void setX(T x) { this.x = x; }
        T getY() { return y; }
        void setY(T y) { this.y = y; }
    }

    @Test
    public void build() {
        Point<String> point = new Point<>();
        point.setX("东经125°42′ - 130°10′");
        point.setY("北纬44°04′ - 46°40′");
        System.out.println(point.getX() + " : " + point.getY());
    }
}
```

## 1.2 泛型检查

**概念：** javac会对程序的泛型进行运行前检查，若泛型使用错误会编译失败，以此来保证程序的健壮性和安全性，而JVM运行代码的时候会忽略掉所有泛型检查以提高运行效率，所以我们可以利用反射（运行时期的技术手段）来越过泛型检查。

**测试：** SkipGenericTypeCheckTest.java
```java
/**
 * @author JoeZhou
 */
public class SkipGenericTypeCheckTest {

    private static class Demo<T> {
        private T value;
        void setValue(T value) { this.value = value; }
        void printValue(){
            System.out.println(value);
        }
    }

    @Test
    public void skipGenericTypeCheckByReflect() throws Exception {
        Demo<String> demo = new Demo<>();
        // demo.setValue(10);// compile fail
        Class<?> klass = demo.getClass();
        Method method = klass.getDeclaredMethod("setValue", Object.class);
        method.invoke(demo, 10);
        demo.printValue();
    }
}
```

## 1.3 方法泛型

**概念：** 泛型除了定义在类上，也可以定义在方法上，方法上的泛型可以直接使用类上声明的泛型符号，也可以自己单独声明自定义的泛型符号，原则如下：
- 静态方法不可以直接使用类上的泛型，因为泛型只有在实例化的过程中才能被确定下来，
- 自定义的方法泛型必须在 `void` 或返回值类型之前使用菱形语法进行定义：
    - `public <V, K> K method(V t, K k){}`
    - `public static <Q> void method(Q q){}`

**测试：** MethodGenericTypeTest.java
```java
/**
 * @author JoeZhou
 */
public class MethodGenericTypeTest<T> {
    private static <V> V method(V v) {
        String result =
                v instanceof Integer ? "type of Integer" :
                v instanceof Double ? "type of Double" :
                v instanceof String ? "type of String" : "type of Others";
        System.out.println("the param is " + result);
        return v;
    }

    @Test
    public void methodGenericType() {
        Integer resultA = MethodGenericTypeTest.method(15);
        Double resultB = MethodGenericTypeTest.method(15.0);
        String resultC = MethodGenericTypeTest.method("15.0");
        System.out.println(resultA + ", " + resultB + ", " + resultC);
    }
}
```

## 1.4 泛型限定

**概念：** 在方法的返回值或参数类型中，我们可以使用一些特殊的泛型声明格式来对入参的泛型进行限定。
- `<?>`：未知类型限定，支持一切泛型。
- `<? super Child>`：只接受Child和Child的父类。
- `<? extends Parent>`：只接受Parent和Parent的子类。

**测试：** GenericTypeLimitTest.java
```java
/**
 * @author JoeZhou
 */
public class GenericTypeLimitTest {

    private static class Person<T> {}
    private static class Parent {}
    private static class Child extends Parent {}

	@Test
	public void genericTypeLimit() {
		Person<Child> personA = new Person<>();
		Person<Parent> personB = new Person<>();
		allLimit(personA);
		allLimit(personB);
		superLimit(personA);
		superLimit(personB);
		extendsLimit(personA);
		extendsLimit(personB);
	}

	private void allLimit(Person<?> person) {}
	private void superLimit(Person<? super Child> person) {}
	private void extendsLimit(Person<? extends Parent> person) {}
}
```

## 1.5 反射泛型

**概念：** `java.lang.reflect` 包中提供了一个参数化类型接口 `ParameterizedType`，它是类型接口 `Type` 的子接口，表示参数化类型（凡是带有泛型的参数类型都属于它的范畴）。
- `Method` 相关API方法：
    - `Type[] getGenericParameterTypes()`：获取方法的所有参数类型及其泛型类型，没有泛型的参数类型也会被获取到。
    - `Type getGenericReturnType()`：获取方法的返回值类型及其泛型类型。
- `Type` 相关API方法：
    - `String getTypeName()`：获取参数类型的类全名。
- `ParameterizedType` 相关API方法：
    - `Type[] getActualTypeArguments()`：获取泛型类型对应的真实java类型。

**源码：** ReflectGenericTypeTest.java
```java
/**
 * @author JoeZhou
 */
public class ReflectGenericTypeTest {

    private static class Demo<T, K> { }

    private Demo<String, Object> method(Demo<Integer, Double> demo) {
        return null;
    }

    private Method method;

    @Before
    public void before() throws NoSuchMethodException {
        method = ReflectGenericTypeTest.class.getDeclaredMethod("method", Demo.class);
    }
}
```

**测试：** ReflectGenericTypeTest.java 中添加
```java
@Test
public void getGenericActualParamTypeOfMethod() {
    for (Type paramType : method.getGenericParameterTypes()) {
        System.out.println(paramType.getTypeName());
        if (paramType instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) paramType;
            for (Type actualParamType : parameterizedType.getActualTypeArguments()) {
                System.out.println("\t" + actualParamType.getTypeName());
            }
        }
    }
}

@Test
public void getGenericActualReturnTypeOfMethod() {
    Type returnType = method.getGenericReturnType();
    if (returnType instanceof ParameterizedType) {
        System.out.println(returnType.getTypeName());
        ParameterizedType parameterizedType = (ParameterizedType) returnType;
        for (Type actualTypeArgument : parameterizedType.getActualTypeArguments()) {
            System.out.println("\t" + actualTypeArgument.getTypeName());
        }
    }
}
```

# 2. 数据结构-链表

概念：链表和数组都是存储数据的一种线性结构，链表就像一条锁链，锁链中的每一个铁环，就可以看做是链表的最基本单位：节点（Node）。
- 链表不定长：在内存中，链表的节点数量是动态分配的，一个链表结构中存在多少个节点，取决于我们向这个链表中添加了多少元素，如果我们想要向这个链表中追加元素或者插入元素，那么我们只要新建一个节点保存这个元素，并且改变几个引用值，就可以完成操作
- 不连续：在每次添加新元素到链表中的时候，链表的节点都是重新new出来的，即使数据类型是一样的，但是他们之间的内存地址也是互相没有关系的，也就是说，即使是存储在同一个链表中的不同节点，他们之间的内存地址也是没有规律，不连续的
- 链表不定长导致增删快，不连续导致遍历慢。

> 整个链表就好比一列火车，头结点就是火车头，火车头是不搭载乘客的；后面的每一个节点就是普通的火车车厢，车厢中的乘客就是节点data数据域保存的数据，而节点的next后继指针域就好比车厢之间的钩子，沿着这个钩子就可以找到下一节车厢；如果一节车厢的钩子没有挂载其他车厢，说明这个车厢已经是最后一节车厢了

## 2.1 单向链表

概念：单链表的每一个节点只有一个next后继指针域，所以在遍历这个链表的时候，只能够单向的从前向后进行遍历，不能够从后向前进行遍历。
- 单链表的节点一般分为两个部分：
    - data数据域，用来存储要保存的数据，例如一个字符串、一个User对象等等。
    - next后继指针域，用来保存下一个节点的内存地址，串起整个链表结构。
- 在链表中，链表的第一个节点通常不存储任何数据，他仅仅用来引起整个链表，我们将这个特殊的节点称之为数组的头结点
- 在整条链表中，我们只要知道了链表头结点的内存地址，就可以顺着之后每一个节点的next后继指针域向下，逐个找到后续的所有节点
- 链表的最后一个节点的后继指针域取值为null，这一特性在遍历整个链表的时候，常用来判断是否还有后继节点

源码：SingleLinkedListDemo.java
```java
public class Node<E> {
    E data;
    Node<E> next;

    Node(E data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "[" + data + "|" + (next == null ? "null" : next.data) + "]";
    }
}
```

## 2.2 双向链表

概念：双向链表的每个节点都由三部分组成，数据域，pre前驱指针和next后继指针，所以在访问其中一个节点的时候，既能够向后找到下一个节点，又能向前找到上一个节点。

```java
public static class Node<E> {
    E data;
    Node<E> next;
    Node<E> pre;

    Node(E data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "[" + (pre == null ? "null" : pre.data)
                + "|" + data + "|"
                + (next == null ? "null" : next.data) + "]";
    }
}
```

## 2.3 循环链表

概念：换链表就是收尾相连的单链表。