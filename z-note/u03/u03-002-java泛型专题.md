# 1. 泛型

**概念：** 泛型的术语意思就是，适用于许多许多的类型，是JDK5引入的概念，实现了参数化类型的概念。
- 设计坐标类，可以操作int类型的坐标值。
- 升级坐标类，可以同时操作int类型，double类型和String类型的坐标。

**测试：** PointTest.java
```java
/**
 * @author JoeZhou
 */
public class PointTest {

    private static class Point {
        private Integer integerX;
        private Integer integerY;

        Integer getIntegerX() {return integerX;}
        void setIntegerX(Integer integerX) {this.integerX = integerX;}
        Integer getIntegerY() {return integerY;}
        void setIntegerY(Integer integerY) {this.integerY = integerY;}
    }

    @Test
    public void build() {
        Point point = new Point();
        point.setIntegerX(10);
        point.setIntegerY(20);
        System.out.println(point.getIntegerX() + " : " + point.getIntegerY());
    }
}
```

## 1.1 菱形语法

**概念：** 泛型声明格式也叫菱形语法，使用菱形语法可以不在坐标类中指定成员的具体类型，而是由外部调用者来决定和显示声明，这样的设计使得类的设计变得更加的灵活和简单。
- 泛型声明：
    - `class 类名<泛型, 泛型, ...>{ }`
    - 构造器名后面不能使用泛型，但是构造器参数可以。
    - 泛型不能使用基本数据类型。
- 泛型使用：
    - 标准写法：`类名<泛型> 实例 = new 类名<泛型>()`
    - 不建议写法：`类名<泛型> 实例 = new 类名()`
    - JDK8写法：`类名<泛型> 实例 = new 类名<>()`
    - 泛型擦除：`类名 实例 = new 类名()`：泛型擦除默认将泛型指定为 `Object`。

**源码：** PointWithGenericTypeTest.java
```java
/**
 * @author JoeZhou
 */
public class PointWithGenericTypeTest {
    
    private static class Point<T> {
        private T x;
        private T y;

        T getX() { return x; }
        void setX(T x) { this.x = x; }
        T getY() { return y; }
        void setY(T y) { this.y = y; }
    }

    @Test
    public void build() {
        Point<String> point = new Point<>();
        point.setX("东经125°42′ - 130°10′");
        point.setY("北纬44°04′ - 46°40′");
        System.out.println(point.getX() + " : " + point.getY());
    }
}
```

## 1.2 泛型检查

概念：
- 一旦使用了泛型设计，就必须要保证使用方传入的参数和设计方规定的参数类型保持完全一致，否则JVM会报错，这样的设计时候为了使类的运行过程更安全，使用更方便。
- 泛型仅仅是给javac看的，在运行时候，JVM会将所有泛型忽略掉，而我们的反射是在程序运行的过程中执行的，所以一般情况下，我们的反射无法看到泛型的存在，反过来想，通过反射的方式，我们可以越过泛型的检查。

**测试：**
```java
public class SkipGenericTypeCheckTest {
	@Test
	public void skipGenericTypeCheckByReflect() throws Exception {
        PointPro<String> point = new Point<>();
        //point.setX(10);// compile fail

		Class<?> klass = point.getClass();
		Method method = klass.getMethod("setX", Object.class);
        method.invoke(point, "东经125°42' - 130°10'");
		System.out.println(point.getX());
	}
}
```

## 1.3 方法泛型

概念：泛型除了定义在类上，也可以定义在方法上：
- 实例方法可以直接使用类上定义的泛型，如： `public void fun(T t){}`
- 静态方法不可以直接使用类上的泛型，因为类加载的时候，先加载静态方法，后加载泛型，导致加载静态方法的并不知道泛型是什么。
- 实例方法和静态方法都可以使用另一个自定义的泛型，但是必须在 `void` 之前使用菱形语法进行定义，如：
    - public <V> void fun(V t){}
    - public static <Q> void fun(Q q){}

测试
```java
public class MethodGenericTypeTest<T> {
	public <V> void method(V t) {
		System.out.println(t instanceof Integer);
	}

	@Test
	public void methodGenericType() {
		MethodGenericTest<String> methodGenericTest = new MethodGenericTest<>();
		methodGenericTest.method(15);
        methodGenericTest.method(15.5);
	}
}
```

## 1.4 泛型限定

概念：在方法和类的定义上，我们可以使用一些特殊的泛型声明格式来对泛型进行限定。
- `<?>` 未知类型限定：只能写在参数中，支持一切泛型。
- `<? super Child>` 只接受Child和Child的父类。
- `<? extends Parent>` 只接受Parent和Parent的子类。

```java
public class GenericTypeLimitTest {

    static class Person<T> {}
    static class Parent {}
    static class Child extends Parent {}

	@Test
	public void genericTypeLimit() {
		Person<Child> personA = new Person<>();
		Person<Parent> personB = new Person<>();
		allLimit(personA);
		allLimit(personB);
		superLimit(personA);
		superLimit(personB);
		extendsLimit(personA);
		extendsLimit(personB);
	}

	private void allLimit(Person<?> person) {}
	private void superLimit(Person<? super Child> person) {}
	private void extendsLimit(Person<? extends Parent> person) {}
}
```

## 1.5 反射泛型

源码：ReflectGenericTypeTest.java
```java
/**
 * @author JoeZhou
 */
public class ReflectGenericTypeTest {
    private static class Demo<T, K> {}
    private Demo<String, Object> method(Demo<Integer, Double> demo) { return null;}
    private Method method;

    @Before
    public void before() throws NoSuchMethodException {
        method = GenericTypeTest.class.getDeclaredMethod("method", Demo.class);
    }
}
```

概念：`java.lang.reflect` 包中提供了一个参数化类型接口 `ParameterizedType`，它是类型接口 `Type` 的子接口，表示带有泛型的参数类型。
- `Method` 相关API方法：
    - `Type[] getGenericParameterTypes()`：获取方法的所有参数类型及其泛型类型，没有泛型的参数类型也会被获取到。
    - `Type getGenericReturnType()`：获取方法的返回值类型及其泛型类型。
- `Type` 相关API方法：
    - `String getTypeName()`：获取参数类型的类全名。
- `ParameterizedType` 相关API方法：
    - `Type[] getActualTypeArguments()`：获取泛型类型对应的真实java类型。

测试：ReflectGenericTypeTest.java 中添加
```java
@Test
public void getGenericActualParamTypeOfMethod() {
    for (Type paramType : method.getGenericParameterTypes()) {
        System.out.println(paramType.getTypeName());
        if (paramType instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) paramType;
            for (Type actualParamType : parameterizedType.getActualTypeArguments()) {
                System.out.println("\t" + actualParamType.getTypeName());
            }
        }
    }
}

@Test
public void getGenericActualReturnTypeOfMethod() {
    Type returnType = method.getGenericReturnType();
    if (returnType instanceof ParameterizedType) {
        System.out.println(returnType.getTypeName());
        ParameterizedType parameterizedType = (ParameterizedType) returnType;
        for (Type actualTypeArgument : parameterizedType.getActualTypeArguments()) {
            System.out.println("\t" + actualTypeArgument.getTypeName());
        }
    }
}
```

# 2. 链表结构

概念：链表和数组都是存储数据的一种线性结构，链表就像一条锁链，锁链中的每一个铁环，就可以看做是链表的最基本单位：节点（Node）
- 链表的内存特性：
    - 不定长：在内存中，链表的节点数量是动态分配的，一个链表结构中存在多少个节点，取决于我们向这个链表中添加了多少元素，如果我们想要向这个链表中追加元素或者插入元素，那么我们只要新建一个节点保存这个元素，并且改变几个引用值，就可以完成操作
    - 不连续：在每次添加新元素到链表中的时候，链表的节点都是重新new出来的，即使数据类型是一样的，但是他们之间的内存地址也是互相没有关系的，也就是说，即使是存储在同一个链表中的不同节点，他们之间的内存地址也是没有规律，不连续的
    - 不定长导致增删快，不连续导致遍历慢。

> 整个链表就好比一列火车，头结点就是火车头，火车头是不搭载乘客的；后面的每一个节点就是普通的火车车厢，车厢中的乘客就是节点data数据域保存的数据，而节点的next后继指针域就好比车厢之间的钩子，沿着这个钩子就可以找到下一节车厢；如果一节车厢的钩子没有挂载其他车厢，说明这个车厢已经是最后一节车厢了

## 2.1 单向链表

概念：单链表的每一个节点只有一个next后继指针域，所以在遍历这个链表的时候，只能够单向的从前向后进行遍历，不能够从后向前进行遍历。
- 单链表的节点一般分为两个部分：
    - data数据域，用来存储要保存的数据，例如一个字符串、一个User对象等等。
    - next后继指针域，用来保存下一个节点的内存地址，串起整个链表结构。
- 在链表中，链表的第一个节点通常不存储任何数据，他仅仅用来引起整个链表，我们将这个特殊的节点称之为数组的头结点
- 在整条链表中，我们只要知道了链表头结点的内存地址，就可以顺着之后每一个节点的next后继指针域向下，逐个找到后续的所有节点
- 链表的最后一个节点的后继指针域取值为null，这一特性在遍历整个链表的时候，常用来判断是否还有后继节点

源码：SingleLinkedListDemo.java
```java
public class Node<E> {
    E data;
    Node<E> next;

    Node(E data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "[" + data + "|" + (next == null ? "null" : next.data) + "]";
    }
}
```

## 2.2 双向链表

概念：双向链表的每个节点都由三部分组成，数据域，pre前驱指针和next后继指针，所以在访问其中一个节点的时候，既能够向后找到下一个节点，又能向前找到上一个节点。

```java
public static class Node<E> {
    E data;
    Node<E> next;
    Node<E> pre;

    Node(E data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "[" + (pre == null ? "null" : pre.data)
                + "|" + data + "|"
                + (next == null ? "null" : next.data) + "]";
    }
}
```

## 2.3 循环链表

概念：换链表就是收尾相连的单链表。