# 1. 泛型

**概念：** 泛型的术语意思就是，适用于许多许多的类型，是JDK5引入的概念，实现了参数化类型的概念。
- 设计坐标类，可以操作int类型的坐标值。
- 升级坐标类，可以同时操作int类型，double类型和String类型的坐标。

**源码：** generic/PointTest.java

## 1.1 菱形语法

**概念：** 泛型声明格式也叫菱形语法，使用菱形语法可以不在坐标类中指定成员的具体类型，而是由外部调用者来决定和显示声明，这样的设计使得类的设计变得更加的灵活和简单。
- 泛型声明：
    - `class 类名<泛型, 泛型, ...>{ }`
    - 构造器名后面不能使用泛型，但是构造器参数可以。
    - 泛型不能使用基本数据类型。
- 泛型使用：
    - 标准写法：`类名<泛型> 实例 = new 类名<泛型>()`
    - 不建议写法：`类名<泛型> 实例 = new 类名()`
    - JDK8写法：`类名<泛型> 实例 = new 类名<>()`
    - 泛型擦除：`类名 实例 = new 类名()`：泛型擦除默认将泛型指定为 `Object`。

**源码：** generic/PointWithGenericTypeTest.java

## 1.2 泛型检查

**概念：** javac会对程序的泛型进行运行前检查，若泛型使用错误会编译失败，以此来保证程序的健壮性和安全性，而JVM运行代码的时候会忽略掉所有泛型检查以提高运行效率，所以我们可以利用反射（运行时期的技术手段）来越过泛型检查。

**源码：** generic/SkipGenericTypeCheckTest.java

## 1.3 方法泛型

**概念：** 泛型除了定义在类上，也可以定义在方法上，方法上的泛型可以直接使用类上声明的泛型符号，也可以自己单独声明自定义的泛型符号，原则如下：
- 静态方法不可以直接使用类上的泛型，因为泛型只有在实例化的过程中才能被确定下来，
- 自定义的方法泛型必须在 `void` 或返回值类型之前使用菱形语法进行定义：
    - `public <V, K> K method(V t, K k){}`
    - `public static <Q> void method(Q q){}`

**源码：** generic/MethodGenericTypeTest.java

## 1.4 泛型限定

**概念：** 在方法的返回值或参数类型中，我们可以使用一些特殊的泛型声明格式来对入参的泛型进行限定。
- `<?>`：未知类型限定，支持一切泛型。
- `<? super Child>`：只接受Child和Child的父类。
- `<? extends Parent>`：只接受Parent和Parent的子类。

**源码：** generic/GenericTypeLimitTest.java

## 1.5 反射泛型

**概念：** `java.lang.reflect` 包中提供了一个参数化类型接口 `ParameterizedType`，它是类型接口 `Type` 的子接口，表示参数化类型（凡是带有泛型的参数类型都属于它的范畴）。
- `Method` 相关API方法：
    - `Type[] getGenericParameterTypes()`：获取方法的所有参数类型及其泛型类型，没有泛型的参数类型也会被获取到。
    - `Type getGenericReturnType()`：获取方法的返回值类型及其泛型类型。
- `Type` 相关API方法：
    - `String getTypeName()`：获取参数类型的类全名。
- `ParameterizedType` 相关API方法：
    - `Type[] getActualTypeArguments()`：获取泛型类型对应的真实java类型。

**源码：** generic/ReflectGenericTypeTest.java

# 2. 数据结构-链表

概念：链表和数组都是存储数据的一种线性结构，链表就像一条锁链，锁链中的每一个铁环，就可以看做是链表的最基本单位：节点（Node）。
- 链表不定长：在内存中，链表的节点数量是动态分配的，一个链表结构中存在多少个节点，取决于我们向这个链表中添加了多少元素，如果我们想要向这个链表中追加元素或者插入元素，那么我们只要新建一个节点保存这个元素，并且改变几个引用值，就可以完成操作
- 不连续：在每次添加新元素到链表中的时候，链表的节点都是重新new出来的，即使数据类型是一样的，但是他们之间的内存地址也是互相没有关系的，也就是说，即使是存储在同一个链表中的不同节点，他们之间的内存地址也是没有规律，不连续的
- 链表不定长导致增删快，不连续导致遍历慢。

> 整个链表就好比一列火车，头结点就是火车头，火车头是不搭载乘客的；后面的每一个节点就是普通的火车车厢，车厢中的乘客就是节点data数据域保存的数据，而节点的next后继指针域就好比车厢之间的钩子，沿着这个钩子就可以找到下一节车厢；如果一节车厢的钩子没有挂载其他车厢，说明这个车厢已经是最后一节车厢了

## 2.1 单向链表

概念：单链表的每一个节点只有一个next后继指针域，所以在遍历这个链表的时候，只能够单向的从前向后进行遍历，不能够从后向前进行遍历。
- 单链表的节点一般分为两个部分：
    - data数据域，用来存储要保存的数据，例如一个字符串、一个User对象等等。
    - next后继指针域，用来保存下一个节点的内存地址，串起整个链表结构。
- 在链表中，链表的第一个节点通常不存储任何数据，他仅仅用来引起整个链表，我们将这个特殊的节点称之为数组的头结点
- 在整条链表中，我们只要知道了链表头结点的内存地址，就可以顺着之后每一个节点的next后继指针域向下，逐个找到后续的所有节点
- 链表的最后一个节点的后继指针域取值为null，这一特性在遍历整个链表的时候，常用来判断是否还有后继节点

**源码：** generic/SingleLinkedListTest.java

## 2.2 双向链表

概念：双向链表的每个节点都由三部分组成，数据域，pre前驱指针和next后继指针，所以在访问其中一个节点的时候，既能够向后找到下一个节点，又能向前找到上一个节点。

**源码：** generic/DoubleLinkedListTest.java

## 2.3 循环链表

概念：换链表就是收尾相连的单链表。

**源码：** generic/CycleLinkedListTest.java

# 3. Stack工具类

**概念：** `java.util.Stack` 类继承自 `Vector` 类，是栈结构的工具类，提供了许多栈结构的API方法：
- `E push(E item)`：将元素推送到此栈结构的栈顶，并返回此元素。
- `E pop()`：移除并返回栈顶元素，对空栈进行此操作，会抛 `EmptyStackException` 异常。
- `E peek()`：返回栈顶元素（不移除），对空栈进行此操作，会抛 `EmptyStackException` 异常。
- `boolean empty()`：测试此栈是否为空。
- `int search(Object o)`：返回o距离栈顶(1)的位置，-1表示o不存在。

**源码：** collection/StackTest.java

# 4. Queue工具类
        
**概念：** `java.util.Queue` 接口继承自 `Collection` 接口，是队列结构的工具接口，提供了许多队列结构的API方法：
- `boolean add(E e)`：将指定的元素加入到对列中，如果添加成功返回true。
- `boolean offer(E e)`：将指定的元素加入到对列中，如果添加成功返回true
    - 当队列有容量限制的时候，此方法通常优于 `add()`。
- `E remove()`：移除并返回队列头元素，对空队进行此操作，会抛 `NoSuchElementException` 异常。
- `E poll()`：移除并返回队列头元素，对空队进行此操作，会返回null。
- `E element()`：返回队列头元素（不移除），对空队列进行此操作，会抛 `NoSuchElementException` 异常。
- `E peek()`：返回队列头元素（不移除），对空队列进行此操作，会返回null。

> 队列通常是以FIFO的方式操作元素的，但是优先级队列或LIFO队列等特殊队列例外。

**源码：** collection/QueueTest.java

