# 5. 处理缓冲流

处理流会在节点流的基础上，对数据进行更丰富的处理，然后再进行传输。

## 5.1 缓冲字节输入流
利用BufferedInputStream中的mark和reset方法，对文件进行中间部分内容读取
@Test
public void bufferedInputStreamTest() throws IOException {
	FileInputStream fis = new FileInputStream("E:\\io\\BT.txt");
	BufferedInputStream bis = new BufferedInputStream(fis, 8192);// p2 : default 8K.

	System.out.println("1b:" + (char) bis.read());// 在1号位置读取一个字节
	System.out.println("2b:" + (char) bis.read());// 在2号位置读取一个字节

	bis.mark(4);// 在3号位置mark，4字节后该mark失效

	System.out.println("3b:" + (char) bis.read());// 在3号位置读取一个字节
	System.out.println("4b:" + (char) bis.read());// 在4号位置读取一个字节
	System.out.println("5b:" + (char) bis.read());// 在5号位置读取一个字节
	System.out.println("6b:" + (char) bis.read());// 在6号位置读取一个字节

	bis.reset();// 回到标记的3号位置

	System.out.println("3b:" + (char) bis.read());// 在3号位置读取一个字节
	System.out.println("4b:" + (char) bis.read());// 在4号位置读取一个字节
	System.out.println("5b:" + (char) bis.read());// 在5号位置读取一个字节
	System.out.println("6b:" + (char) bis.read());// 在6号位置读取一个字节

	bis.close();
}


tips：mark()方法标记的位置，只取决于这行代码被调用时，fis中指针的位置，或者理解为这行代码的位置，跟参数无关。
tips：mark()方法的参数是一个以字节为单位的标记有效期，比如4，代表从标记开始，4个字节内，标记都有效，如果读了5个字节，mark()标记失效，reset()方法将会报错。
tips：mark()方法的有效期不仅仅取决于它的参数，还取决于BufferedInputStream()的缓存，默认8K，两个值，谁大走谁，比如mark(5)，但是BufferedInputStream()的缓存是8192字节，所以读的字节没超过8192字节，都生效。

## 5.2 缓冲字节输出流
利用BufferedOutputStream对一个文件写入10个A
@Test
public void BufferedOutputStreamTest() throws IOException {
	FileOutputStream fos = new FileOutputStream("E:\\io\\BO2.txt");
	BufferedOutputStream bos = new BufferedOutputStream(fos);

	for (int i = 0; i < 10; i++) {
        // 如果写入数字，会转成unicode码
		bos.write('A');
	}

	bos.flush();
	bos.close();
}


## 5.3 缓冲字符输入流
利用BufferedReader中的readline方法一行一行地读取自身文件，并输出在控制台上
@Test
public void BufferedReaderTest() throws IOException {
	FileReader fr = new FileReader("D:\\...\\处理_缓冲流.java");
    // 在FileReader外套一层BufferedReader
	BufferedReader br = new BufferedReader(fr);
	String str = null;
    // BufferedReader中有readLine()方法，可以按行读取
	while((str = br.readLine()) != null) {
		System.out.println(str);
	}
	br.close();
}


## 5.4 缓冲字符输出流
利用BufferedWriter向文件写入100个随机数，每个随机数占据一行
@Test
public void bufferedWriterTest() throws IOException {
	FileWriter fw = new FileWriter("E:\\io\\random.txt");
	BufferedWriter bw = new BufferedWriter(fw);

    Random random = new Random();
    for (int i = 0, j = 100; i < j; i++) {
        
        // BufferedWriter支持写入字符串
        bw.write("" + (random.nextInt(100)));
        
        // newLine()可以换行
        bw.newLine();
    }
    
	bw.flush();
	bw.close();
}

练习：03003-4

# 6. 处理转换流

我们可以利用处理转换流将字节流转换成对应的字符流（inputStream-Reader，outputStream-Writer）。

## 6.1 输入转换流
利用InputStreamReader模拟Scanner键入输出，使用readLine()方法读取控制台信息
@Test
public void inputStreamReaderTest() throws IOException {
    
    // System.in本身就是InputStream类型
	InputStreamReader isr = new InputStreamReader(System.in);
	BufferedReader br = new BufferedReader(isr);
	String str;
	while ((str = br.readLine()) != null) {
		System.out.println(">> " + str);
	}
    br.close();
}


tips：Idea中的Junit和System.in或者Scanner有冲突，请换成main方法测试。

## 6.2 输出转换流
@Test
public void outputStreamWriterTest() throws IOException {
    
    // true代表追加
	FileOutputStream fos = new FileOutputStream("E:\\io\\osw.txt", true);
 
    // 将FileOutputStream转成Writer
	OutputStreamWriter osw = new OutputStreamWriter(fos);
	osw.write("你好");
 
    // utf8
	System.out.println(osw.getEncoding());
	osw.flush();

    // 第二个参数可以控制编码
	osw = new OutputStreamWriter(fos, "GBK");
	osw.write("世界");
 
    // gbk
	System.out.println(osw.getEncoding());
	osw.flush();
	osw.close();
}


# 7. 处理打印流

打印流是输出语句的底层结构，无需抛出IO异常，且自带flush效果。

## 7.1 打印字节流
利用继承自OutputStream的PrintStream，重新定义输出打印语句的效果
public class Text_PrintStream {
	public static void main(String[] args) throws FileNotFoundException {
		PrintStream ps = new PrintStream(new FileOutputStream("D:\\JavaDir\\IO\\Text_PrintStream.dat"));
		// 重新定义输出语句中的out，让其从默认指向控制台改为指向ps绑定的文件上
		System.setOut(ps);
		// 利用新的输出语句，将unicode前128个打印在文件中
		for (int i = 0; i < 128; i++) {
			System.out.print((char) i + " ");
		}
		ps.close();
	}
}


如果修改out指定之后，需要回复原来的指向(控制台)，则需要在setOut()之前，对System.out进行备份，然后再使用新指定之后，再次调用setOut()来还原备份。
PrintStream preOut = System.out;// 默认值备份
System.setOut(preOut);// 还原备份


tips：System.out和System.err都能重定向到别的输出流中输出，此时控制台console区域不输出内容。

## 7.2 打印字符流
使用PrintWriter创建一个日志文件，模拟Log4j（java的日志文件）工作
@Test
public void printWriterTest() throws IOException {
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	FileWriter fw = new FileWriter("E:\\io\\日志.log", true);
	PrintWriter pw = new PrintWriter(fw);
	String str = null;
	while ((str = br.readLine()) != null) {
		if ("q".equalsIgnoreCase(str)) {
			break;
		}
		pw.println(str);
	}
	pw.println("LOGGING AT " + new Date());
    br.close();
	pw.close();
}


tips：idea中，junit和scanner冲突，测试请使用main方法。