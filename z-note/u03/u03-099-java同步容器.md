# 1. 同步容器List

## 1.1 Vector

**概念：** Vector类称为向量类或矢量类，可以实现可扩容的数组，支持使用索引进行访问，Vector的容量可以根据需要增大或缩小。
- 构造：可以在构造向量的时候指定初始容量和默认增量。
    - `new Vector()`：默认初始容量为10，默认增量为0。
    - `new Vector(10)`：指定初始容量为，默认增量为0。
    - `new Vector(10, 5)`：指定初始容量和满容后的增量。
    - 增量越小，内存管理的效率越高，但执行开销越大，因为执行内存分配的次数将越多。
    - 增量越大，执行内存分配的次数将越少，但如果没有用完分配的所有空间，将浪费内存。
- 方法：
    - `boolean add(E e)`：尾部追加一个元素。
    - `void add(int index, E element)`：在index位置插入一个元素。
    - `E set(int index, E element)`：将index位置上的元素修改为E。
    - `int capacity()`：返回向量的最大容量。
    - `int size()`：返回向量中当前元素的个数。
    - `boolean contains(Object o)`：返回向量中是否包含元素o。
    - `int indexOf(Object o)`：返回向量中元素o所在的位置，不存在返回-1。
    - `boolean removeElement(Object obj)`：删除向量中指定的元素。
    - `E remove(int index)`：返回并删除向量中index位置上的元素。
    - `void clear()`：删除向量中所有的元素。

**测试：** thread/collection/SynchronizedListTest.vectorByDebug()

## 1.2 SynchronizedList

**概念：** Collections中提供了一个方法可以将异步的List容器转换成一个同步的List容器：
- 方法：`static <T> List<T> synchronizedList(List<T> list)`

**测试：** thread/collection/SynchronizedListTest.synchronizedList()

## 1.3 CopyOnWriteArrayList

**概念：** CopyOnWriteArrayList的特点是写时进行加锁复制，读时不加锁，适用于读线程远远多于写线程的情景。

**测试：** thread/collection/SynchronizedListTest.copyOnWriteArrayList()

# 2. 同步容器Map

## 2.1 Hashtable

**概念：** Hashtable中的大部分方法都是线程同步的，而且不支持null值，其余和HashMap的使用相似。

**测试：** thread/collection/SynchronizedMapTest.hashtable()

## 2.2 SynchronizedHashMap

**概念：** Collections中提供了一个方法可以将异步的Map容器转换成一个同步的Map容器：
- 方法：`static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)`

**测试：** thread/collection/SynchronizedListTest.synchronizedHashMap()

## 2.3 ConcurrentHashMap

**概念：** ConcurrentHashMap采用分段锁的技术，适用于并发量比较高的情况。
- ConcurrentHashMap底层使用的是Node数组 + 链表 + 红黑树的结构完成的。
- ConcurrentHashMap在添加元素的时候，会根据key值的hash值决定放到Node数组的哪个位置，取出元素的时候也会在相应的位置上取出值。
    - key值的hash值相同的时候，会在Node数组的某位置上形成链表。
    - Node数组的某位置上的链表过长时（大于8），会被转换成红黑树结构。
- `put(K, V)`: 计算key的哈希值，并判断是否hash冲突：
    - 如果不冲突：直接CAS插入数组对应位置。
    - 如果冲突：加锁插入到数组对应位置上的链表或红黑树的尾部。

**测试：** thread/collection/SynchronizedListTest.concurrentHashMap()

## 2.4 ConcurrentSkipListMap

**概念：** ConcurrentSkipListMap底层使用的是跳表数据结构，在高并发情况下可以更快速的找到元素，且它可以排序，用于替代concurrentTreeMap（不存在，因为树结构的CAS太复杂）。

**测试：** thread/collection/SynchronizedListTest.concurrentSkipListMap()

# 3. 同步容器Queue

## ConcurrentLinkedQueue
## LinkedBlockingDeque
## ArrayBlockingQueue
## DelayQueue
## SynchronousQueue
## TransferQueue
