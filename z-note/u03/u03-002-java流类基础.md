# 1. I/O流概念入门

**概念：** 大多数的应用程序都需要与外部设备（磁盘、硬盘和网络等）进行数据交换，I/O流指的就是应用程序和这些设备之间的各种各样的数据交换方式，我们可以将他们理解为一根根功能各异的"管道"。
- 流的分类：
    - 按方向：输入流/输出流，也称读流/写流，都是站在程序代码的角度来辨别方向。
    - 按处理数据方式：字节流/字符流，字节流以二进制方式进行数据传输，字符流是以字符为单位进行数据传输。
    - 按功能：节点流/处理流，节点流是对数据直传输，处理流会在数据传输过程中对数据进行二次处理后再传输。
- java中有很多负责I/O数据交换的类，都在 `java.io` 包中：
    - File：表示文件本身的类。
    - RandomAccessFile：表示允许随机位置访问的文件本身的类。
    - InputStream：表示输入字节流的抽象类。
    - OutputStream：表示输出字节流的抽象类。
    - Reader：表示输入字符流的抽象类。
    - Writer：表示输出字符流的抽象类。

> 带有中文的纯文本内容推荐使用字符流，图片，影音等二进制内容推荐使用字节流。

# 2. File类

**概念：** File类是I/O包中唯一代表硬盘文件本身的类，通过它可以对文件进行创建，删除，重命名，设置读写权限等操作。
- 构造器：`new File(String filename)`
    - java种的路径支持 `UNIX` 和 `WINDOWS/DOS` 约定的路径分隔符 `/` 和 `\\` 这两种写法。
- 常用API方法：
    - `boolean exists()`：判断文件/目录是否存在。
    - `boolean mkdir()`：创建单层目录。 
    - `boolean mkdirs()`：创建多层目录。
    - `void delete()`：删除文件/目录，彻底删除，不进回收站，删除文件夹的前提是，文件夹是空文件夹。
    - `void deleteOnExit()`：在JVM终止时删除文件，只有在JVM正常终止时，才会尝试执行删除操作。
    - `boolean createNewFile()`：创建一个文件。
    - `String getName()`：得到文件/目录的名称。 
    - `String getPath()`：得到文件/目录的路径。 
    - `long length()`：得到文件字节数。
    - `String getParent()`：返回父目录的路径名，没有父目录返回null。
    - `long lastModified()`：返回文件最后一次被修改的时间戳，文件不存在或发生异常都会返回0L。    
    - `boolean canRead()`：判断文件是否可读（能查看但是不能操作和存储）。
    - `boolean canWrite()`：判断文件是否可写（能写入但是看不见）。
    - `boolean isFile()`：判断文件是否是文件。
    - `boolean isDirectory()`：判断文件是否是目录。
    - `boolean isHidden()`：返回文件是否是一个隐藏文件。
    - `boolean isAbsolute`：返回文件是否是绝对路径（从盘符出发就是绝对路径）。
    - `String getAbsolutePath()`：返回文件的绝对路径。
    - `boolean renameTo(File file)`：重命名为新的file实例的名字注意参数中的file实例不要创建出来。
    - `boolean equals(File file)`：判断文件/目录是否是同一个。

**测试：** FileTest.java
```java
/**
 * @author JoeZhou
 */
public class FileTest {

    private File file;

    @Before
    public void before() throws IOException {
        String pathDirs = "D:\\java\\io";
        File dirs = new File(pathDirs);
        if (!dirs.exists()) {
            System.out.println(dirs.mkdirs() ? "目录创建成功" : "目录创建失败");
        }
        String pathname = pathDirs + "\\start.txt";
        this.file = new File(pathname);
        if (this.file.exists()) {
            System.out.println(this.file.delete() ? "文件删除成功" : "文件删除失败");
        }
        System.out.println(this.file.createNewFile() ? "文件创建成功" : "文件创建失败");
    }

    @Test
    public void fileApi() {
        System.out.println("文件名：" + file.getName());
        System.out.println("文件路径：" + file.getPath());
        System.out.println("文件大小：" + file.length());
        System.out.println("父目录：" + file.getParent());
        System.out.println("最后修改日期：" + new Date(file.lastModified()));
        System.out.println(file.canRead() ? "可读" : "不可读");
        System.out.println(file.canWrite() ? "可写" : "不可写");
        System.out.println(file.isFile() ? "是文件" : "不是文件");
        System.out.println(file.isDirectory() ? "是目录" : "不是目录");
        System.out.println(file.isHidden() ? "隐藏文件" : "非隐藏文件");
        System.out.println(file.isAbsolute() ? "是绝对路径" : "不是绝对路径");
        System.out.println("文件绝对路径：" + file.getAbsolutePath());
        File newFile = new File("D:\\java\\io\\build-1.txt");
        System.out.println(file.renameTo(newFile) ? "修改成功" : "修改失败");
        System.out.println(file.equals(newFile) ? "是同一个" : "非同一个");
    }
}
```

**练习：** 03002-2

# 3. RandomAccessFile类

**概念：** RandomAccessFile可以从指定的位置开始访问一个文件，它具有一个位置指示器，负责指向当前读写处的位置，默认位置是文件的开头，我们可以自己设定指示器的初始位置，读写n个字节后，指示器指向n个字节后的下一个字节处。
- 构造器：`new RandomAccessFile(String name, String mode)`
        - p1：文件路径，如果文件不存在会帮忙创建，但是如果目录不存在直接报错。
        - p2：文件读写模式，`r` 表示只读，`rw` 表示读写。
- 常用API方法：
    - `final void writeUTF(String str)`：写入一个字符串。
        - UTF-8编码下一个字符占3个字节，GBK编码下一个字符占2个字节。
        - writeUTF()会首先把指定字符串的总字节数写进前2个字节，故6个字节的数据其实占了8字节的空间。
    - `final void writeInt(int v)`：写入一个int类型值。
    - `void seek(long pos)`：设置位置指示器的位置。
    - `void skipBytes(int n)`：位置指示器向后移动n个字节（跳过n个字节）。
    - `final String readUTF()`：读取一个字符串。
    - `final int readInt()`：读取一个int类型值。
    - `void close()`：关闭RandomAccessFile，节省内存资源。

> RandomAccessFile仅限于操作文件，不能访问其他IO设备，如网络，内存映像等。

**测试：** 使用同一个RandomAccessFile对象对一个文件完成三个员工信息（姓名和年龄）的按顺序写和按顺序读，且在输出过程种，跳过赵四的年龄。
```java
/**
 * @author JoeZhou
 */
public class RandomAccessFileTest {

    private RandomAccessFile randomAccessFile;

    @Before
    public void before() throws IOException {
        randomAccessFile = new RandomAccessFile("D:\\java\\io\\emp.txt", "rw");
        randomAccessFile.writeUTF("赵四");
        randomAccessFile.writeInt(18);
        randomAccessFile.writeUTF("刘能");
        randomAccessFile.writeInt(28);
        randomAccessFile.writeUTF("广坤");
        randomAccessFile.writeInt(38);
    }

    @After
    public void after() throws IOException {
        randomAccessFile.close();
    }

    @Test
    public void write() throws IOException {

        // 位置指示器重置于0号位
        randomAccessFile.seek(0);
        System.out.print(randomAccessFile.readUTF() + "\t");

        // 跳过赵四的年龄
        randomAccessFile.skipBytes(4);
        System.out.print(randomAccessFile.readUTF() + "\t");
        System.out.print(randomAccessFile.readInt() + "\t");
        System.out.print(randomAccessFile.readUTF() + "\t");
        System.out.print(randomAccessFile.readInt() + "\n");
    }
}
```

> java.io.EOFException 异常在某个文件已经到末尾了，你仍然在读取时爆发。

**练习：** 03002-3

# 3. 文件节点流

节点流是对数据的直传输，中间不涉及任何数据的处理。

## 4.1 文件字节输入流
利用FileInputStream将自身文件输出在控制台，并计算总字节数
@Test
public void FileInputStreamTest() throws IOException {
    
    // 文件路径，支持"/"和"\\"
	String filePath = "****.java";
 
    // 将FileInputStream管插在你要操作的文件上
	FileInputStream fis = new FileInputStream(filePath);
 
    // 查看可见（还剩下的）总字节数
	System.out.println("总字节数：" + fis.available());
 
    // 定义一个中间变量，负责接收每次循环出来的字节
	int b;
	while ((b = fis.read()) != -1) {
        // 将数字转换为char值
		System.out.print((char) b);
	}
    
	fis.close();
}


## 4.2 文件字节输出流
利用FileInputStream和FileOutputStream，将HelloWorld.txt文件内容copy到某HolloWorld.java文件中
@Test
public void FileOutputStreamTest() throws IOException {
    
    // 输入流
	FileInputStream fis = new FileInputStream("E:\\io\\HelloWorld.txt");
 
    // 输出流，要输出的文件路径如果没有程序会帮忙创建
	FileOutputStream fos = new FileOutputStream("E:\\io\\HelloWorld.java");

	int b;
 
    // 从HelloWorld.txt输入一个，往HelloWorld.java输出一个
	while ((b = fis.read()) != -1) {
		fos.write(b);
	}

    // 冲刷管道中残留数据
	fos.flush();
	fos.close();
	fis.close();

	System.out.println("copy over...");
}


tips：FileOutputStream()第二个参数默认false，如果改为true，则每次写入，代表追加，否则代表覆盖原来的值。

## 4.3 文件字符输入流
利用FileReader将包含中文的自身文件输出在控制台
@Test
public void readerTest() throws IOException {
	String path = "****.java";
	FileReader fr = new FileReader(path);

	int b = -1;
	while ((b = fr.read()) != -1) {
		System.out.print((char) b);
	}

	fr.close();
}


## 4.4 文件字符输出流
利用FileWriter制作一个文件Unicode.dat
@Test
public void writerTest() throws IOException {
	FileWriter fw = new FileWriter("E:\\io\\unicode.dat");

    // unicode码最大值65535
	for(int i = 0, j = 65535; i < j; i++) {
		fw.write(i);
	}
	
	fw.flush();
	fw.close();
}