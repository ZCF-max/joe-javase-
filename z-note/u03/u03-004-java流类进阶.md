# 1. 数据流

**概念：** 数据流支持以类型为单位读取和写入数据。
- `DataInputStream`：数据输入字节流，是InputStream的子类。
    - 构造器：`DataInputStream(InputStream in)`
    - 常用API方法：
        - `readDouble()`：从输入流中读取一个double类型的数据。
        - `readBoolean()`：从输入流中读取一个boolean类型的数据。
        - `readInt()`：：从输入流中读取一个int类型的数据。
- `DataOutputStream`：数据输出字节流，是OutputStream的子类。
    - 构造器：`DataOutputStream(OutputStream out)`
    - 常用API方法：
        - `writeDouble()`：写一个double类型的数据到输出流中。
        - `writeBoolean()`：写一个boolean类型的数据到输出流中。
        - `writeInt()`：：写一个int类型的数据到输出流中。

**练习：** 将一个int，一个boolean和一个double写入文件 `a.txt` 后读出来。
```java
/**
 * @author JoeZhou
 */
public class DataSeriesTest {

    private String filePath = "D:" + File.separator + "java-io" + File.separator + "a.txt";

    @Test
    public void dataInputStream() {
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(filePath));
             DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {
            
            dos.writeInt(250);
            dos.writeBoolean(true);
            dos.writeDouble(3.14);
            dos.flush();
            
            System.out.println(dis.readInt());
            System.out.println(dis.readBoolean());
            System.out.println(dis.readDouble());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

# 2. 对象流

**概念：** 对象流可以传输一个类对象，但要求该类必须是一个可序列化的类。
- ObjectOuputStream
- ObjectInputStream

**测试：** 将 `Student.java` 传输至硬盘文件，然后读取回来。
```java
/**
 * @author JoeZhou
 */
public class ObjectSeriesTest {

    @Test
    public void ObjectStream() {
        
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("E:\\io\\student.txt"));
        oos.writeObject(new Student("赵四",58));
        // 对象输入流
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("E:\\io\\student.txt"));
  
        System.out.println(ois.readObject());
        oos.flush();
        oos.close();
        ois.close();
    }
}

class Student implements Serializable {
	private String name;
    
    /**属性不参与序列化过程，值不可见(为默认值)*/
	private transient Integer age;
 	
    public Student(String name, Integer age) {
		this.name = name;
		this.age = age;
	}

 	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Integer getAge() {return age;}
	public void setAge(Integer age) {this.age = age;}
}
```

# 3. 原型模式

原型模式就是java中的克隆技术，以某个实例为原型，克隆出一个新的实例，新实例具有原实例的属性值，这样的做法效率很高，因为不需要执行构造器，也不需要为属性赋值等。

克隆不等于new，因为new出来的新实例，所有属性都是默认值，这不叫克隆。

克隆出来的对象可以进行改变，且不会影响到原实例。

想要实现原型模式，必须让你的原实例实现Cloneable接口（否则抛出CloneNotSupportedException异常），并直接或间接使用Object中的clone()方法，Cloneable是一个标记接口，标识某个类为“可克隆的”。

羊类
package com.gof23.原型模式;
import java.util.Date;

public class Sheep implements Cloneable {
	private String name;
	private Date birth;

    public Sheep shallowClone(Sheep sheep) {
    	Sheep result = null;
    	try {
    		result = (Sheep)super.clone();// 使用Object中的clone方法进行克隆
    	} catch (CloneNotSupportedException e) {
    		e.printStackTrace();
    	}
    	return result;
    }

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Date getBirth() {return birth;}
	public void setBirth(Date birth) {this.birth = birth;}
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void shallowCloneTest() throws CloneNotSupportedException {
    Date birth = new Date(111111111111L);// 定义一个时间对象
    Sheep dorset = new Sheep();// 创建Dorset羊
    dorset.setName("Dorset");
    dorset.setBirth(birth);
    Sheep dolly = dorset.shallowClone(dorset);// 根据Dorset羊克隆一个dolly羊
    dolly.setName("dolly");// 对dolly羊重新设置名字
    System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
    birth.setTime(999999999999L);// 改变date对象的值
    System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth值造成了影响
}


上面的例子你会发现，Object中的clone可以完成实例的克隆，但是两个实例的birth属性仍然指向同一个Date，当我对Date进行改变的时候，两只羊的birth属性值会同时发生改变，这种克隆，我们叫它浅复制，如果克隆时，所有的属性也都被克隆一份，就叫做深克隆（深复制）。

深克隆：深克隆的是实现实际上是对对象的序列化和反序列化，所以需要让你的被克隆类实现序列化接口。
// 本次实现深克隆使用 ByteArrayOutputStream 和 ByteArrayInputStream 作为克隆过程中字符数组存储中介
public Sheep deepClone(Sheep sheep) {
	Sheep result = null;
	ByteArrayOutputStream bos = null;
	ObjectOutputStream oos = null;
	ObjectInputStream ois = null;
	try {
		bos = new ByteArrayOutputStream();
		oos = new ObjectOutputStream(bos);
		oos.writeObject(sheep);// 将传入参数sheep类写入bos中
		// 将读取到数据传入ObjectInputStream
		ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
		result = (Sheep) ois.readObject();
	} catch (IOException | ClassNotFoundException e) {
		e.printStackTrace();
	} finally {
		try {
			bos.close();
			oos.close();
			ois.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	return result;
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void deepCloneTest() throws CloneNotSupportedException, ClassNotFoundException, IOException {
	Date birth = new Date(111111111111L);// 定义一个时间对象
	Sheep dorset = new Sheep();// 创建Dorset羊
	dorset.setName("Dorset");
	dorset.setBirth(birth);
	Sheep dolly = dorset.deepClone(dorset);// 根据Dorset羊克隆一个dolly羊
	dolly.setName("dolly");// 对dolly羊重新设置名字
	System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
	birth.setTime(999999999999L);// 改变date对象的值
	System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth没有造成影响
}


还有一种更简单的方式实现深克隆（此时不用实现序列化接口），就是在你的深克隆方法体中，将Date属性再浅克隆一次。
public Sheep deepClone(Sheep sheep) {
    Date birth = (Date)sheep.getBirth().clone();
    sheep.setBirth(birth);
    return sheep;
}


tips：这种方式需要把所有引用属性都重新浅克隆一遍，当引用属性比较多的时候不适用。

总结：

浅克隆：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象，就像你和你的影子，你完蛋，你的影子也完蛋。
深克隆：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。就像你和你的克隆人，你完蛋，你的克隆人还活着。