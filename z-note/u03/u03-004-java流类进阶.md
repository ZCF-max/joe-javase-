# 8. 处理数据流

需求：在内存中创造一个虚拟的字节数组，向字节数组中写入一个double一个boolean并读出来。

数据输入字节流：DataInputStream extends InputStream
数据输出字节流：DataOutputStream extends OutputStream
字节数组输入字节流：ByteArrayInputStream extends InputStream
字节数组输出字节流：ByteArrayOutputStream extends OutputSteam

图：处理数据流

@Test
public void dataOutputStreamTest() throws IOException {
	// 在内存中创造一个虚拟的字节数组，并插一根字节数组输出流管(baos)，准备往里面写数据
	ByteArrayOutputStream baos = new ByteArrayOutputStream();
	
	// 在baos外层嵌套数据输出流管(dos)，因为想使用它的writeDouble()、writeInt()等便捷方法写数据
	DataOutputStream dos = new DataOutputStream(baos);
	
	// 写：使用DataOutputStream中的便捷方法向内存数组中写数据
	dos.writeDouble(3.14);
	dos.writeBoolean(true);
	dos.writeInt(250);
	dos.flush();
	
	// 读：内存中的字节数组没有名字，我们只能从节数组输入流管(baos)中读数据
	// ByteArrayInputStream()的构造方法中只支持字节数组参数，所有我们需要将baos转成字节数组
	ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
	
	// 在bais外层嵌套数据输入流管(dis)，因为想使用它的readDouble()、readInt()等便捷方法读数据
	DataInputStream dis = new DataInputStream(bais);
	
	// 读：使用DataInputStream中的便捷方法从内存数组中读数据
	System.out.println(dis.readDouble());
	System.out.println(dis.readBoolean());
	System.out.println(dis.readInt());
	
	dos.close();
	dis.close();
}

# 9. 处理对象流

ObjectOuputStream和ObjectInputStream可以实现对可序列化类对象的传输。
public class 处理_对象流 {
	@Test
	public void ObjectStreamTest() throws IOException, ClassNotFoundException {

        // 对象输出流
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("E:\\io\\student.txt"));

        // 新建一个对象，并将对象写到文件中
		oos.writeObject(new Student("赵四",58));

        // 对象输入流
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("E:\\io\\student.txt"));
  
        // 从文件中读取对象，并查看
		System.out.println(ois.readObject());

		oos.flush();
		oos.close();
		ois.close();
	}
}

/**
 * Serializable没有任何方法 就是告诉虚拟机这是一个可序列化的类，可以被传输 这种接口称为标记接口
 */
@SuppressWarnings("serial")
class Student implements Serializable {
	private String name;
	private transient Integer age;// 被修饰的属性不参与序列化过程，值不可见(为默认值)
 	
    public Student(String name, Integer age) {
		this.name = name;
		this.age = age;
	}
 	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Integer getAge() {return age;}
	public void setAge(Integer age) {this.age = age;}
}

# 10. 原型模式

原型模式就是java中的克隆技术，以某个实例为原型，克隆出一个新的实例，新实例具有原实例的属性值，这样的做法效率很高，因为不需要执行构造器，也不需要为属性赋值等。

克隆不等于new，因为new出来的新实例，所有属性都是默认值，这不叫克隆。

克隆出来的对象可以进行改变，且不会影响到原实例。

想要实现原型模式，必须让你的原实例实现Cloneable接口（否则抛出CloneNotSupportedException异常），并直接或间接使用Object中的clone()方法，Cloneable是一个标记接口，标识某个类为“可克隆的”。

羊类
package com.gof23.原型模式;
import java.util.Date;

public class Sheep implements Cloneable {
	private String name;
	private Date birth;

    public Sheep shallowClone(Sheep sheep) {
    	Sheep result = null;
    	try {
    		result = (Sheep)super.clone();// 使用Object中的clone方法进行克隆
    	} catch (CloneNotSupportedException e) {
    		e.printStackTrace();
    	}
    	return result;
    }

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Date getBirth() {return birth;}
	public void setBirth(Date birth) {this.birth = birth;}
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void shallowCloneTest() throws CloneNotSupportedException {
    Date birth = new Date(111111111111L);// 定义一个时间对象
    Sheep dorset = new Sheep();// 创建Dorset羊
    dorset.setName("Dorset");
    dorset.setBirth(birth);
    Sheep dolly = dorset.shallowClone(dorset);// 根据Dorset羊克隆一个dolly羊
    dolly.setName("dolly");// 对dolly羊重新设置名字
    System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
    birth.setTime(999999999999L);// 改变date对象的值
    System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth值造成了影响
}


上面的例子你会发现，Object中的clone可以完成实例的克隆，但是两个实例的birth属性仍然指向同一个Date，当我对Date进行改变的时候，两只羊的birth属性值会同时发生改变，这种克隆，我们叫它浅复制，如果克隆时，所有的属性也都被克隆一份，就叫做深克隆（深复制）。

深克隆：深克隆的是实现实际上是对对象的序列化和反序列化，所以需要让你的被克隆类实现序列化接口。
// 本次实现深克隆使用 ByteArrayOutputStream 和 ByteArrayInputStream 作为克隆过程中字符数组存储中介
public Sheep deepClone(Sheep sheep) {
	Sheep result = null;
	ByteArrayOutputStream bos = null;
	ObjectOutputStream oos = null;
	ObjectInputStream ois = null;
	try {
		bos = new ByteArrayOutputStream();
		oos = new ObjectOutputStream(bos);
		oos.writeObject(sheep);// 将传入参数sheep类写入bos中
		// 将读取到数据传入ObjectInputStream
		ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
		result = (Sheep) ois.readObject();
	} catch (IOException | ClassNotFoundException e) {
		e.printStackTrace();
	} finally {
		try {
			bos.close();
			oos.close();
			ois.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	return result;
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void deepCloneTest() throws CloneNotSupportedException, ClassNotFoundException, IOException {
	Date birth = new Date(111111111111L);// 定义一个时间对象
	Sheep dorset = new Sheep();// 创建Dorset羊
	dorset.setName("Dorset");
	dorset.setBirth(birth);
	Sheep dolly = dorset.deepClone(dorset);// 根据Dorset羊克隆一个dolly羊
	dolly.setName("dolly");// 对dolly羊重新设置名字
	System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
	birth.setTime(999999999999L);// 改变date对象的值
	System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth没有造成影响
}


还有一种更简单的方式实现深克隆（此时不用实现序列化接口），就是在你的深克隆方法体中，将Date属性再浅克隆一次。
public Sheep deepClone(Sheep sheep) {
    Date birth = (Date)sheep.getBirth().clone();
    sheep.setBirth(birth);
    return sheep;
}


tips：这种方式需要把所有引用属性都重新浅克隆一遍，当引用属性比较多的时候不适用。

总结：

浅克隆：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象，就像你和你的影子，你完蛋，你的影子也完蛋。
深克隆：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。就像你和你的克隆人，你完蛋，你的克隆人还活着。