# 1. 数据流

**概念：** 数据流支持以类型为单位读取和写入数据。

**源码：** DataSeriesTest.java
```java
/**
 * @author JoeZhou
 */
public class DataSeriesTest {
    private String filePath = "D:" + File.separator + "java-io" + File.separator + "data.txt";

}
```

## 1.1 DataOutputStream

**概念：** 数据输出字节流DataOutputStream是OutputStream的子类，可以以类型为单位向文件或内存写入数据。
- 构造器：`DataOutputStream(OutputStream out)`
- 常用API方法：
    - `writeDouble()`：写一个double类型的数据到输出流中。
    - `writeBoolean()`：写一个boolean类型的数据到输出流中。
    - `writeInt()`：：写一个int类型的数据到输出流中。

**测试：** 将一个int，一个boolean和一个double写入文件 `data.txt`。
```java
@Test
public void dataOutputStream() {
    try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(filePath))) {
        dos.writeInt(250);
        dos.writeBoolean(true);
        dos.writeDouble(3.14);
        dos.flush();
        System.out.println("write over...");
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

> 文件中的数据需要使用 `DataInputStream` 读取，直接打开是乱码。

## 1.2 DataInputStream

**概念：** 数据输入字节流DataInputStream是InputStream的子类，可以以类型为单位从文件或内存中读取数据。
- 构造器：`DataInputStream(InputStream in)`
- 常用API方法：
    - `readDouble()`：从输入流中读取一个double类型的数据。
    - `readBoolean()`：从输入流中读取一个boolean类型的数据。
    - `readInt()`：：从输入流中读取一个int类型的数据。

**测试：** 将1.1章节中的 `data.txt` 读出来。
```java
@Test
public void dataInputStream() {
    try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {
        System.out.println(dis.readInt());
        System.out.println(dis.readBoolean());
        System.out.println(dis.readDouble());
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

# 2. 对象流

**概念：** 对象流可以传输一个类对象，但要求该类必须是一个可序列化的类。
- `transient` 修饰符修饰的属性不参与序列化过程，真实的值不可见，只可见其默认值。

**源码：** ObjectSeriesTest.java
```java
/**
 * @author JoeZhou
 */
public class ObjectSeriesTest {
    private String filePath = "D:" + File.separator + "java-io" + File.separator + "object.txt";
}

class Student implements Serializable {
	private String name;
	private transient Integer age;

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Integer getAge() {return age;}
	public void setAge(Integer age) {this.age = age;}
}
```

## 2.1 ObjectOutputStream

**概念：** 对象输出字节流ObjectOutputStream是OutputStream的子类，可以将类对象数据写入文件。
- 构造器：`ObjectOutputStream(OutputStream out)`
- 常用API方法：`writeObject()`：写一个类对象数据到输出流中。

**测试：** 将 `Student.java` 写入 `object.txt` 文件中。
```java
@Test
public void objectOutputStream() {
    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
        Student student = new Student();
        student.setName("赵四");
        student.setAge(18);
        oos.writeObject(student);
        oos.flush();
        System.out.println("write over...");
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

> 文件中的数据需要使用 `ObjectInputStream` 读取，直接打开是乱码。

## 2.2 ObjectInputStream

**概念：** 对象输入字节流ObjectInputStream是InputStream的子类，可以从文件中读取类对象数据。
- 构造器：`ObjectInputStream(InputStream out)`
- 常用API方法：`readObject()`：将一个类对象数据从输入流中读出来。

**测试：** 将 `Student.java` 从 `object.txt` 文件中读取出来。
```java
@Test
public void objectInputStream() {
    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
        Student student = (Student) ois.readObject();
        System.out.println("name：" + student.getName());
        System.out.println("age：" + student.getAge());
    } catch (IOException | ClassNotFoundException e) {
        e.printStackTrace();
    }
}
```

# 3. 原型模式

**概念：** 原型模式就是java中的克隆技术，以某个实例为原型，克隆出一个新的实例，新实例具有原实例的属性值，这样的做法效率很高，因为不需要执行构造器，也不需要为属性赋值等。
- 克隆不等于new，因为new出来的新实例，所有属性都是默认值，这不叫克隆。

**源码：** Sheep.java
```java
/**
 * @author JoeZhou
 */
public class Sheep implements Cloneable {
    String name;
    Date birth;
}
```

## 3.1 浅克隆

**概念：** 通过浅克隆的方式克隆出来的实例的所有属性都含有与原来的实例相同的值，但对于引用类型来说，克隆的是内存地址，试想100个克隆实例的Date属性，全都指向0x9527，那么当0x9527位置上的Date值发生改变，100个克隆实例的值就全都跟着改变了，就像你和你的影子，你变胖了，你的影子也变胖了。
- 浅克隆其实是直接或者间接调用了 `Object` 中的`clone()`，所以要求原实例实现 `Cloneable` 接口（标记接口，标识某个类为"可克隆的"）以开启克隆操作的支持。

**源码：** 在Sheep.java中添加
```java
Sheep shallowClone(Sheep sheep) {
    Sheep result = null;
    try {
        result = (Sheep) super.clone();
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return result;
}
```

**测试：** 测试birth属性值的更改，是否会同时影响两只羊的birth值。
```java
@Test
public void shallowClone() {
    Date birth = new Date();

    Sheep sheepA = new Sheep();
    sheepA.name = "dorset";
    sheepA.birth = birth;
    System.out.println("sheepA：" + sheepA.name + "-" + sheepA.birth);

    Sheep sheepB = sheepA.shallowClone(sheepA);
    System.out.println("sheepB：" + sheepB.name + "-" + sheepB.birth);
    System.out.println(sheepA == sheepB ? "is same sheep" : "is different sheep");

    birth.setTime(999999999999L);
    System.out.println("sheepA-birth：" + sheepA.birth);
    System.out.println("sheepB-birth：" + sheepB.birth);
}
```

## 3.2 多次浅克隆

**概念：** 多次浅克隆的效果等同于一次深克隆，即在你的深克隆方法体中，将Date属性再浅克隆一次。

**源码：** 在Sheep.java中添加
```java
Sheep multipleShallowClone(Sheep sheep) {
    Sheep result = null;
    try {
        result = (Sheep) super.clone();
        Date birth = (Date) result.birth.clone();
        result.birth = birth;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return result;
}
```

**测试：** 测试birth属性值的更改，是否会同时影响两只羊的birth值。
```java
@Test
public void multipleShallowClone() {
    Date birth = new Date();

    Sheep sheepA = new Sheep();
    sheepA.name = "dorset";
    sheepA.birth = birth;
    System.out.println("sheepA：" + sheepA.name + "-" + sheepA.birth);

    Sheep sheepB = sheepA.multipleShallowClone(sheepA);
    System.out.println("sheepB：" + sheepB.name + "-" + sheepB.birth);
    System.out.println(sheepA == sheepB ? "is same sheep" : "is different sheep");

    birth.setTime(999999999999L);
    System.out.println("sheepA-birth：" + sheepA.birth);
    System.out.println("sheepB-birth：" + sheepB.birth);
}
```

> 这种方式需要把所有引用属性都重新浅克隆一遍，当引用属性比较多，或者引用层度比较深的时候不适用。

## 3.3 深克隆

**概念：** 通过深克隆的方式克隆出来的实例的所有属性都含有与原来的实例相同的值，对与引用类型来说，它们所指向的对象，也被克隆了一份新的，即100个克隆实例的Date属性指向了100个不同的内存地址，此时Date值的改变，不会影响任何克隆实例，就像你和你的克隆人，你变胖了，但你的克隆人不变。
- 深克隆的是实现实际上是对对象的序列化和反序列化，所以需要让你的被克隆类实现序列化接口。

// 本次实现深克隆使用 ByteArrayOutputStream 和 ByteArrayInputStream 作为克隆过程中字符数组存储中介
```java
public Sheep deepClone(Sheep sheep) {
	Sheep result = null;
	ByteArrayOutputStream bos = null;
	ObjectOutputStream oos = null;
	ObjectInputStream ois = null;
	try {
		bos = new ByteArrayOutputStream();
		oos = new ObjectOutputStream(bos);
		oos.writeObject(sheep);// 将传入参数sheep类写入bos中
		// 将读取到数据传入ObjectInputStream
		ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
		result = (Sheep) ois.readObject();
	} catch (IOException | ClassNotFoundException e) {
		e.printStackTrace();
	} finally {
		try {
			bos.close();
			oos.close();
			ois.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	return result;
}
```

测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
```java
@Test
public void deepCloneTest() throws CloneNotSupportedException, ClassNotFoundException, IOException {
	Date birth = new Date(111111111111L);// 定义一个时间对象
	Sheep dorset = new Sheep();// 创建Dorset羊
	dorset.setName("Dorset");
	dorset.setBirth(birth);
	Sheep dolly = dorset.deepClone(dorset);// 根据Dorset羊克隆一个dolly羊
	dolly.setName("dolly");// 对dolly羊重新设置名字
	System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
	birth.setTime(999999999999L);// 改变date对象的值
	System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth没有造成影响
}
```



