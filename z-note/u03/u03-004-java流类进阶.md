# 1. 数据流

**概念：** 数据流支持以类型为单位读取和写入数据。

**源码：** DataSeriesTest.java
```java
/**
 * @author JoeZhou
 */
public class DataSeriesTest {
    private String filePath = "D:" + File.separator + "java-io" + File.separator + "data.txt";

}
```

## 1.1 DataOutputStream

**概念：** 数据输出字节流DataOutputStream是OutputStream的子类，可以以类型为单位向文件或内存写入数据。
- 构造器：`DataOutputStream(OutputStream out)`
- 常用API方法：
    - `writeDouble()`：写一个double类型的数据到输出流中。
    - `writeBoolean()`：写一个boolean类型的数据到输出流中。
    - `writeInt()`：：写一个int类型的数据到输出流中。

**测试：** 将一个int，一个boolean和一个double写入文件 `data.txt`。
```java
@Test
public void dataOutputStream() {
    try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(filePath))) {
        dos.writeInt(250);
        dos.writeBoolean(true);
        dos.writeDouble(3.14);
        dos.flush();
        System.out.println("write over...");
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

> 文件中的数据需要使用 `DataInputStream` 读取，直接打开是乱码。

## 1.2 DataInputStream

**概念：** 数据输入字节流DataInputStream是InputStream的子类，可以以类型为单位从文件或内存中读取数据。
- 构造器：`DataInputStream(InputStream in)`
- 常用API方法：
    - `readDouble()`：从输入流中读取一个double类型的数据。
    - `readBoolean()`：从输入流中读取一个boolean类型的数据。
    - `readInt()`：：从输入流中读取一个int类型的数据。

**测试：** 将1.1章节中的 `data.txt` 读出来。
```java
@Test
public void dataInputStream() {
    try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {
        System.out.println(dis.readInt());
        System.out.println(dis.readBoolean());
        System.out.println(dis.readDouble());
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

# 2. 对象流

**概念：** 对象流可以传输一个类对象，但要求该类必须是一个可序列化的类。
- `transient` 修饰符修饰的属性不参与序列化过程，真实的值不可见，只可见其默认值。

**源码：** ObjectSeriesTest.java
```java
/**
 * @author JoeZhou
 */
public class ObjectSeriesTest {
    private String filePath = "D:" + File.separator + "java-io" + File.separator + "object.txt";
}

class Student implements Serializable {
	private String name;
	private transient Integer age;

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Integer getAge() {return age;}
	public void setAge(Integer age) {this.age = age;}
}
```

## 2.1 ObjectOutputStream

**概念：** 对象输出字节流ObjectOutputStream是OutputStream的子类，可以将类对象数据写入文件。
- 构造器：`ObjectOutputStream(OutputStream out)`
- 常用API方法：`writeObject()`：写一个类对象数据到输出流中。

**测试：** 将 `Student.java` 写入 `object.txt` 文件中。
```java
@Test
public void objectOutputStream() {
    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
        Student student = new Student();
        student.setName("赵四");
        student.setAge(18);
        oos.writeObject(student);
        oos.flush();
        System.out.println("write over...");
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

> 文件中的数据需要使用 `ObjectInputStream` 读取，直接打开是乱码。

## 2.2 ObjectInputStream

**概念：** 对象输入字节流ObjectInputStream是InputStream的子类，可以从文件中读取类对象数据。
- 构造器：`ObjectInputStream(InputStream out)`
- 常用API方法：`readObject()`：将一个类对象数据从输入流中读出来。

**测试：** 将 `Student.java` 从 `object.txt` 文件中读取出来。
```java
@Test
public void objectInputStream() {
    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
        Student student = (Student) ois.readObject();
        System.out.println("name：" + student.getName());
        System.out.println("age：" + student.getAge());
    } catch (IOException | ClassNotFoundException e) {
        e.printStackTrace();
    }
}
```

# 3. 原型模式

**概念：** 原型模式就是java中的克隆技术，以某个实例为原型，克隆出一个新的实例，新实例具有原实例的属性值，这样的做法效率很高，因为不需要执行构造器，也不需要为属性赋值等。
- 克隆不等于new，因为new出来的新实例，所有属性都是默认值，这不叫克隆。
- 克隆出来的对象可以进行改变，且不会影响到原实例。
- 想要实现原型模式，必须让你的原实例实现Cloneable接口（否则抛出CloneNotSupportedException异常），并直接或间接使用Object中的clone()方法，Cloneable是一个标记接口，标识某个类为“可克隆的”。
- 浅克隆：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象，就像你和你的影子，你完蛋，你的影子也完蛋。
- 深克隆：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。就像你和你的克隆人，你完蛋，你的克隆人还活着。

**源码：** Sheep.java
```java
public class Sheep implements Cloneable {
	private String name;
	private Date birth;

    public Sheep shallowClone(Sheep sheep) {
    	Sheep result = null;
    	try {
    		result = (Sheep)super.clone();// 使用Object中的clone方法进行克隆
    	} catch (CloneNotSupportedException e) {
    		e.printStackTrace();
    	}
    	return result;
    }

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Date getBirth() {return birth;}
	public void setBirth(Date birth) {this.birth = birth;}
}
```

## 3.1 浅克隆

测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
```java
@Test
public void shallowCloneTest() throws CloneNotSupportedException {
    Date birth = new Date(111111111111L);
    Sheep dorset = new Sheep();
    dorset.setName("Dorset");
    dorset.setBirth(birth);
    Sheep dolly = dorset.shallowClone(dorset);// 根据Dorset羊克隆一个dolly羊
    dolly.setName("dolly");// 对dolly羊重新设置名字
    System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
    birth.setTime(999999999999L);// 改变date对象的值
    System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth值造成了影响
}
```

上面的例子你会发现，Object中的clone可以完成实例的克隆，但是两个实例的birth属性仍然指向同一个Date，当我对Date进行改变的时候，两只羊的birth属性值会同时发生改变，这种克隆，我们叫它浅复制，如果克隆时，所有的属性也都被克隆一份，就叫做深克隆（深复制）。

## 3.2 深克隆

深克隆：深克隆的是实现实际上是对对象的序列化和反序列化，所以需要让你的被克隆类实现序列化接口。
// 本次实现深克隆使用 ByteArrayOutputStream 和 ByteArrayInputStream 作为克隆过程中字符数组存储中介
```java
public Sheep deepClone(Sheep sheep) {
	Sheep result = null;
	ByteArrayOutputStream bos = null;
	ObjectOutputStream oos = null;
	ObjectInputStream ois = null;
	try {
		bos = new ByteArrayOutputStream();
		oos = new ObjectOutputStream(bos);
		oos.writeObject(sheep);// 将传入参数sheep类写入bos中
		// 将读取到数据传入ObjectInputStream
		ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
		result = (Sheep) ois.readObject();
	} catch (IOException | ClassNotFoundException e) {
		e.printStackTrace();
	} finally {
		try {
			bos.close();
			oos.close();
			ois.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	return result;
}
```

测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
```java
@Test
public void deepCloneTest() throws CloneNotSupportedException, ClassNotFoundException, IOException {
	Date birth = new Date(111111111111L);// 定义一个时间对象
	Sheep dorset = new Sheep();// 创建Dorset羊
	dorset.setName("Dorset");
	dorset.setBirth(birth);
	Sheep dolly = dorset.deepClone(dorset);// 根据Dorset羊克隆一个dolly羊
	dolly.setName("dolly");// 对dolly羊重新设置名字
	System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
	birth.setTime(999999999999L);// 改变date对象的值
	System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth没有造成影响
}
```

## 3.3 二次克隆

还有一种更简单的方式实现深克隆（此时不用实现序列化接口），就是在你的深克隆方法体中，将Date属性再浅克隆一次。
```
public Sheep deepClone(Sheep sheep) {
    Date birth = (Date)sheep.getBirth().clone();
    sheep.setBirth(birth);
    return sheep;
}
```

tips：这种方式需要把所有引用属性都重新浅克隆一遍，当引用属性比较多的时候不适用。

