# 1. 线程安全问题
 
**概念：** 当多线程并发访问时，程序有可能得不到正确的数据结果时，即为线程不安全。
- **同步与异步：** 比如你和赵四一起做同一套数学模拟题，异步就是你们将卷子复制一套，然后一人做半套题，最后拼成一份答案，同步就是你做几道，将卷子扔给赵四，赵四做几道再扔给你，循环交替，直到卷子做完。
    - 异步：互不干扰，资源利用率高，因为整个过程中没有人会长时间处于等待状态，但是不安全，因为有可能两个人题目刷重。
    - 同步：安全，不会刷重题目，但是效率相对而言会低一些，但有些时候，我们不得不牺牲一点效率因素，来提升安全因素。  - 
- **线程不安全原因：** 线程安全问题多由异步造成：
    - 比如赵四账户有1万元余额
    - 今天别人说好要给他转账5000元（线程A）
    - 他也要给别人转账2000元（线程B）
    - 线程A执行，10000 + 5000 = 15000 但是还未来得及更新账户余额，线程就进入了等待状态
    - 线程B执行，10000 - 2000 = 8000，但是还未来得及更新账户余额，线程就进入了等待状态
    - 线程A继续执行，更新账户余额为15000
    - 线程B继续执行，更新账户余额为8000
    - 最终，经过赵四一顿操作，余额最终为8000元
- **线程安全建议：**
    - 尽量对共享资源使用同步的操作，如代码加锁等。
    - 尽量对共享资源使用原子性的操作，如使用JDK提供的原子类等。
    - 尽量少用共享资源，多用线程私有资源，如使用ThreadLocal等。

# 2. 售票系统安全问题

**源码：** TicketSellTest.java
```java
/**@author JoeZhou*/
public class TicketSellTest {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        t1.setName("江北售票点：");
        t2.setName("香坊售票点：");
        t1.start();
        t2.start();
    }
}

/**@author Joe*/
class Ticket implements Runnable {

    /** 票号 */
    private Integer ticketNo = 0;

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);
                sell();
            } catch (InterruptedException e) { 
                e.printStackTrace(); 
            }
        }
    }

    private void sell() {
        int max = 100;
        if(ticketNo < max){
           System.out.println(Thread.currentThread().getName() + "卖了第" + (++ticketNo) + "张票"); 
        }
    }
}
```

tips：发现因为线程之间互相争抢资源，所以会出现两个售票点重复卖票的情况。

## 2.1 synchronized同步

**概念：** 
- 关键字synchronized可以将代码进行同步，其本质是锁，加锁后，当线程A访问此代码时，获取这把锁，其他线程将无法访问这个线程，只有当线程A访问结束之后，释放锁，其他线程才能接着访问，synchronized有两种用法：
- 同步整个方法：在方法上添加 `synchronized` 修饰，对整个方法加锁。
    - `private synchronized void sell(){...}`
- 同步部分代码：使用 `synchronized(){}` 只对涉及到共享数据的部分代码加锁，小括号中是锁的类型。
    - `synchronized(this){...}`
    
**源码：** 
```java
private void sell(){
    synchronized(this){
        int max = 100;
        if(ticketNo < max){
            System.out.println(Thread.currentThread().getName() + "卖了第" + (++ticketNo) + "张票"); 
		}
    }
}
```

## 2.2 同步方法的锁类型

**概念：** 
- synchronized修饰普通方法时使用的是this锁，修饰静态方法时，使用的是类对象锁。
- 同步方法的原理其实就是锁，但只有多个线程使用的是同一种锁时才会发生同步现象。


```java
/**
* 测试同步方法的锁的类型，我们让线程A走同步代码块，让线程B走同步方法，如果仍旧发生同步现象，则代表同步方法中的锁和测试中同步代码块中的锁一致。
@author Joe*/
public class LockTypeTest {
    public static void main(String[] args) {
        LockTypeRunnable r = new LockTypeRunnable();
        Thread t1 = new Thread(r);
        Thread t2 = new Thread(r);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
}

/**@author Joe*/
class LockTypeRunnable implements Runnable {

    private Integer tickets = 0;

    @Override
    public void run() {
        String t1 = "t1";
        while (true) {
            try {
                Thread.sleep(1000);
                if (Thread.currentThread().getName().equals(t1)) {
                    // 同步方法
                    sell();
                } else {
                    // 同步代码块
                    synchronized (this) {
                        int max = 100;
                        if (tickets < max) {
                            System.out.println(Thread.currentThread().getName() + "卖了第" + (++tickets) + "张票");
                        }
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private synchronized void sell() {
        int max = 100;
        if (tickets < max) {
            System.out.println(Thread.currentThread().getName() + "卖了第" + (++tickets) + "张票");
        }
    }
}
```

# 3. 死锁
 
**概念：** 
- 假设吃饭的时候，我有一根筷子，你有一根筷子，我需要你给我凑成一双，我吃饭，你需要我给你凑成一双，你吃饭，这时候就会僵持不下，发生死锁，线程也是一样，A线程持有一个B的锁，B线程持有一个A的锁，二者谁也不肯释放锁，就会发生死锁。
- 死锁的现象我们应该积极避免，应该按照锁的hashcode进行排列，hashcode大的先锁，hashcode小的后锁，所有线程都按照这个规矩办事，就不会出现死锁问题了。

**源码：**
```java
/**@author Joe*/
public class DeadLockTest {
	public static void main(String[] args) {
		DeadLockRunnable r = new DeadLockRunnable();
		new Thread(r).start();
		new Thread(r).start();
	}
}

class DeadLockRunnable implements Runnable {

	private final Object obj1 = new Object();
    private final Object obj2 = new Object();

	@Override
	public void run() {
        String t1 = "Thread-0";
		if (Thread.currentThread().getName().equals(t1)) {
			synchronized (obj1) {
				System.out.println("if -- obj1");
				synchronized (obj2) {
					System.out.println("if -- obj2");
				}
			}
		} else {
			synchronized (obj2) {
				System.out.println("else -- obj2");
				synchronized (obj1) {
					System.out.println("else -- obj1");
				}
			}
		}
	}
}
```


# 4. 单例模式与线程安全

**概念：** 单例模式(单件模式)要求有且只有一个实例，其对外提供一个可以获取该实例的方法。


## 4.1 饿汉单例

概念：这种模式下，无论是否调用这个getInstance方法，都将会new一个Singleton的实例出来，就像一个饿汉一样，无论是否吃馒头，都先做一个馒头出来备用，这无疑有些浪费。
- 将构造器私有化。
- 对外提供一个静态方法，可以将我们自己new出来的实例返回。

```java
public class HungerSingleton {

    private static final HungerSingleton singleton = new HungerSingleton();

    public static HungerSingleton getInstance() {
        return singleton;
    }

    private HungerSingleton() {}
}
```

```java
@Test
public void hungerSingleton {
    for (int i = 0; i < 10; i++) {
        new Thread(()->{
            System.out.println(HungerSingleton.getInstance());
        }).start();
    }
}
```

## 4.2  饱汉单例

概念：
- 这种模式下，可以解决资源浪费的问题，但是并不安全，如果多个线程同时访问getInstance方法，因为方法不同步，可能会导致多个实例被new的情况。


```java
class LazySingleton {
    private static LazySingleton singleton = null;
    private LazySingleton(){}
    public static LazySingleton getInstance(){
        if(singleton == null){
            singleton = new LazySingleton();	
        }
        return singleton;
    }
}
```

```java
@Test
public void lazySingleton {
    for (int i = 0; i < 10; i++) {
        new Thread(()->{
            System.out.println(lazySingleton.getInstance());
        }).start();
    }
}
```

## 4.3  DCL饱汉单例

- 饿汉单例本身就是线程安全的，饱汉单例本身就是线程不安全的。
- 我们可以使用DCL（Double Check Lock）模式来优化饱汉单例模式，使其变为线程安全的。


```java
public class SafeSingleton {
    private static SafeSingleton singleton = null;
    private SafeSingleton(){}
    public static SafeSingleton getInstance(){
        if(singleton == null){
            synchroinzed(SafeSingleton.class){
                if(singleton == null){
                    singleton = new SafeSingleton();
                }
            }
        }
        return singleton;
    }
}
```

```java
@Test
public void safeSingleton {
    for (int i = 0; i < 10; i++) {
        new Thread(()->{
            System.out.println(safeSingleton.getInstance());
        }).start();
    }
}
```

# 5. 原子类

**概念：** 
- 加锁是比较消耗性能的，我们可以使用java并发包中提供的原子类来更简单，更高效，且线程安全地操作一个共享数据变量。
- 原子类都在 `java.util.concurrent.atomic` 包下，共有17个类。
- 对共享数据num进行10个线程并发自增100次，则：
    - 如果使用 `num++`，则最后一条输出结果一定小于1000，因为中途会因为线程争抢而丢失数据。
    - 如果使用 `num.incrementAndGet()`，则最后一条输出结果一定等于1000。

> num++不是原子性操作，在指令级层面，它至少经历了取出值，自增，重新赋值这三件指令。

**源码：** AtomicIntegerDemo.java
```java
/**
 * @author JoeZhou
 */
public class AtomicIntegerDemo {
    private static AtomicInteger num = new AtomicInteger(0);

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    System.out.println(num.incrementAndGet());
                }
            }).start();
        }
    }
}
```


## 5.1 基本类型原子类

**概念：** 想要线程安全地操作基本类型可以使用对应的原子类，AtomicBoolean/AtomicInteger/AtomicLong。
- **初始化：** 以`AtomicInteger`为例，它的构造器中需要放入一个int类型的初始值。
- **使用：**
    - `get()`：获取当前变量值。
    - `incrementAndGet()`：自增当前变量值元素并返回自增后结果。
    - `addAndGet(int delta)`：对当前变量值自增 `delta` 后返回计算结果。
    - `accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)`：自定义计算过程
        - p1：函数式接口中的初始right值。
        - p3：函数式接口，需要两个int型运算参数，返回一个int型结果。

**源码：**
```java
/**
 * @author JoeZhou
 */
public class AtomicIntegerDemo {
    private static AtomicInteger atomicInteger = new AtomicInteger(0);

    public static void main(String[] args) {
        System.out.println("当前值：" + atomicInteger.get());
        System.out.println("当前值+1后：" + atomicInteger.incrementAndGet());
        System.out.println("当前值-1后：" + atomicInteger.decrementAndGet());
        System.out.println("当前值+6后：" + atomicInteger.addAndGet(6));
        int result = atomicInteger.accumulateAndGet(5, (left, right) -> {
                    System.out.print("left：" + left + "\t");
                    System.out.print("right：" + right + "\n");
                    return left * right;
                }
        );
        System.out.println("当前值*5后：" + result);
    }
}
```

## 5.2 基本类型数组原子类

**概念：** 如果想要对基本类型的数组进行原子计算，则可以使用AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray：
- **初始化：** 以`AtomicIntegerArray`为例，它的构造器中需要放入一个int类型的数组。
- **使用：**
    - `get(int i)`：通过角标获取元素。
    - `incrementAndGet(int i)`：通过角标自增元素并返回自增后结果。
    - `addAndGet(int i, int delta)`：通过角标自增 `delta` 后返回计算结果。
    - `accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction)`：自定义计算过程
        - p1：数组角标。
        - p2：初始right值。
        - p3：函数式接口，需要两个int型运算参数，返回一个int型结果。
 
**源码：** AtomicIntegerArrayDemo.java
```java
/**
 * @author JoeZhou
 */
public class AtomicIntegerArrayDemo {

    private static AtomicIntegerArray atomicIntegerArray;

    static {
        int[] arr = new int[]{3, 2};
        atomicIntegerArray = new AtomicIntegerArray(arr);
    }

    public static void main(String[] args) {
        System.out.println("0号元素：" + atomicIntegerArray.get(0));
        System.out.println("0号元素+1后：" + atomicIntegerArray.incrementAndGet(0));
        System.out.println("0号元素-1后：" + atomicIntegerArray.decrementAndGet(0));
        System.out.println("0号元素+6后：" + atomicIntegerArray.addAndGet(0, 6));
        int result = atomicIntegerArray.accumulateAndGet(0, 5, (left, right) -> {
                    System.out.print("left：" + left + "\t");
                    System.out.print("right：" + right + "\n");
                    return left * right;
                }
        );
        System.out.println("0号元素*5后：" + result);
    }
}
```

## 5.3 Double和Long的升级原子类

概念：DoubleAdder和LongAdder对Double和Long的原子更新性能进行优化提升，但是它们只有简单的自增，添加和自减方法。

源码：LongAdderTest.java
```java
/**
 * @author JoeZhou
 */
public class LongAdderTest {

    private static LongAdder longAdder = new LongAdder();

    public static void main(String[] args) {
        longAdder.add(5);
        System.out.println("当前值+5后：" + longAdder);
        longAdder.increment();
        System.out.println("当前值+1后：" + longAdder);
        longAdder.decrement();
        System.out.println("当前值-1后：" + longAdder);
    }
}
```

## 5.4 引用类型原子类

**概念：** 
- 如果想对某个类中的属性进行原子操作，则可以使用引用类型原子类：
    - 属性为 `int`，使用AtomicIntegerFieldUpdater
    - 属性为 `long`，使用AtomicLongFieldUpdater
    - 属性为引用数据类型，如 `String`/`Integer`/`Long` 等，使用AtomicReferenceFieldUpdater
- 使用引用类型原子类注意事项：
    - 成员属性必须volatile修饰，表示该属性在线程之间立即可见。
    - 成员属性不能被static或final修饰。
- 如果很在乎CAS的ABA问题，可以替换如下两种：
    - AtomicMarkableReference：带版本戳的原子引用类型，版本戳为boolean类型。
    - AtomicStampedReference：带版本戳的原子引用类型，版本戳为int类型。

源码：Student.java
```java
public class Student {
    private volatile long id;
    private volatile String name;

    public Student(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    public Long getId() {return id;}
    public void setId(Long id) {this.id = id;}
    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
}
```

源码：AtomicLongFieldUpdaterDemo.java
```java
/**
 * @author JoeZhou
 */
public class AtomicLongFieldUpdaterDemo {

    private static AtomicLongFieldUpdater<Student> longFieldUpdater;

    public static void main(String[] args) {

        longFieldUpdater = AtomicLongFieldUpdater.newUpdater(Student.class, "id");

        Student student = new Student(1L, "赵四");
        longFieldUpdater.get(student);
        System.out.println("当前student中的ID值：" + student.getId());

        longFieldUpdater.compareAndSet(student, 1L, 5L);
        System.out.println("当前student中的ID值如果是1就改为5：" + student.getId());

        longFieldUpdater.incrementAndGet(student);
        System.out.println("当前student中的ID+1后值：" + student.getId());

        longFieldUpdater.decrementAndGet(student);
        System.out.println("当当前student中的ID-1后值：" + student.getId());

        longFieldUpdater.addAndGet(student, 5);
        System.out.println("当前student中的ID+5后值：" + student.getId());

        long result = longFieldUpdater.accumulateAndGet(student, 5, (left, right) -> {
            System.out.print("left：" + left + "\t");
            System.out.print("right：" + right + "\n");
            return left * right;
        });
        System.out.println("当前student中的ID*5后值：" + student.getId());
        
    }
}
```

> 操作字符串类型的name，更换使用AtomicReferenceFieldUpdater即可。	















 	5 ThreadLocal的使用
 		线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。为每个线程单独存放一份变量副本，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。
 		只要线程处于活动状态并且ThreadLocal实例可访问，那么每个线程都拥有对其本地线程副本的隐式引用变量一个线程消失后，它的所有副本线程局部实例受垃圾回收（除非其他存在对这些副本的引用）

		一般用的比较多的是
		1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。
		2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。
		3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。
		4、ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。