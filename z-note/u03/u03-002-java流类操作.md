# 1. File类

**概念：** 
- I/O（Input/Output）：
    - 大多数的应用程序（项目）都需要与外部设备进行数据交换，最常见的外部设备有磁盘、硬盘和网络。
    - 我们所说的I/O就是指应用程序（项目）和这些设备之间的数据交换。
- java.io.File类：
    - java中有很多负责I/O数据交换的类，都在 `java.io` 包中。
    - File类是I/O包中唯一代表硬盘文件本身的类，通过它可以对文件进行创建，删除，重命名，设置读写权限等操作。
    - 构造器：`new File(String filename)`，java种的路径支持 `UNIX` 和 `WINDOWS/DOS` 约定的路径分隔符 `/` 和 `\\` 这两种写法。
 - File类常用API：
    - `boolean exists()`：判断文件/目录是否存在。
    - `boolean mkdir()`：创建单层目录。 
    - `boolean mkdirs()`：创建多层目录。
    - `void delete()`：删除文件/目录，彻底删除，不进回收站，删除文件夹的前提是，文件夹是空文件夹。
    - `void deleteOnExit()`：在JVM终止时删除文件，只有在JVM正常终止时，才会尝试执行删除操作。
    - `boolean createNewFile()`：创建一个文件。
    - `String getName()`：得到文件/目录的名称。 
    - `String getPath()`：得到文件/目录的路径。 
    - `long length()`：得到文件字节数。
    - `String getParent()`：返回父目录的路径名，没有父目录返回null。
    - `long lastModified()`：返回文件最后一次被修改的时间戳，文件不存在或发生异常都会返回0L。    
    - `boolean canRead()`：判断文件是否可读（能查看但是不能操作和存储）。
    - `boolean canWrite()`：判断文件是否可写（能写入但是看不见）。
    - `boolean isFile()`：判断文件是否是文件。
    - `boolean isDirectory()`：判断文件是否是目录。
    - `boolean isHidden()`：返回文件是否是一个隐藏文件。
    - `boolean isAbsolute`：返回文件是否是绝对路径（从盘符出发就是绝对路径）。
    - `String getAbsolutePath()`：返回文件的绝对路径。
    - `boolean renameTo(File file)`：重命名为新的file实例的名字注意参数中的file实例不要创建出来。
    - `boolean equals(File file)`：判断文件/目录是否是同一个。

**测试：** FileTest.java
```java
/**
 * @author JoeZhou
 */
public class FileTest {

    private File file;

    @Before
    public void before() throws IOException {
        String pathDirs = "D:\\java\\io";
        File dirs = new File(pathDirs);
        if (!dirs.exists()) {
            System.out.println(dirs.mkdirs() ? "目录创建成功" : "目录创建失败");
        }
        String pathname = pathDirs + "\\start.txt";
        this.file = new File(pathname);
        if (this.file.exists()) {
            System.out.println(this.file.delete() ? "文件删除成功" : "文件删除失败");
        }
        System.out.println(this.file.createNewFile() ? "文件创建成功" : "文件创建失败");
    }

    @Test
    public void fileApi() {
        System.out.println("文件名：" + file.getName());
        System.out.println("文件路径：" + file.getPath());
        System.out.println("文件大小：" + file.length());
        System.out.println("父目录：" + file.getParent());
        System.out.println("最后修改日期：" + new Date(file.lastModified()));
        System.out.println(file.canRead() ? "可读" : "不可读");
        System.out.println(file.canWrite() ? "可写" : "不可写");
        System.out.println(file.isFile() ? "是文件" : "不是文件");
        System.out.println(file.isDirectory() ? "是目录" : "不是目录");
        System.out.println(file.isHidden() ? "隐藏文件" : "非隐藏文件");
        System.out.println(file.isAbsolute() ? "是绝对路径" : "不是绝对路径");
        System.out.println("文件绝对路径：" + file.getAbsolutePath());
        File newFile = new File("D:\\java\\io\\build-1.txt");
        System.out.println(file.renameTo(newFile) ? "修改成功" : "修改失败");
        System.out.println(file.equals(newFile) ? "是同一个" : "非同一个");
    }
}
```

# 2. RandomAccessFile类

**概念：** 
- java.io.RandomAccessFile类：
    - RandomAccessFile可以从指定的位置开始访问一个文件，它具有一个位置指示器，负责指向当前读写处的位置，默认位置是文件的开头，我们可以自己设定指示器的初始位置，读写n个字节后，指示器指向n个字节后的下一个字节处。
    - 构造器：`new RandomAccessFile(String name, String mode)`
        - p1：文件路径，如果文件不存在会帮忙创建，但是如果目录不存在直接报错。
        - p2：文件读写模式，`r` 表示只读，`rw` 表示读写。
- RandomAccessFile类的常用API：
    - `final void writeUTF(String str)`：写入一个字符串。
        - UTF-8编码下一个字符占3个字节，GBK编码下一个字符占2个字节。
        - writeUTF()会首先把指定字符串的总字节数写进前2个字节，故6个字节的数据其实占了8字节的空间。
    - `final void writeInt(int v)`：写入一个int类型值。
    - `void seek(long pos)`：设置位置指示器的位置。
    - `void skipBytes(int n)`：位置指示器向后移动n个字节（跳过n个字节）。
    - `final String readUTF()`：读取一个字符串。
    - `final int readInt()`：读取一个int类型值。
    - `void close()`：关闭RandomAccessFile，节省内存资源。

> RandomAccessFile仅限于操作文件，不能访问其他IO设备，如网络，内存映像等。

**测试：** 使用同一个RandomAccessFile对象对一个文件完成三个员工信息（姓名和年龄）的按顺序写和按顺序读，且在输出过程种，跳过赵四的年龄。
```java
/**
 * @author JoeZhou
 */
public class RandomAccessFileTest {

    private RandomAccessFile randomAccessFile;

    @Before
    public void before() throws IOException {
        randomAccessFile = new RandomAccessFile("D:\\java\\io\\emp.txt", "rw");
        randomAccessFile.writeUTF("赵四");
        randomAccessFile.writeInt(18);
        randomAccessFile.writeUTF("刘能");
        randomAccessFile.writeInt(28);
        randomAccessFile.writeUTF("广坤");
        randomAccessFile.writeInt(38);
    }

    @After
    public void after() throws IOException {
        randomAccessFile.close();
    }

    @Test
    public void write() throws IOException {

        // 位置指示器重置于0号位
        randomAccessFile.seek(0);
        System.out.print(randomAccessFile.readUTF() + "\t");

        // 跳过赵四的年龄
        randomAccessFile.skipBytes(4);
        System.out.print(randomAccessFile.readUTF() + "\t");
        System.out.print(randomAccessFile.readInt() + "\t");
        System.out.print(randomAccessFile.readUTF() + "\t");
        System.out.print(randomAccessFile.readInt() + "\n");
    }
}
```

> java.io.EOFException 异常在某个文件已经到末尾了，你仍然在读取时爆发。

**练习：** 03002-2

# 3. I/O流

**概念：** 电脑硬盘上存放文件，文件上存放数据，Java中通过各种各样的管道来传输数据，这些管道就是I/O流。
- 流的分类：
    - 按方向：输入流/输出流，也称读流/写流，都是站在程序代码的角度来辨别方向。
    - 按处理数据方式：字节流/字符流，字节流以二进制方式进行数据传输，字符流是以字符为单位进行数据传输。
    - 按功能：节点流/处理流，节点流是对数据直传输，处理流会在数据传输过程中对数据进行二次处理后再传输。
- 四大抽象流：
    - 输入字节流：InputStream
    - 输出字节流：OutputStream
    - 输入字符流：Reader
    - 输出字符流：Writer
- 抽象流常用节点流子类：
    - 文件流：FileInputStream/FileOutputStream/FileReader/FileWriter
    - 内存数组流：ByteArrayInputStream/ByteArrayOutputStream/CharArrayReader/CharArrayWriter
    - 内存字符串流：StringReader/StringWriter
- 抽象流常用处理流子类：
    - 缓冲流：BufferedInputStream/BufferedOutputStream/BufferedReader/BufferedWriter
    - 转换流：InputStreamReader/OutputStreamWriter/BufferedReader/BufferedWriter
    - 打印流：PrintStream/PrintWriter
    - 数据流：DataInputStream/DataOutputStream
    - 对象流：ObjectInputStream/ObjectOutputStream
    - 管道流：PipedInputStream/PipedOutputStream/PipedReader/PipedWriter

> 带有中文的纯文本内容推荐使用字符流，图片，影音等二进制内容推荐使用字节流。

# 4. 文件节点流

节点流是对数据的直传输，中间不涉及任何数据的处理。

## 4.1 文件字节输入流
利用FileInputStream将自身文件输出在控制台，并计算总字节数
@Test
public void FileInputStreamTest() throws IOException {
    
    // 文件路径，支持"/"和"\\"
	String filePath = "****.java";
 
    // 将FileInputStream管插在你要操作的文件上
	FileInputStream fis = new FileInputStream(filePath);
 
    // 查看可见（还剩下的）总字节数
	System.out.println("总字节数：" + fis.available());
 
    // 定义一个中间变量，负责接收每次循环出来的字节
	int b;
	while ((b = fis.read()) != -1) {
        // 将数字转换为char值
		System.out.print((char) b);
	}
    
	fis.close();
}


## 4.2 文件字节输出流
利用FileInputStream和FileOutputStream，将HelloWorld.txt文件内容copy到某HolloWorld.java文件中
@Test
public void FileOutputStreamTest() throws IOException {
    
    // 输入流
	FileInputStream fis = new FileInputStream("E:\\io\\HelloWorld.txt");
 
    // 输出流，要输出的文件路径如果没有程序会帮忙创建
	FileOutputStream fos = new FileOutputStream("E:\\io\\HelloWorld.java");

	int b;
 
    // 从HelloWorld.txt输入一个，往HelloWorld.java输出一个
	while ((b = fis.read()) != -1) {
		fos.write(b);
	}

    // 冲刷管道中残留数据
	fos.flush();
	fos.close();
	fis.close();

	System.out.println("copy over...");
}


tips：FileOutputStream()第二个参数默认false，如果改为true，则每次写入，代表追加，否则代表覆盖原来的值。

## 4.3 文件字符输入流
利用FileReader将包含中文的自身文件输出在控制台
@Test
public void readerTest() throws IOException {
	String path = "****.java";
	FileReader fr = new FileReader(path);

	int b = -1;
	while ((b = fr.read()) != -1) {
		System.out.print((char) b);
	}

	fr.close();
}


## 4.4 文件字符输出流
利用FileWriter制作一个文件Unicode.dat
@Test
public void writerTest() throws IOException {
	FileWriter fw = new FileWriter("E:\\io\\unicode.dat");

    // unicode码最大值65535
	for(int i = 0, j = 65535; i < j; i++) {
		fw.write(i);
	}
	
	fw.flush();
	fw.close();
}

# 5. 处理缓冲流

处理流会在节点流的基础上，对数据进行更丰富的处理，然后再进行传输。

## 5.1 缓冲字节输入流
利用BufferedInputStream中的mark和reset方法，对文件进行中间部分内容读取
@Test
public void bufferedInputStreamTest() throws IOException {
	FileInputStream fis = new FileInputStream("E:\\io\\BT.txt");
	BufferedInputStream bis = new BufferedInputStream(fis, 8192);// p2 : default 8K.

	System.out.println("1b:" + (char) bis.read());// 在1号位置读取一个字节
	System.out.println("2b:" + (char) bis.read());// 在2号位置读取一个字节

	bis.mark(4);// 在3号位置mark，4字节后该mark失效

	System.out.println("3b:" + (char) bis.read());// 在3号位置读取一个字节
	System.out.println("4b:" + (char) bis.read());// 在4号位置读取一个字节
	System.out.println("5b:" + (char) bis.read());// 在5号位置读取一个字节
	System.out.println("6b:" + (char) bis.read());// 在6号位置读取一个字节

	bis.reset();// 回到标记的3号位置

	System.out.println("3b:" + (char) bis.read());// 在3号位置读取一个字节
	System.out.println("4b:" + (char) bis.read());// 在4号位置读取一个字节
	System.out.println("5b:" + (char) bis.read());// 在5号位置读取一个字节
	System.out.println("6b:" + (char) bis.read());// 在6号位置读取一个字节

	bis.close();
}


tips：mark()方法标记的位置，只取决于这行代码被调用时，fis中指针的位置，或者理解为这行代码的位置，跟参数无关。
tips：mark()方法的参数是一个以字节为单位的标记有效期，比如4，代表从标记开始，4个字节内，标记都有效，如果读了5个字节，mark()标记失效，reset()方法将会报错。
tips：mark()方法的有效期不仅仅取决于它的参数，还取决于BufferedInputStream()的缓存，默认8K，两个值，谁大走谁，比如mark(5)，但是BufferedInputStream()的缓存是8192字节，所以读的字节没超过8192字节，都生效。

## 5.2 缓冲字节输出流
利用BufferedOutputStream对一个文件写入10个A
@Test
public void BufferedOutputStreamTest() throws IOException {
	FileOutputStream fos = new FileOutputStream("E:\\io\\BO2.txt");
	BufferedOutputStream bos = new BufferedOutputStream(fos);

	for (int i = 0; i < 10; i++) {
        // 如果写入数字，会转成unicode码
		bos.write('A');
	}

	bos.flush();
	bos.close();
}


## 5.3 缓冲字符输入流
利用BufferedReader中的readline方法一行一行地读取自身文件，并输出在控制台上
@Test
public void BufferedReaderTest() throws IOException {
	FileReader fr = new FileReader("D:\\...\\处理_缓冲流.java");
    // 在FileReader外套一层BufferedReader
	BufferedReader br = new BufferedReader(fr);
	String str = null;
    // BufferedReader中有readLine()方法，可以按行读取
	while((str = br.readLine()) != null) {
		System.out.println(str);
	}
	br.close();
}


## 5.4 缓冲字符输出流
利用BufferedWriter向文件写入100个随机数，每个随机数占据一行
@Test
public void bufferedWriterTest() throws IOException {
	FileWriter fw = new FileWriter("E:\\io\\random.txt");
	BufferedWriter bw = new BufferedWriter(fw);

    Random random = new Random();
    for (int i = 0, j = 100; i < j; i++) {
        
        // BufferedWriter支持写入字符串
        bw.write("" + (random.nextInt(100)));
        
        // newLine()可以换行
        bw.newLine();
    }
    
	bw.flush();
	bw.close();
}


# 6. 处理转换流

我们可以利用处理转换流将字节流转换成对应的字符流（inputStream-Reader，outputStream-Writer）。

## 6.1 输入转换流
利用InputStreamReader模拟Scanner键入输出，使用readLine()方法读取控制台信息
@Test
public void inputStreamReaderTest() throws IOException {
    
    // System.in本身就是InputStream类型
	InputStreamReader isr = new InputStreamReader(System.in);
	BufferedReader br = new BufferedReader(isr);
	String str;
	while ((str = br.readLine()) != null) {
		System.out.println(">> " + str);
	}
    br.close();
}


tips：Idea中的Junit和System.in或者Scanner有冲突，请换成main方法测试。

## 6.2 输出转换流
@Test
public void outputStreamWriterTest() throws IOException {
    
    // true代表追加
	FileOutputStream fos = new FileOutputStream("E:\\io\\osw.txt", true);
 
    // 将FileOutputStream转成Writer
	OutputStreamWriter osw = new OutputStreamWriter(fos);
	osw.write("你好");
 
    // utf8
	System.out.println(osw.getEncoding());
	osw.flush();

    // 第二个参数可以控制编码
	osw = new OutputStreamWriter(fos, "GBK");
	osw.write("世界");
 
    // gbk
	System.out.println(osw.getEncoding());
	osw.flush();
	osw.close();
}


# 7. 处理打印流

打印流是输出语句的底层结构，无需抛出IO异常，且自带flush效果。

## 7.1 打印字节流
利用继承自OutputStream的PrintStream，重新定义输出打印语句的效果
public class Text_PrintStream {
	public static void main(String[] args) throws FileNotFoundException {
		PrintStream ps = new PrintStream(new FileOutputStream("D:\\JavaDir\\IO\\Text_PrintStream.dat"));
		// 重新定义输出语句中的out，让其从默认指向控制台改为指向ps绑定的文件上
		System.setOut(ps);
		// 利用新的输出语句，将unicode前128个打印在文件中
		for (int i = 0; i < 128; i++) {
			System.out.print((char) i + " ");
		}
		ps.close();
	}
}


如果修改out指定之后，需要回复原来的指向(控制台)，则需要在setOut()之前，对System.out进行备份，然后再使用新指定之后，再次调用setOut()来还原备份。
PrintStream preOut = System.out;// 默认值备份
System.setOut(preOut);// 还原备份


tips：System.out和System.err都能重定向到别的输出流中输出，此时控制台console区域不输出内容。

## 7.2 打印字符流
使用PrintWriter创建一个日志文件，模拟Log4j（java的日志文件）工作
@Test
public void printWriterTest() throws IOException {
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	FileWriter fw = new FileWriter("E:\\io\\日志.log", true);
	PrintWriter pw = new PrintWriter(fw);
	String str = null;
	while ((str = br.readLine()) != null) {
		if ("q".equalsIgnoreCase(str)) {
			break;
		}
		pw.println(str);
	}
	pw.println("LOGGING AT " + new Date());
    br.close();
	pw.close();
}


tips：idea中，junit和scanner冲突，测试请使用main方法。

# 8. 处理数据流

需求：在内存中创造一个虚拟的字节数组，向字节数组中写入一个double一个boolean并读出来。

数据输入字节流：DataInputStream extends InputStream
数据输出字节流：DataOutputStream extends OutputStream
字节数组输入字节流：ByteArrayInputStream extends InputStream
字节数组输出字节流：ByteArrayOutputStream extends OutputSteam



@Test
public void dataOutputStreamTest() throws IOException {
	// 在内存中创造一个虚拟的字节数组，并插一根字节数组输出流管(baos)，准备往里面写数据
	ByteArrayOutputStream baos = new ByteArrayOutputStream();
	
	// 在baos外层嵌套数据输出流管(dos)，因为想使用它的writeDouble()、writeInt()等便捷方法写数据
	DataOutputStream dos = new DataOutputStream(baos);
	
	// 写：使用DataOutputStream中的便捷方法向内存数组中写数据
	dos.writeDouble(3.14);
	dos.writeBoolean(true);
	dos.writeInt(250);
	dos.flush();
	
	// 读：内存中的字节数组没有名字，我们只能从节数组输入流管(baos)中读数据
	// ByteArrayInputStream()的构造方法中只支持字节数组参数，所有我们需要将baos转成字节数组
	ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
	
	// 在bais外层嵌套数据输入流管(dis)，因为想使用它的readDouble()、readInt()等便捷方法读数据
	DataInputStream dis = new DataInputStream(bais);
	
	// 读：使用DataInputStream中的便捷方法从内存数组中读数据
	System.out.println(dis.readDouble());
	System.out.println(dis.readBoolean());
	System.out.println(dis.readInt());
	
	dos.close();
	dis.close();
}


# 9. 处理对象流

ObjectOuputStream和ObjectInputStream可以实现对可序列化类对象的传输。
public class 处理_对象流 {
	@Test
	public void ObjectStreamTest() throws IOException, ClassNotFoundException {

        // 对象输出流
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("E:\\io\\student.txt"));

        // 新建一个对象，并将对象写到文件中
		oos.writeObject(new Student("赵四",58));

        // 对象输入流
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("E:\\io\\student.txt"));
  
        // 从文件中读取对象，并查看
		System.out.println(ois.readObject());

		oos.flush();
		oos.close();
		ois.close();
	}
}

/**
 * Serializable没有任何方法 就是告诉虚拟机这是一个可序列化的类，可以被传输 这种接口称为标记接口
 */
@SuppressWarnings("serial")
class Student implements Serializable {
	private String name;
	private transient Integer age;// 被修饰的属性不参与序列化过程，值不可见(为默认值)
 	
    public Student(String name, Integer age) {
		this.name = name;
		this.age = age;
	}
 	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Integer getAge() {return age;}
	public void setAge(Integer age) {this.age = age;}
}

# 10. 原型模式

原型模式就是java中的克隆技术，以某个实例为原型，克隆出一个新的实例，新实例具有原实例的属性值，这样的做法效率很高，因为不需要执行构造器，也不需要为属性赋值等。

克隆不等于new，因为new出来的新实例，所有属性都是默认值，这不叫克隆。

克隆出来的对象可以进行改变，且不会影响到原实例。

想要实现原型模式，必须让你的原实例实现Cloneable接口（否则抛出CloneNotSupportedException异常），并直接或间接使用Object中的clone()方法，Cloneable是一个标记接口，标识某个类为“可克隆的”。

羊类
package com.gof23.原型模式;
import java.util.Date;

public class Sheep implements Cloneable {
	private String name;
	private Date birth;

    public Sheep shallowClone(Sheep sheep) {
    	Sheep result = null;
    	try {
    		result = (Sheep)super.clone();// 使用Object中的clone方法进行克隆
    	} catch (CloneNotSupportedException e) {
    		e.printStackTrace();
    	}
    	return result;
    }

	public String getName() {return name;}
	public void setName(String name) {this.name = name;}
	public Date getBirth() {return birth;}
	public void setBirth(Date birth) {this.birth = birth;}
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void shallowCloneTest() throws CloneNotSupportedException {
    Date birth = new Date(111111111111L);// 定义一个时间对象
    Sheep dorset = new Sheep();// 创建Dorset羊
    dorset.setName("Dorset");
    dorset.setBirth(birth);
    Sheep dolly = dorset.shallowClone(dorset);// 根据Dorset羊克隆一个dolly羊
    dolly.setName("dolly");// 对dolly羊重新设置名字
    System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
    birth.setTime(999999999999L);// 改变date对象的值
    System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth值造成了影响
}


上面的例子你会发现，Object中的clone可以完成实例的克隆，但是两个实例的birth属性仍然指向同一个Date，当我对Date进行改变的时候，两只羊的birth属性值会同时发生改变，这种克隆，我们叫它浅复制，如果克隆时，所有的属性也都被克隆一份，就叫做深克隆（深复制）。

深克隆：深克隆的是实现实际上是对对象的序列化和反序列化，所以需要让你的被克隆类实现序列化接口。
// 本次实现深克隆使用 ByteArrayOutputStream 和 ByteArrayInputStream 作为克隆过程中字符数组存储中介
public Sheep deepClone(Sheep sheep) {
	Sheep result = null;
	ByteArrayOutputStream bos = null;
	ObjectOutputStream oos = null;
	ObjectInputStream ois = null;
	try {
		bos = new ByteArrayOutputStream();
		oos = new ObjectOutputStream(bos);
		oos.writeObject(sheep);// 将传入参数sheep类写入bos中
		// 将读取到数据传入ObjectInputStream
		ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
		result = (Sheep) ois.readObject();
	} catch (IOException | ClassNotFoundException e) {
		e.printStackTrace();
	} finally {
		try {
			bos.close();
			oos.close();
			ois.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	return result;
}


测试：通过debug观测两只羊的内容，地址，以及setTime方法对两只羊的birth属性影响
@Test
public void deepCloneTest() throws CloneNotSupportedException, ClassNotFoundException, IOException {
	Date birth = new Date(111111111111L);// 定义一个时间对象
	Sheep dorset = new Sheep();// 创建Dorset羊
	dorset.setName("Dorset");
	dorset.setBirth(birth);
	Sheep dolly = dorset.deepClone(dorset);// 根据Dorset羊克隆一个dolly羊
	dolly.setName("dolly");// 对dolly羊重新设置名字
	System.out.println(dolly.getBirth());// dolly的birth值和Dorset的值一致
	birth.setTime(999999999999L);// 改变date对象的值
	System.out.println(dolly.getBirth());// birth变量的改变对dolly的birth没有造成影响
}


还有一种更简单的方式实现深克隆（此时不用实现序列化接口），就是在你的深克隆方法体中，将Date属性再浅克隆一次。
public Sheep deepClone(Sheep sheep) {
    Date birth = (Date)sheep.getBirth().clone();
    sheep.setBirth(birth);
    return sheep;
}


tips：这种方式需要把所有引用属性都重新浅克隆一遍，当引用属性比较多的时候不适用。

总结：

浅克隆：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象，就像你和你的影子，你完蛋，你的影子也完蛋。
深克隆：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。就像你和你的克隆人，你完蛋，你的克隆人还活着。