synchronized(Obj)
- 在obj对象头的markword记录这个线程的ID（偏向锁）
- 如果发生线程争抢，升级为轻量级自旋锁
- 10次自旋后升级为重量级OS锁


- 同步代码的执行时间短，并发访问量低的时候，使用自旋锁
- 同步代码的执行时间长，并发访问量高的时候，使用OS锁



# ReentrantReadWriteLockTest

- 读读共享
- 读写互斥
- 写写互斥

```java
/**
 * @author JoeZhou
 */
public class ReentrantReadWriteLockTest {
    public static void main(String[] args) {
        ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo();
        new Thread(readWriteLockDemo::read, "reader-A").start();
        new Thread(readWriteLockDemo::read, "reader-B").start();
        new Thread(readWriteLockDemo::write, "writer-A").start();
        new Thread(readWriteLockDemo::write, "writer-B").start();
    }
}

class ReadWriteLockDemo {
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    private Lock readLock = lock.readLock();
    private Lock writeLock = lock.writeLock();

    void read() {
        readLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "：reading...");
            Thread.sleep(5000L);
            System.out.println(Thread.currentThread().getName() + "：read over...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            readLock.unlock();
        }

    }

    void write() {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "：writing...");
            Thread.sleep(1000L);
            System.out.println(Thread.currentThread().getName() + "：write over...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            writeLock.unlock();
        }
    }
}
```