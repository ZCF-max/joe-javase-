# 1. synchronized锁升级

概念：即使在多线程环境下，某些共享变量也有可能极少发生线程争抢，即大多数的情况下都是只有一个线程在访问这个共享资源，如果对这个共享资源添加OS锁，那么每次访问的时候都需要向OS申请，也会很浪费性能，早期的synchronized会直接对锁实例obj添加OS锁，后来随着JDK的升级而做了优化，变成了先添加偏向锁，然后视情况而定，是否需要向重量锁方向进行进化。
- 锁实例obj的mark-word的后两bit记录了锁类型的信息，其中：
    - 刚new出来的实例，没有加锁，mark-down后两位为 `01`，再辅助一个倒数第三位的 `0` 同时描述。
    - 获得了偏向锁后，mark-down后两位为 `01`，再辅助一个倒数第三位的 `1` 同时描述。
    - 获得了轻量级锁-自旋锁后，mark-down后两位为 `00`，不需要辅助位。
    - 获得了重量级锁-OS锁后，mark-down后两位为 `01`，不需要辅助位。
    - 如果锁实例obj将要被GC回收，mark-down后两位为 `11`，不需要辅助位。

## 1.1 偏向锁

概念：
- 偏向锁会偏向第一个获取锁的线程（假设为threadA），将获得了偏向锁的信息 `101` 记录在琐实例obj的mark-word中的后三位，再将threadA的线程ID记录mark-word其他位，然后每次有线程想要获取锁的时候，只需要一个简单的判断：
    - 如果新线程还是threadA，直接放行进入同步代码中。
    - 如果其他线程，如threadB，则表示发生了资源争抢，需要将偏向锁撤销并升级为轻量级锁。
    - 如果同步代码发生了严重耗时的情况，如调用了 `wait()`，则直接升级为重量级锁。
- 偏向锁在升级之前需要先撤销revoke，这个过程也会消耗一定的CPU资源，所以如果你明确知道会发生多线程争抢事件，就不要使用偏向锁，而直接使用自旋锁，以免不必要的性能开销。
- 偏向锁是需要启动的：因为JVM在启动的会执行很多sync代码，这些代码明确会有多线程竞争，所以偏向锁都是延迟4秒才启动的，以避免频繁的锁升级和锁撤销，浪费性能。
    - 可以通过 `-XX:biasdLockingStartupDelay=0` 参数来调整匿名偏向锁的启动延迟时间。
    - 偏向锁未启动时new出来的实例没有任何锁的信息，添加sync锁后，直接升级成为自旋锁。
    - 偏向锁启动之后再new出来的实例直接会获得一个匿名偏向锁，指向0(null)，锁信息为 `101`，添加sync锁后仍为偏向锁，但mark-down存入了偏向的线程ID。

**源码：** thread/lock/LockUpgradeTest.biasLock()

## 1.2 轻量级锁-自旋锁

概念：偏向锁撤销后，争抢资源的两个线程threadA和threadB，会各自在自己的线程栈中生成LR（lock record），并通过自旋的方式开始争抢资源，假设threadB争抢到了资源，则将threadB的LR记录在锁实例obj中，此时threadA开始在用户内存空间CAS自旋，此时锁实例obj中的偏向锁便升级为了自旋锁。
- 自旋可以理解为在同步代码块的"门口"，建立一个死循环不停地尝试获取锁的过程。
- 自旋锁会消耗CPU资源，所以不适用于同步代码的执行时间长，或并发访问量高的情况。

> 自旋锁也叫无锁，但为了避免误导，尽量不要使用这个叫法。

**源码：** thread/lock/LockUpgradeTest.selfRotatingLock()

## 1.3 重量级锁-OS锁

概念：如果某个线程自旋次数超过10次，或所有自旋线程个数总和超过CPU核数的一半，那么自旋锁将升级为重量级锁，即OS锁。
- JDK6之前可以使用 `-XX:PreBlockSpin` 调整自旋最大次数，JDK6之后JVM引入了自适应自旋的概念，即JVM自动管理自旋最大次数，无需我们操心。
- OS锁需要向内核空间申请并得到返回，效率比自旋锁低，但它底层使用等待队列来存放和调度那些没能获取锁的线程，不消耗CPU资源，所以更适用于同步代码的执行时间长，或并发访问量高的情况。




CAS底层操作是一条汇编指令 lock cmpxchg



# 2. ReentrantReadWriteLockTest

- 读读共享
- 读写互斥
- 写写互斥

```java
/**
 * @author JoeZhou
 */
public class ReentrantReadWriteLockTest {
    public static void main(String[] args) {
        ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo();
        new Thread(readWriteLockDemo::read, "reader-A").start();
        new Thread(readWriteLockDemo::read, "reader-B").start();
        new Thread(readWriteLockDemo::write, "writer-A").start();
        new Thread(readWriteLockDemo::write, "writer-B").start();
    }
}

class ReadWriteLockDemo {
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    private Lock readLock = lock.readLock();
    private Lock writeLock = lock.writeLock();

    void read() {
        readLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "：reading...");
            Thread.sleep(5000L);
            System.out.println(Thread.currentThread().getName() + "：read over...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            readLock.unlock();
        }

    }

    void write() {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "：writing...");
            Thread.sleep(1000L);
            System.out.println(Thread.currentThread().getName() + "：write over...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            writeLock.unlock();
        }
    }
}
```