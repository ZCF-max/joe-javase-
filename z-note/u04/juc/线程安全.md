# 1. 线程安全问题
 
**概念：** 当多线程并发访问时，程序有可能得不到正确的数据结果时，即为线程不安全。
- **线程安全建议：**
    - 尽量对共享资源使用同步的操作，如代码加锁等。
    - 尽量对共享资源使用原子性的操作，如使用JDK提供的原子类等。
    - 尽量少用共享资源，多用线程私有资源，如使用ThreadLocal等。
    
    
# ThreadLocal的使用
 		线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。为每个线程单独存放一份变量副本，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。
 		只要线程处于活动状态并且ThreadLocal实例可访问，那么每个线程都拥有对其本地线程副本的隐式引用变量一个线程消失后，它的所有副本线程局部实例受垃圾回收（除非其他存在对这些副本的引用）

		一般用的比较多的是
		1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。
		2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。将某个值设置到当前线程的一个map容器中，其他线程你是获取不到的。
		3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值，如果你的ThreadLocal使用完了，一定要记得remove掉，否则会产生内存泄露问题。
		4、ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。
		
		
```java
/**
 * @author JoeZhou
 */
public class ThreadLocalTest {

    private static ThreadLocal<Person> personThreadLocal = new ThreadLocal<>();

    public static void main(String[] args) {

        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
                personThreadLocal.set(new Person());
                System.out.println("1秒钟后Person设置完成...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
                System.out.println(personThreadLocal.get() == null ? "2秒钟后获取失败.." : "2秒钟后获取成功");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
    
    static class Person {
        private String name;
    }
}
```