# 5. 原子类

**概念：** 
- 加锁是比较消耗性能的，我们可以使用java并发包中提供的原子类来更简单，更高效，且线程安全地操作一个共享数据变量。
- 原子类都在 `java.util.concurrent.atomic` 包下，共有17个类。
- 对共享数据num进行10个线程并发自增100次，则：
    - 如果使用 `num++`，则最后一条输出结果一定小于1000，因为中途会因为线程争抢而丢失数据。
    - 如果使用 `num.incrementAndGet()`，则最后一条输出结果一定等于1000。

> num++不是原子性操作，在指令级层面，它至少经历了取出值，自增，重新赋值这三件指令。

**源码：** AtomicIntegerDemo.java
```java
/**
 * @author JoeZhou
 */
public class AtomicIntegerDemo {
    private static AtomicInteger num = new AtomicInteger(0);

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    System.out.println(num.incrementAndGet());
                }
            }).start();
        }
    }
}
```


## 5.1 基本类型原子类

**概念：** 想要线程安全地操作基本类型可以使用对应的原子类，AtomicBoolean/AtomicInteger/AtomicLong。
- **初始化：** 以`AtomicInteger`为例，它的构造器中需要放入一个int类型的初始值。
- **使用：**
    - `get()`：获取当前变量值。
    - `incrementAndGet()`：自增当前变量值元素并返回自增后结果。
    - `addAndGet(int delta)`：对当前变量值自增 `delta` 后返回计算结果。
    - `accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)`：自定义计算过程
        - p1：函数式接口中的初始right值。
        - p3：函数式接口，需要两个int型运算参数，返回一个int型结果。

**源码：**
```java
/**
 * @author JoeZhou
 */
public class AtomicIntegerDemo {
    private static AtomicInteger atomicInteger = new AtomicInteger(0);

    public static void main(String[] args) {
        System.out.println("当前值：" + atomicInteger.get());
        System.out.println("当前值+1后：" + atomicInteger.incrementAndGet());
        System.out.println("当前值-1后：" + atomicInteger.decrementAndGet());
        System.out.println("当前值+6后：" + atomicInteger.addAndGet(6));
        int result = atomicInteger.accumulateAndGet(5, (left, right) -> {
                    System.out.print("left：" + left + "\t");
                    System.out.print("right：" + right + "\n");
                    return left * right;
                }
        );
        System.out.println("当前值*5后：" + result);
    }
}
```

## 5.2 基本类型数组原子类

**概念：** 如果想要对基本类型的数组进行原子计算，则可以使用AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray：
- **初始化：** 以`AtomicIntegerArray`为例，它的构造器中需要放入一个int类型的数组。
- **使用：**
    - `get(int i)`：通过角标获取元素。
    - `incrementAndGet(int i)`：通过角标自增元素并返回自增后结果。
    - `addAndGet(int i, int delta)`：通过角标自增 `delta` 后返回计算结果。
    - `accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction)`：自定义计算过程
        - p1：数组角标。
        - p2：初始right值。
        - p3：函数式接口，需要两个int型运算参数，返回一个int型结果。
 
**源码：** AtomicIntegerArrayDemo.java
```java
/**
 * @author JoeZhou
 */
public class AtomicIntegerArrayDemo {

    private static AtomicIntegerArray atomicIntegerArray;

    static {
        int[] arr = new int[]{3, 2};
        atomicIntegerArray = new AtomicIntegerArray(arr);
    }

    public static void main(String[] args) {
        System.out.println("0号元素：" + atomicIntegerArray.get(0));
        System.out.println("0号元素+1后：" + atomicIntegerArray.incrementAndGet(0));
        System.out.println("0号元素-1后：" + atomicIntegerArray.decrementAndGet(0));
        System.out.println("0号元素+6后：" + atomicIntegerArray.addAndGet(0, 6));
        int result = atomicIntegerArray.accumulateAndGet(0, 5, (left, right) -> {
                    System.out.print("left：" + left + "\t");
                    System.out.print("right：" + right + "\n");
                    return left * right;
                }
        );
        System.out.println("0号元素*5后：" + result);
    }
}
```

## 5.3 Double和Long的升级原子类

概念：DoubleAdder和LongAdder对Double和Long的原子更新性能进行优化提升，但是它们只有简单的自增，添加和自减方法。

源码：LongAdderTest.java
```java
/**
 * @author JoeZhou
 */
public class LongAdderTest {

    private static LongAdder longAdder = new LongAdder();

    public static void main(String[] args) {
        longAdder.add(5);
        System.out.println("当前值+5后：" + longAdder);
        longAdder.increment();
        System.out.println("当前值+1后：" + longAdder);
        longAdder.decrement();
        System.out.println("当前值-1后：" + longAdder);
    }
}
```

## 5.4 引用类型原子类

**概念：** 
- 如果想对某个类中的属性进行原子操作，则可以使用引用类型原子类：
    - 属性为 `int`，使用AtomicIntegerFieldUpdater
    - 属性为 `long`，使用AtomicLongFieldUpdater
    - 属性为引用数据类型，如 `String`/`Integer`/`Long` 等，使用AtomicReferenceFieldUpdater
- 使用引用类型原子类注意事项：
    - 成员属性必须volatile修饰，表示该属性在线程之间立即可见。
    - 成员属性不能被static或final修饰。
- 如果很在乎CAS的ABA问题，可以替换如下两种：
    - AtomicMarkableReference：带版本戳的原子引用类型，版本戳为boolean类型。
    - AtomicStampedReference：带版本戳的原子引用类型，版本戳为int类型。

源码：Student.java
```java
public class Student {
    private volatile long id;
    private volatile String name;

    public Student(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    public Long getId() {return id;}
    public void setId(Long id) {this.id = id;}
    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
}
```

源码：AtomicLongFieldUpdaterDemo.java
```java
/**
 * @author JoeZhou
 */
public class AtomicLongFieldUpdaterDemo {

    private static AtomicLongFieldUpdater<Student> longFieldUpdater;

    public static void main(String[] args) {

        longFieldUpdater = AtomicLongFieldUpdater.newUpdater(Student.class, "id");

        Student student = new Student(1L, "赵四");
        longFieldUpdater.get(student);
        System.out.println("当前student中的ID值：" + student.getId());

        longFieldUpdater.compareAndSet(student, 1L, 5L);
        System.out.println("当前student中的ID值如果是1就改为5：" + student.getId());

        longFieldUpdater.incrementAndGet(student);
        System.out.println("当前student中的ID+1后值：" + student.getId());

        longFieldUpdater.decrementAndGet(student);
        System.out.println("当当前student中的ID-1后值：" + student.getId());

        longFieldUpdater.addAndGet(student, 5);
        System.out.println("当前student中的ID+5后值：" + student.getId());

        long result = longFieldUpdater.accumulateAndGet(student, 5, (left, right) -> {
            System.out.print("left：" + left + "\t");
            System.out.print("right：" + right + "\n");
            return left * right;
        });
        System.out.println("当前student中的ID*5后值：" + student.getId());
        
    }
}
```

> 操作字符串类型的name，更换使用AtomicReferenceFieldUpdater即可。	