# 02009-3-7
1. 尽可能详细地描述如下代码的全过程（从编写到运行）。
```java
public class Person {
    private String name;
    private static String classInfo;
    public Person(String name) {
        this.name = name;
    }
    static {
        classInfo = "三班";
    }
    {
        System.out.println("动态块被执行...");
    }
    public static void main(String[] args) {
        Person p = new Person("赵四");
        p.setName("刘能");
        sayHello(p.getName());
    }
    static void sayHello(String name){
        System.out.println("hi I am " + name);
    }
    String getName() {return name;}
    void setName(String name) {this.name = name;}
}
```
**答案：** 整体分三部分，编写，编译和运行。
1. 编写代码：
    - 在计算机物理硬盘上编写 `Person.java` 文件。
2. 编译代码：
    - 执行命令：`javac Person.java` 
    - 检查java文件的内容是否正确（词法和语法）。
    - 得到 `Person.class` 文件，它也在计算机物理硬盘上。
3. 运行代码，执行运行命令：`java Person`。
4. JVM启动：`Connected to the target VM...`
5. JVM中的 `Bootstrap ClassLoader` 启动。
    - 按需加载 `%JAVA_HOME%\jre\lib` 下的某些的class文件（jar包）。
    - 加载另外两个类加载器。
6. `ExtClassLoader` 去按需加载 `ext` 下的某些class文件（jar包）。
7. `AppClassLoader` 去加载 `classpath` 路径下的 `Person.class`（因为它有main方法）。
    - 检验，准备和解析的工作会在整个加载的过程中交叉执行。
    - `AppClassLoader` 在方法区中创建一个对应 `Person.class` 文件的instanceKlass区域。
    - `AppClassLoader` 开始逐行加载 `Person.class` 中的内容到instanceKlass区域中。
    - `AppClassLoader` 将静态属性 `classInfo`，加载到instanceKlass区域的静态区，并分配初始值为null。
    - `AppClassLoader` 将静态方法 `main()`，加载到instanceKlass区域的静态区。
    - `AppClassLoader` 将静态方法 `sayHello()`，加载到instanceKlass区域的静态区。 
    - `AppClassLoader` 将静态块，加载到instanceKlass区域的静态区。
    - `AppClassLoader` 将动态块，加载到instanceKlass区域的非静态区。
    - `AppClassLoader` 将构造方法 `Person(){}`，加载到instanceKlass区域的非静态区。
    - `AppClassLoader` 将非静态方法 `getName()`，加载到instanceKlass区域的非静态区。
    - `AppClassLoader` 将非静态方法 `setName()`，加载到instanceKlass区域的非静态区。
    - 在堆内存中创建一个对应instanceKlass区域的java.lang.Class对象，模拟内存地址为 `0xAAAA`。
    - 非静态属性 `name`，`AppClassLoader` 会忽略它，非静态属性不进行加载。
8. 进行初始化工作
    - 为静态属性 `classInfo` 赋真正的值。
    - 执行执行静态块，将 `classInfo` 赋值为 "三班"。
9. 执行方法入口main，将其压入栈顶。
10. 执行代码：`Person p = new Person("赵四");`
    - 在堆内存中开辟空间，分配内存地址，模拟为 `0x9527`。
    - 设置实例的对象头：类型指针指向 `0xAAAA`，记录HashCode，分代年龄和锁状态等信息。
    - 设置实例数据区内容：建立非静态属性 `name`，并赋初始值为null。
    - 设置实例的补齐区：如果需要补齐则补齐，不需要则忽略。
    - 执行动态块：输出 "动态块被执行..."。
    - 执行构造函数，将属性 `name` 的值赋值为 "赵四"。
    - 在main方法的方法栈帧中创建一个局部变量 `p`。
    - 将内存地址 `0x9527` 分配给栈中的变量 `p`。
11. 执行代码：`p.setName("刘能")`
    - 在栈内存中开辟 `setName()` 的方法栈帧，其中包含了一个 `this` 和局部变量 `name`。
    - 将 `p` 的值 `0x9527` 赋值给 `this`。
    - 将局部变量 `name` 的值 "刘能" 赋值给 `this.name`。
    - `setName()` 出栈。
12. 执行代码：`p.getName()`
    - 在栈内存中开辟 `getName()` 的方法栈帧，其中包含了一个 `this`。
    - 将 `p` 的值 `0x9527` 赋值给 `this`。
    - 返回 `this.name` 的值，递交给 `sayHello()` 作为方法参数。
    - `getName()` 出栈。
13. 执行代码：`sayHello()`
    - 在栈内存中开辟 `sayHello()` 的方法栈帧，其中包含一个类型指针地址 `0xAAAA` 和局部变量 `name`。
    - 执行输出 "hi I am 刘能"
    - `sayHello()` 出栈。
14. main方法出栈，程序结束：`Disconnected from the target VM`
    
# 02009-6-3
 1. 将 `public int method();` 中的字节码进行解析。
 **答案：**
 1. 将 `public int method();` 中的字节码进行解析。
 - `public int method();`：
    - `descriptor: ()I`：
    - `flags: ACC_PUBLIC`：
    - `stack=4`：
    - `locals=1`：
    - `args_size=1`：
- `0: aload_0`：
- `1: dup`：
- `2: getfield #2 //Field num:I`：
- `5: dup_x1`：
- `6: iconst_1`：
- `7: iadd`：
- `8: putfield #2 //Field num:I`：
- `11: ireturn`：
- `LineNumberTable:`：
    - `line 10: 0`：
- `LocalVariableTable:`：
    - `Start=0`：
    - `Length=12`：
    - `Slot=0`：
    - `Name=this`：
    - `Signature=.../ByteCodeDemo;`：